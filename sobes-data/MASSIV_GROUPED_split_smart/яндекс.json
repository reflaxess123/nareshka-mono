[
  {
    "company": "Яндекс",
    "count": 126,
    "records": [
      {
        "timestamp": "2025-07-18 10:25:52",
        "content": "2025-07-18 10:25:52\n Daniil Daniil -> 2071074234:\nКомпания: Яндекс Финтех 1 этап\nЗадача 1:\nУсловий не сохранилось, но задачка была на то, что будет в консоле при обработке Promise\n      Ответы: В 4 строку вообще не зайдем. \n5 строка будет ответ 2\n8 строка undefined\nна 7 строку не попадем\n---\nЗадача 2: Задача на замыкание\n\nfunction runOnce(fn) {\n    let isCalled = false\n\n    return function(...args) {\n        if(isCalled) return undefined\n        isCalled = true\n\n        return fn(...args)\n}\n}\n\nЗ...",
        "full_content": "2025-07-18 10:25:52\n Daniil Daniil -> 2071074234:\nКомпания: Яндекс Финтех 1 этап\nЗадача 1:\nУсловий не сохранилось, но задачка была на то, что будет в консоле при обработке Promise\n      Ответы: В 4 строку вообще не зайдем. \n5 строка будет ответ 2\n8 строка undefined\nна 7 строку не попадем\n---\nЗадача 2: Задача на замыкание\n\nfunction runOnce(fn) {\n    let isCalled = false\n\n    return function(...args) {\n        if(isCalled) return undefined\n        isCalled = true\n\n        return fn(...args)\n}\n}\n\nЗадача 3:\n\nArray.prototype.groupBy = function (fn) {\nreturn this.reduce((result, item) => {\nconst key = fn(item) // Вычисляем ключ для текущего элемента\nif (!result[key]) {\n// Если такого ключа ещё нет в объекте\nresult[key] = [] // Создаём пустой массив для этого ключа\n}\nresult[key].push(item) // Добавляем элемент в соответствующую\nгруппу\nreturn result\n}, () // Начинаем с пустого объекта\n\n\nЗадача 4:\n\nfunction get(url, retry = 5) {\n    return fetch(url).then(res => res.json()).catch(err=> {\n        if (retry > 0) {\n           const newRetry = retry - 1;\n            return get(url, newRetry)\n        } else {\n            throw new Error('Заданный URL недоступен')\n        }\n    })\n}\n\nЗадача 5:\n\nconstructor() {\nthis.stack = []; // Основной стек для хранения элементов\nthis.maxStack = []; // Стек для отслеживания максимумов\n}\n\npush(elem) {\nthis.stack.push(elem);\n// Если maxStack пуст или новый элемент >= текущего\nмаксимума\nif (this.maxStack.length === 0 || elem >=\nthis.maxStack[this.maxStack.length - 1]) {\nthis.maxStack.push(elem);\n}\n}\n\nmax() {\nif (this.maxStack.length === 0) return -Infinity;\nreturn this.maxStack[this.maxStack.length - 1];\n}\n\npop() {\nconst popped = this.stack.pop();\n// Если удаляемый элемент равен текущему максимуму\nif (popped === this.maxStack[this.maxStack.length - 1]) {\nthis.maxStack.pop();\n}\nreturn popped;"
      },
      {
        "timestamp": "2025-07-17 20:49:57",
        "content": "2025-07-17 20:49:57\n Даниил -> 2071074234:\nЯндекс 1 этап технички\nЗП: говорил 250-300+\n\nЗадача 1\n\nНеобходимо написать функцию, которая на вход принимает url и retry, асинхронно ходит по этому урлу GET запросом и возвращает данные (json).\nДля получения данных использовать fetch.\nможно использовать только Promise API.\nЕсли во время запроса произошла ошибка, то пробовать запросить ещё 5 раз.\nЕсли в итоге информацию получить не удалось, вернуть ошибку \"Заданный URL недоступен\".\n\nfunction get(url, re...",
        "full_content": "2025-07-17 20:49:57\n Даниил -> 2071074234:\nЯндекс 1 этап технички\nЗП: говорил 250-300+\n\nЗадача 1\n\nНеобходимо написать функцию, которая на вход принимает url и retry, асинхронно ходит по этому урлу GET запросом и возвращает данные (json).\nДля получения данных использовать fetch.\nможно использовать только Promise API.\nЕсли во время запроса произошла ошибка, то пробовать запросить ещё 5 раз.\nЕсли в итоге информацию получить не удалось, вернуть ошибку \"Заданный URL недоступен\".\n\nfunction get(url, retry = 5) {\n        return fetch(url)\n        .then(res => res.json())\n        .catch(err => {\n            if (retry > 0) {\n                return get(url, retry - 1)\n            } else {\n                throw new Error('Заданный URL недоступен')\n            }\n        })\n    }\n\nЗадача 2\n\nРеализовать функцию compose, которая принимает\nпеременное количество функций и возвращает новую функцию.\nРезультат работы каждой функции передаетсяв следующую.\n\nfunction compose(...callbacks) {\n    return function (...args) {\n        const res = callbacks.reduceRight((acc, fn) => [fn(...args)], args);\n        return res[0];\n    }\n}\n\nЗадача 3\n\nРеализовать функцию isMonotonic, которая принимает\nмассив чисел и определяет, является ли он монотонным (не возрастающим или не убывающим).\n\nfunction isMonotonic(numbers) {\n    let direction = 0;\n\n    for (let i = 1; i < numbers.length; i++) {\n        const diff = numbers[i] - numbers[i - 1];\n\n        if (diff === 0) continue;\n\n        if (direction === 0) {\n            direction = diff > 0 ? 1 : -1;\n        } else if ((direction === 1 && diff < 0) || (direction === -1 && diff > 0)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nЗадача 4\n\nНужно написать полифилл для Array.protptype.some\nВозвращаемое значение true, если функция проверки возвращает truthy значение хотя бы для одного элемента массива. Иначе false.\n\nArray.prototype.some = function (callback, myThis) {\n    const bindedCallback = myThis ? callback.bind(myThis) : this;\n\n    for (let i = 0; i < this.length; i++) {\n        if (bindedCallback(this[i], i, this)) {\n            return true;\n        }\n    }\n\n    return false;\n}"
      },
      {
        "timestamp": "2025-07-14 13:42:11",
        "content": "2025-07-14 13:42:11\n Ivan Kulyaev -> 2071074234:\n1. Яндекс 1 этап\n2. Написала HR\n3. ЗП просил от 250к\n\nВопросы:\n\n1. Про опыт\n2. Виды рендеринга в Next.js\n3. Зачем нужен next.js\n4. SEO, метатеги, настройка его в Next.js\n5. Оптимизация некста\n6. PWA, service worker и другие виды веб-приложений (SPA, MPA)\n7. event-loop\n8. Всплытие и погружение\n9. Как отменить распространения события\n10. Где решаю задачи и как к ним готовлюсь\n11. Сложность алгоритма\n12. Как юзаю AI в работе\n\nЗадачи:\n\nВсе, кроме MaxS...",
        "full_content": "2025-07-14 13:42:11\n Ivan Kulyaev -> 2071074234:\n1. Яндекс 1 этап\n2. Написала HR\n3. ЗП просил от 250к\n\nВопросы:\n\n1. Про опыт\n2. Виды рендеринга в Next.js\n3. Зачем нужен next.js\n4. SEO, метатеги, настройка его в Next.js\n5. Оптимизация некста\n6. PWA, service worker и другие виды веб-приложений (SPA, MPA)\n7. event-loop\n8. Всплытие и погружение\n9. Как отменить распространения события\n10. Где решаю задачи и как к ним готовлюсь\n11. Сложность алгоритма\n12. Как юзаю AI в работе\n\nЗадачи:\n\nВсе, кроме MaxStack отсюда и sleep с intersection с этого собеса"
      },
      {
        "timestamp": "2025-07-13 04:26:44",
        "content": "2025-07-13 04:26:44\n Ruslan -> 2071074234:\nКомпания: Яндекс (10.07 1 этап ТЕХ)\nГоворили за опыт.\nЧто такое HTTP запросы?\nЧто такое CORS?\nКак реализовать работу CORS?\n\nЗадача Event loop\n\nconsole.log('apple');\n\nsetTimeout(() => console.log('pear'));\nrequestAnimationFrame(() => console.log('raspberry');\n// можно подушнить что setTimeout и requesAnimationFrame будут\n// выполняться в разной последовательности в зависимости от браузера\n\nPromise.resolve().then(() => console.log('melon'));\nnew Promise((...",
        "full_content": "2025-07-13 04:26:44\n Ruslan -> 2071074234:\nКомпания: Яндекс (10.07 1 этап ТЕХ)\nГоворили за опыт.\nЧто такое HTTP запросы?\nЧто такое CORS?\nКак реализовать работу CORS?\n\nЗадача Event loop\n\nconsole.log('apple');\n\nsetTimeout(() => console.log('pear'));\nrequestAnimationFrame(() => console.log('raspberry');\n// можно подушнить что setTimeout и requesAnimationFrame будут\n// выполняться в разной последовательности в зависимости от браузера\n\nPromise.resolve().then(() => console.log('melon'));\nnew Promise((resolve, reject) => {  \n console.log('orange');  \n .then(() => {\n  console.log('pineapple')\n })\n});\nconsole.log('lime')\n \n\nВторая задача это полный рефакторинг Реакт-компонента\nТребуется перепесать классовый компонент на компонент на хуках\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport TodoInput from './TodoInput';\nimport TodoItem from './TodoItem';\n\nconst generateID = () =>\n  `${Date.now().toString(36)}-${Math.random().toString(36).substr(2, 9)}`;\n\nconst Todo = () => {\n  const [todoItems, setTodoItems] = useState([]);\n  const [completedItemIds, setCompletedItemIds] = useState([]);\n\n  // Загрузка из localStorage\n  useEffect(() => {\n    const saved = localStorage.getItem('todos');\n    if (saved) {\n      try {\n        const parsed = JSON.parse(saved);\n        setTodoItems(parsed.todoItems || []);\n        setCompletedItemIds(parsed.completedItemIds || []);\n      } catch {\n        console.warn('Saved todos non-existent or corrupt.');\n      }\n    }\n  }, []);\n\n  // Сохранение в localStorage\n  useEffect(() => {\n    localStorage.setItem(\n      'todos',\n      JSON.stringify({ todoItems, completedItemIds })\n    );\n  }, [todoItems, completedItemIds]);\n\n  const addTodoItem = useCallback((text) => {\n    const newItem = { text, id: generateID() };\n    setTodoItems((prev) => [...prev, newItem]);\n  }, []);\n\n  const toggleItemCompleted = useCallback((id) => {\n    setCompletedItemIds((prev) =>\n      prev.includes(id)\n        ? prev.filter((itemId) => itemId !== id)\n        : [...prev, id]\n    );\n  }, []);\n\n  return (\n    <div className=\"todo-container\">\n      {todoItems.map((item) => (\n        <TodoItem\n          key={item.id}\n          {...item}\n          completedItemIds={completedItemIds}\n          toggleItemCompleted={toggleItemCompleted}\n        />\n      ))}\n      <TodoInput onAdd={addTodoItem} />\n    </div>\n  );\n};\n\nexport default Todo;"
      },
      {
        "timestamp": "2025-07-11 10:52:07",
        "content": "2025-07-11 10:52:07\n Эмир -> 2071074234:\nЯндекс 2 второй этап. Экспериментальный\nОбщее задание провести лайв ревью кода. \n\nБыл код со скроллом и запросами при скролле \nНужно оптимизировать \nНайти улучшения в коде\n\n1. Что такое и для чего чего нужен Debounce напиши его \n‘’’function debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n‘’’\n2. Что такое и для чего н...",
        "full_content": "2025-07-11 10:52:07\n Эмир -> 2071074234:\nЯндекс 2 второй этап. Экспериментальный\nОбщее задание провести лайв ревью кода. \n\nБыл код со скроллом и запросами при скролле \nНужно оптимизировать \nНайти улучшения в коде\n\n1. Что такое и для чего чего нужен Debounce напиши его \n‘’’function debounce(func, delay) {\n  let timeoutId;\n  \n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n‘’’\n2. Что такое и для чего нужен Throttle \n‘’’\n\nfunction throttle(func, delay) {\n  let lastCall = 0;\n  return function (...args) {\n    const now = Date.now();\n    if (now - lastCall >= delay) {\n      lastCall = now;\n      func.apply(this, args);\n    }\n  };\n}\n\n‘’’\n3. Что такое всплытие событий?\n4. Проведи ревью кода \n(Не сохранилось)\n5. Как отменить всплытие событий"
      },
      {
        "timestamp": "2025-07-10 20:28:31",
        "content": "2025-07-10 20:28:31\n Виталий -> 2071074234:\nЯндекс.\nпервый этап.\nHR написала.\nЗП не указана\n\n1. Селайте обертку над функцией, чтобы она вызывалась один раз. Всё последующие вызовы должны вернуть undefined\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n\n2.Необходимо реализовать метод groupByб расширяющий с...",
        "full_content": "2025-07-10 20:28:31\n Виталий -> 2071074234:\nЯндекс.\nпервый этап.\nHR написала.\nЗП не указана\n\n1. Селайте обертку над функцией, чтобы она вызывалась один раз. Всё последующие вызовы должны вернуть undefined\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n\n2.Необходимо реализовать метод groupByб расширяющий стандартный метод массивов. метод должен возвращать сгруппированную версию массива - объектаб в котором каждый ключ является результатом выполнения переданой функции fn(arr[i]), а каждое значение - массивом, содержащим исходный массив с этим ключом\nArray.prototype.groupBy = function (fn) {\n  return this.reduce((result, item) => {\n    const key = fn(item) // Вычисляем ключ для текущего элемента\n    if (!result[key]) {\n      // Если такого ключа ещё нет в объекте\n      result[key] = [] // Создаём пустой массив для этого ключа\n    }\n    result[key].push(item) // Добавляем элемент в соответствующую группу\n    return result\n  }, {}) // Начинаем с пустого объекта\n}\n\n3. использовать Promise API для реализации 5 запросов на сервер. далее выбрасывает ошибку\n\nfunction get(url, retriesLeft = 5) {\n    return new Promise((resolve, reject) => {\n        fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(response.status);\n                }\n                return response.json();\n            })\n            .then(data => resolve(data))\n            .catch(error => {\n                if (retriesLeft <= 1) {\n                    reject(new Error(\"Заданный URL недоступен\"));\n                } else {\n                    get(url, retriesLeft - 1).then(resolve).catch(reject);\n                }\n            });\n    });\n}\n\n\n\n\n 4. Реализовать структуру данных MaxStack, в которой есть методы:\n pop() – удаляет и возвращает последний добавленный элемент за O(1),\n         кидает исключение или возвращает ошибку, если стек пустой\n push(value) – добавляет элемент в стек за O(1)\n max() – возвращает максимальное значение среди всех элементов стека за O(1),\n          кидает исключение или возвращает ошибку, если стек пустой\n\nclass MaxStack {\n    constructor() {\n        this.stack = [];//\n        this.maxStack = []\n\n    }\n\n    push(a) {\n        this.stack.push(a)\n        if(this.maxStack.length === 0 || a >= this.maxStack[this.maxStack.length - 1]) {\n            this.maxStack.push(a)\n        }\n    }\n\n    pop(){\n        if(this.stack.length === 0) {\n            throw new Error(\"Стук Пуст...\")\n        }\n\n        const a = this.stack.pop()\n\n        if(a === this.maxStack[this.maxStack.length - 1]) {\n            this.maxStack.pop()\n        }\n        return a\n    }\n\n    max() {\n        if (this.maxStack.length === 0) {\n            throw new Error(\"Стек пуст\")\n        }\n        return this.maxStack[this.maxStack.length - 1]\n    }\n\n}"
      },
      {
        "timestamp": "2025-07-09 15:06:36",
        "content": "2025-07-09 15:06:36\n Артем Покатилов -> 2071074234:\nЯндекс Финтех Встреча с командой\nЗП: от 250к\nhr сам написал\n\nВопросы:\n1. Расскажи про задачи интересные\n2. Расскажи про процессы в команде какие были\n3. Было ли у вас дежурство\n4. Какими инструментами пользовались, когда падал прод\n5. Был ли настроен sentry изначально или сам настраивал\n6. По мимо задач по разработке новых фич, чем еще занимался?",
        "full_content": "2025-07-09 15:06:36\n Артем Покатилов -> 2071074234:\nЯндекс Финтех Встреча с командой\nЗП: от 250к\nhr сам написал\n\nВопросы:\n1. Расскажи про задачи интересные\n2. Расскажи про процессы в команде какие были\n3. Было ли у вас дежурство\n4. Какими инструментами пользовались, когда падал прод\n5. Был ли настроен sentry изначально или сам настраивал\n6. По мимо задач по разработке новых фич, чем еще занимался?"
      },
      {
        "timestamp": "2025-07-07 15:36:45",
        "content": "2025-07-07 15:36:45\n Fetisov Artem -> 2071074234:\n1. Яндекс 1 этап\nHR сама написала(сказала что ищут фронта в Яндекс Маркет)\nЗП 300к\n\n\n1. Сделать обертку над функцией, чтобы она вызывалась один раз. Все последующие вызовы должны вернуть undefined.\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n\n2. Написат...",
        "full_content": "2025-07-07 15:36:45\n Fetisov Artem -> 2071074234:\n1. Яндекс 1 этап\nHR сама написала(сказала что ищут фронта в Яндекс Маркет)\nЗП 300к\n\n\n1. Сделать обертку над функцией, чтобы она вызывалась один раз. Все последующие вызовы должны вернуть undefined.\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n\n2. Написать функцию которая спит определенное время а затем возвращает значение.\nfunction sleep(duration) {\n  // Возвращаем новый промис\n  return new Promise(resolve => {\n    // Используем setTimeout для задержки\n    setTimeout(() => {\n      // После завершения задержки, вызываем resolve промиса\n      resolve()\n    }, duration)\n  })\n}\n\n3. Необходимо реализовать метод groupBy, расширяющий стандартные методы массивов. Метод должен возвращать сгруппированную версию массива — объект, в котором каждый ключ является результатом выполнения переданной функции fn(arr[i]), а каждое значение — массивом, содержащим все элементы исходного массива с этим ключом.\nArray.prototype.groupBy = function (fn) {\n  return this.reduce((result, item) => {\n    const key = fn(item) // Вычисляем ключ для текущего элемента\n    if (!result[key]) {\n      // Если такого ключа ещё нет в объекте\n      result[key] = [] // Создаём пустой массив для этого ключа\n    }\n    result[key].push(item) // Добавляем элемент в соответствующую группу\n    return result\n  }, {}) // Начинаем с пустого объекта\n}\n\n\n4. Необходимо проверить решение задачи по двум сервисам, вызвав checkResult(url1, solution), checkResult(url2, solution)\ncheckResult: (url: string, solution: string | number) => Promise<boolean>;\n* Если оба запроса вернули true - вывести succes\n* Если хоть один вернул false - вывести fail\n* Если хоть зареджектился - вывести error\n* Если хоть один отвечает дольше 1 сек - вывести timeout\nimport { checkResult } from 'myLib'\n\nconst solution = 'Any answer'\nconst url1 = 'yandex.ru'\nconst url2 = 'google.com'\n\ncheckResult(url, solution)\ncheckResult(url, solution)\n\nasync function check() {\n  const TIMEOUT_MS = 1000\n\n  // Оборачиваем каждый вызов в Promise.race с таймаутом\n  const withTimeout = url => {\n    return Promise.race([\n      checkResult(url, solution), // основной вызов\n      new Promise(\n        (\n          _,\n          reject // таймаут\n        ) => setTimeout(() => reject(new Error('timeout')), TIMEOUT_MS)\n      ),\n    ])\n  }\n\n  try {\n    // Запускаем оба запроса параллельно\n    const [res1, res2] = await Promise.all([\n      withTimeout(url1),\n      withTimeout(url2),\n    ])\n\n    // Если оба true\n    if (res1 === true && res2 === true) {\n      console.log('success')\n    }\n    // Если хотя бы один false\n    else if (res1 === false || res2 === false) {\n      console.log('fail')\n    }\n  } catch (err) {\n    // Если ошибка — различаем таймаут и другую ошибку\n    if (err.message === 'timeout') {\n      console.log('timeout')\n    } else {\n      console.log('error')\n    }\n  }\n}\n\ncheck()\n\n5. У вас есть два пользователя, у каждого из которых записаны интервалы времени, когда они были свободны. Эти интервалы представлены в виде массива пар [start, end], где start - начало интервала, end - конец интервала. Интервалы у каждого пользователя отсортированы в порядке возрастания и не пересекаются между собой. Напишите функцию intersection(user1, user2), которая находит все интервалы времени, когда обы пользователя были свободны одновременно.\nfunction intersection(user1, user2) {\n  let i = 0;\n  let j = 0;\n  const result = [];\n\n  while (i < user1.length && j < user2.length) {\n    const [start1, end1] = user1[i];\n    const [start2, end2] = user2[j];\n\n    // вычисляем пересечение\n    const start = Math.max(start1, start2);\n    const end = Math.min(end1, end2);\n\n    if (start < end) {\n      result.push([start, end]);\n    }\n\n    // двигаем указатель в том массиве, у которого текущий интервал раньше заканчивается\n    if (end1 < end2) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n\n  return result;\n}"
      },
      {
        "timestamp": "2025-07-07 12:45:39",
        "content": "2025-07-07 12:45:39\n Никита -> 2071074234:\nЯндекс 2 этап\nЗП: от 240\n\nЗадача 1:\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение.\n\nТаймлайн:\n(приходит) 7 1 2 3 6 5 4    8\n(рисунок)   . 1 2 3 . . 4 5 6 7 8\n\nСообщения от сервера приходят в обработчик фу...",
        "full_content": "2025-07-07 12:45:39\n Никита -> 2071074234:\nЯндекс 2 этап\nЗП: от 240\n\nЗадача 1:\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение.\n\nТаймлайн:\n(приходит) 7 1 2 3 6 5 4    8\n(рисунок)   . 1 2 3 . . 4 5 6 7 8\n\nСообщения от сервера приходят в обработчик функции connect:\n\nconnect((msg) => {\n    ...\n});\n\nОтображать сообщения нужно с помощью функции `render`:\nrender(msg)\n*/\n\nconst solution = (connect, render) => {};\nfunction solution(connect, render) {\n  const map = new Map();  // Храним сообщения по id\n  let currId = 1;\n\n  connect((msg) => {\n    map.set(msg.id, msg); // Просто сохраняем сообщение по id\n\n    // Пока есть сообщение с ожидаемым id — рендерим и двигаемся дальше\n    while (map.has(currId)) {\n      const messageToRender = map.get(currId);\n      render(messageToRender); // Вызываем render прямо сейчас\n      map.delete(currId);      // Удаляем отрисованное сообщение\n      currId++;\n    }\n  });\n}\n\nЗадача 2\nНе решил (Решение из базы)\n//Дан массив ссылок: ['url1', 'url2', ...] и лимит одновременных запросов (limit) Необходимо реализовать функцию, которыя опросит урлы в том //порядку, в котором они идут в массиве, и вызовет callback с массивом ответов ['url1_answer', 'url2_anser', ...] так, чтобы в любой момент //времени выполнялось не более limit запросов (как только любой из них завершился, сразу же отправится следующий) Т.е. нужно реализовать шину с шириной равной limit.\n// доп. добавить мемоизацию\nfunction parallelLimit(urls, limit, callback) {\n    // Если limit больше количества URL, устанавливаем его равным длине массива URL\n    limit = Math.min(limit, urls.length);\n    \n    let results = new Array(urls.length);\n    let active = 0;\n    let index = 0;\n    const cache = new Map(); // Добавляем кэш для мемоизации\n    \n    function processNext() {\n        if (index >= urls.length && active === 0) {\n            callback(results);\n            return;\n        }\n        \n        while (index < urls.length && active < limit) {\n            const currIndex = index;\n            const url = urls[currIndex];\n            index++;\n            active++;\n            \n            // Проверяем наличие URL в кэше\n            if (cache.has(url)) {\n                // Если URL уже в кэше, берём результат оттуда\n                results[currIndex] = cache.get(url);\n                active--;\n                // Используем setTimeout для асинхронности и предотвращения переполнения стека\n                setTimeout(processNext, 0);\n            } else {\n                // Если URL нет в кэше, выполняем запрос\n                fetch(url)\n                    .then(response => {\n                        // Сохраняем ответ в кэш\n                        cache.set(url, response);\n                        results[currIndex] = response;\n                        active--;\n                        processNext();\n                    });\n            }\n        }\n    }\n    \n    // Обработка пустого массива URL\n    if (urls.length === 0) {\n        callback(results);\n        return;\n    }\n    \n    processNext();\n}"
      },
      {
        "timestamp": "2025-07-07 09:38:13",
        "content": "2025-07-07 09:38:13\n Ivan -> 2071074234:\nНазвание компании: Яндекс 07.07\nЗП: 300\n\nСекция алгоритмических задач\n\nБыл душный интервьюер. Часто цепляется к словам и деталям решения почему именно так, а не иначе. Лучше говорить только то в чем уверен и рассуждать вслух аккуратно, чтоб не давать повода зацепиться.\n\n1. Легнеда задачи:  есть чат с сообщениями, сообщения могут приходить от сервера в произвольном порядке (проблема race condition). \nпример сообщения {id: 1, text: 'lorem ipsum'}\nКейс: если...",
        "full_content": "2025-07-07 09:38:13\n Ivan -> 2071074234:\nНазвание компании: Яндекс 07.07\nЗП: 300\n\nСекция алгоритмических задач\n\nБыл душный интервьюер. Часто цепляется к словам и деталям решения почему именно так, а не иначе. Лучше говорить только то в чем уверен и рассуждать вслух аккуратно, чтоб не давать повода зацепиться.\n\n1. Легнеда задачи:  есть чат с сообщениями, сообщения могут приходить от сервера в произвольном порядке (проблема race condition). \nпример сообщения {id: 1, text: 'lorem ipsum'}\nКейс: если сообщения пришли от сервера в порядке 1-2-3-6-4-5, то в чате они все равно должны оказаться 1-2-3-4-5-6. (6 не отобразится пока не придет 5)\nfunction solution(connect, render) {\n    // Храним сообщения в Map, где ключ - id сообщения, значение - само сообщение\n    const messages = new Map();\n    // Ожидаем сообщение с этим id следующим\n    let nextExpectedId = 1;\n\n    connect(function onMessage(message) {\n        // Добавляем сообщение в Map\n        messages.set(message.id, message);\n\n        // Пока есть ожидаемое сообщение, рендерим его и увеличиваем nextExpectedId\n        while (messages.has(nextExpectedId)) {\n            render(messages.get(nextExpectedId));\n            messages.delete(nextExpectedId);\n            nextExpectedId++;\n        }\n    });\n}\n2. Нужно сделать обход дерева без использования рекурсии. Дерево представляет собой структуру папок {name: '', childrens[]}\nНужно вывести структуру в консоль в красивом виде, чтоб количество пробелов соответствовало вложенности папки.\nconst stack = [{data, level: 0}]\n\nwhile (stack.length > 0) {\n  // Извлекаем текущий элемент из стека\n  const { data, level } = stack.pop();\n  console.log(\" \".repeat(level*2) + data.name)\n  // Если есть дети, добавляем их в стек в обратном порядке\n  if (data.children && Array.isArray(data.children)) {\n    for (let i = data.children.length - 1; i >= 0; i--) {\n      stack.push({\n        data: data.children[i],\n        level: level + 1,\n      });\n    }\n  }\n}"
      },
      {
        "timestamp": "2025-07-04 13:50:58",
        "content": "2025-07-04 13:50:58\n Sodnom Tyksheev -> 2071074234:\nЯндекс 2 этап\nЗП: 250\n\nТолько одну задачу успели порешать:\n\n/*У нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'Moscow', to: 'SPb' },\n    { from: 'NY', to: 'London' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов \nв порядке следования по маршруту.\n*/\n\nfunction getRoute(tickets...",
        "full_content": "2025-07-04 13:50:58\n Sodnom Tyksheev -> 2071074234:\nЯндекс 2 этап\nЗП: 250\n\nТолько одну задачу успели порешать:\n\n/*У нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'Moscow', to: 'SPb' },\n    { from: 'NY', to: 'London' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов \nв порядке следования по маршруту.\n*/\n\nfunction getRoute(tickets = [], start) {\n    const map = new Map()\n    const res = []\n    let finishCity \n\n    for(const el of tickets){\n        map.set(el.from, el)\n    }\n\n    let current = tickets.find(i => i.from === start);\n    console.log(current)\n\n    while(current && map.has(current.from)){\n        res.push(current);\n\n        current = map.get(current.to);\n    }\n\n    return res\n}\n\nconsole.log(\n    getRoute([\n    { from: 'London', to: 'Moscow' },\n    { from: 'Moscow', to: 'SPb' },\n    { from: 'NY', to: 'London' },\n], 'NY')\n)"
      },
      {
        "timestamp": "2025-07-01 16:21:23",
        "content": "2025-07-01 16:21:23\n Aintripin -> 2071074234:\nКомпания: Яндекс (01.07.2025)\n\nВакансия: Frontend-разработчик\n\nЗП: с HR'ом обговаривал, что от 250,000 смотрю. Вилки нет, но я \"в вилке\"\n\n================================================================================================\n\nЗадачи:\n\n📝 I. Даны три секции кода, нужно написать результат выполнения каждого console.log():\nvar n = 1;\n\nfunction f(n) {\n  // Внутри функции создается локальная переменная `n`, которая является копией\n  // значения, ...",
        "full_content": "2025-07-01 16:21:23\n Aintripin -> 2071074234:\nКомпания: Яндекс (01.07.2025)\n\nВакансия: Frontend-разработчик\n\nЗП: с HR'ом обговаривал, что от 250,000 смотрю. Вилки нет, но я \"в вилке\"\n\n================================================================================================\n\nЗадачи:\n\n📝 I. Даны три секции кода, нужно написать результат выполнения каждого console.log():\nvar n = 1;\n\nfunction f(n) {\n  // Внутри функции создается локальная переменная `n`, которая является копией\n  // значения, переданного в функцию. Изменение этой локальной переменной\n  // не влияет на внешнюю переменную `n`.\n  n = 3;\n}\nf(n);\n\n// Выведет 1, так как функция f работала с копией значения.\nconsole.log(n); // >> 1\n\n// -------------------\n\n// --- Секция 2 ---\n\nvar obj = { a: 1 };\n\nfunction f1(o) {\n  // В функцию передается ссылка на объект. Переменные `o` (внутри) и `obj` (снаружи)\n  // указывают на один и тот же объект в памяти.\n  // Мы мутируем (изменяем) свойство этого объекта.\n  o.a = 5;\n}\nf1(obj);\n\n// Выведет { a: 5 }, так как объект был изменен по ссылке.\nconsole.log(obj); // >> { a: 5 }\n\n// -------------------\n\n// --- Секция 3 ---\n\nvar obj2 = { a: 1 }; // Переименовал, чтобы избежать ошибки Redeclaration of var obj\n\nfunction f2(o) {\n  // Здесь происходит не мутация объекта, а переприсваивание локальной\n  // переменной `o`. Теперь она указывает на совершенно новый объект.\n  // Связь с исходным объектом (на который указывает `obj2`) теряется.\n  o = { hello: 1 };\n}\nf2(obj2);\n\n// Выведет { a: 1 }, так как исходный объект не был изменен.\n// Функция f2 лишь изменила то, на что указывала её внутренняя переменная `o`.\nconsole.log(obj2); // >> { a: 1 }\n\n—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————\n\nII. Реализовать метод times для числового объекта. Функция должна принимать callback и вызывать его заданное количество раз с индексом текущей операции. \nВот пример:\n(3).times(console.log)\n// 0\n// 1\n// 2\n\nПлан решния:\n1) через Number.prototype делаем Number.prototype.times = function() {}\n2) доступ к самому числу будем получать через this, потому что оно будет ссылаться на сам экземпляр, на котором был вызван метод. Т.е. у нас в примере (3).times this будет равно объекту Number со значением 3. Чтобы использовать это в цикле, мы получим его значение через this.ValueOf()\n2.1) *тут есть вероятность, что доебётся что это за valueOf() такое*. Это либо распаковка, либо анбоксинг. У нас в JS есть примитивные типы (number, string, Boolean и т.д.), а есть ещё объекты. У примитивов нет методов.\n> boxing/упаковка — это когда мы пытаемся получить доступ к свойству или методу у примитивного значения (как в нашем случае с (3).times(...)). Для этого создаётся объект-обёртка. Т.е. для числа 3 создаётся new Number(3). \n> теперь, когда у нас есть временной объект new Number(3), мы можем вызвать на нём метод .times(), т.к. этот метод в его прототипе Number.prototype. Внутри этого метода this ссылается на этот объект-обёртку new Number(3)\n> unboxing/распаковка: метод valueOf — это стандартный метод всех объектов-обёрток, который возвращает исходное примитивное значение, которое у нас \"спрятано\" внутри объекта.\n>> поэтому, когда мы вызываем this.ValueOf(), мы \"распаковываем\" коробку new Number(3) и достаём уже из неё сам примитив, т.е. 3\n>>> если уж совсем доебётся, то это ещё часть механизма type coercion/conversion aka \"преобразования типов\". Т.е. у нас JS пытается увидеть примитив, а встречает объект. И поэтому пытается его преобразовать в примитив. Для этого и используется valueOf(). Если тот не возвращает примитив, то вызывается toString\n3. у нас по задаче нужно вызвать это всё N раз. Для этого захуярим цикл for, который будет от 0 до N - 1 итерироваться\n4. функция должна принимать callback. Предлагаю добавить проверку на то, является ли переданный аргумент функцией. Это чтобы предотвратить ошибки. Например, если метод вызовут некорректно, например\n(3).times()"
      },
      {
        "timestamp": "2025-07-01 14:28:08",
        "content": "2025-07-01 14:28:08\n Alexander Biryukov -> 2071074234:\nЯндекс 1 Этап\nЗП: 300к на руки\n\n1 задача \nВопросы:\nСпросил за rest оператор, и что если будем делать если у нас ES5.\nЧто такое arguments\nЧто такое псевдомассив\n\nfunction strjoin(separator, ...arr) {\n  console.log(arguments)\n  return arr.join(separator);\n}\n\n2 задача\n\nВопросы:\nЧто такое промисы?\n\nPromise.resolve(1)\n  .then(x => x + 1) // 2\n  .then(x => { throw x }) // выбрасывает 2\n  .then(x => console.log(x)) // пропускается из-за ошибки\n  .c...",
        "full_content": "2025-07-01 14:28:08\n Alexander Biryukov -> 2071074234:\nЯндекс 1 Этап\nЗП: 300к на руки\n\n1 задача \nВопросы:\nСпросил за rest оператор, и что если будем делать если у нас ES5.\nЧто такое arguments\nЧто такое псевдомассив\n\nfunction strjoin(separator, ...arr) {\n  console.log(arguments)\n  return arr.join(separator);\n}\n\n2 задача\n\nВопросы:\nЧто такое промисы?\n\nPromise.resolve(1)\n  .then(x => x + 1) // 2\n  .then(x => { throw x }) // выбрасывает 2\n  .then(x => console.log(x)) // пропускается из-за ошибки\n  .catch(err => console.log(err)) // 2\n  .then(x => Promise.resolve(x)) // undefined (catch ничего не возвращает)\n  .catch(err => console.log(err)) // не сработает\n  .then(x => console.log(x)) // undefined\n\n3 задача\n\n\n// Написать декоратор для функции, который ограничивает число вызовов.\n//\n// callLimit(fn, limit, callback), принимает следующие аргументы:\n// fn - функция, которую декодируем;\n// limit - маскимальное число вызовов\n// callback - вызывается, когда совершен последний вызов. Опционально.\n// У вызываемой функции должен быть метод для перезагрузки счетчика в начале\n\nfunction callLimit(fn, limit, callback) {\n  let count = 0 // Счётчик вызовов\n\n  // Обёртка над исходной функцией\n  function wrapper(...args) {\n    if (count >= limit) return // Прекратить выполнение, если лимит превышен\n\n    count++ // Увеличить счётчик\n\n    // Если вызов достиг лимита — вызвать callback (если он передан)\n    if (count === limit && typeof callback === 'function') {\n      callback()\n    }\n\n    // Вызов оригинальной функции с переданными аргументами\n    return fn.apply(this, args)\n  }\n\n  // Метод для ручного сброса счётчика вызовов\n  wrapper.reset = function () {\n    count = 0\n  }\n\n  return wrapper // Вернуть обёрнутую функцию\n}\n\n\n4 Задача\n\n/**\n * @param {Function} fn - Асинхронная функция\n * @param {number} t - Время ограничения в миллисекундах\n**/\nconst timelimited = function (fn, t) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      // Запускаем асинхронную функцию\n      const fnPromise = fn(...args).then(resolve).catch(reject);\n\n      // Устанавливаем таймер на t миллисекунд\n      const timer = setTimeout(() => {\n        reject(\"Time limit exceeded\"); // Реджектим, если время истекло\n      }, t);\n\n      // Если функция успевает выполниться, очищаем таймер\n      fnPromise.finally(() => clearTimeout(timer));\n    });\n  };\n};\n\n\n5 задача\n\nВопросы: \nКакие сложности алгоритмов бывают.\nОписать и рассказать в чем разница\n\n\nclass MaxStack {\n    constructor() {\n        this.stack = []; // Основной стек\n        this.maxStack = []; // Вспомогательный стек для хранения максимумов\n    }\n\n    // Добавление элемента в стек\n    push(x) {\n        this.stack.push(x);\n        // Если maxStack пуст или x >= текущего максимума, добавляем x в maxStack\n        if (this.maxStack.length === 0 || x >= this.maxStack[this.maxStack.length - 1]) {\n            this.maxStack.push(x);\n        }\n    }\n\n    // Удаление и возврат верхнего элемента\n    pop() {\n        if (this.stack.length === 0) {\n            throw new Error(\"Stack is empty\");\n        }\n        const popped = this.stack.pop();\n        // Если удалённый элемент равен текущему максимуму, удаляем его из maxStack\n        if (popped === this.maxStack[this.maxStack.length - 1]) {\n            this.maxStack.pop();\n        }\n        return popped;\n    }\n\n\n    // Возврат максимального элемента\n    max() {\n        if (this.maxStack.length === 0) {\n            throw new Error(\"Stack is empty\");\n        }\n        return this.maxStack[this.maxStack.length - 1];\n    }\n}"
      },
      {
        "timestamp": "2025-06-27 09:59:38",
        "content": "2025-06-27 09:59:38\n Артем Покатилов -> 2071074234:\nЯндекс Фантех 3 этап\nЗП: от 250к\nhr сам написал\n\nВопросы:\n\nКакая твоя роль на проекте? За что отвечаешь?\nМенторил?\nРазговаривал ли со смежниками? (про бекендеров и т.д. внутри команды)\nНасколько часто приходится общаться с командой?\nРасскажи про большую и интересную задачу?\nСам предлагал какие то решения?\nКогда проект начался и сколько он длился?\nПостановка задачи была со стороны заказчика? Ты сам не предлагал каких то фичей?\nВопрос про CI/CD. ...",
        "full_content": "2025-06-27 09:59:38\n Артем Покатилов -> 2071074234:\nЯндекс Фантех 3 этап\nЗП: от 250к\nhr сам написал\n\nВопросы:\n\nКакая твоя роль на проекте? За что отвечаешь?\nМенторил?\nРазговаривал ли со смежниками? (про бекендеров и т.д. внутри команды)\nНасколько часто приходится общаться с командой?\nРасскажи про большую и интересную задачу?\nСам предлагал какие то решения?\nКогда проект начался и сколько он длился?\nПостановка задачи была со стороны заказчика? Ты сам не предлагал каких то фичей?\nВопрос про CI/CD. Что знаешь про CI/CD? Настраивал ли сам его?\nКак происходит заливание нового кода в продакшн? (Про CI/CD)\n Где начинают выполняться проверки? (Про машинку и контейнер)\nСам пайплайн видел? Где все это происходит понимаешь?\nКогда происходит сборка PROD, DEV и TEST стенды?\n\nПро тесты (смотреть скрин тут https://t.me/c/2071074234/489/133701):\n\nКакие виды тесты ты знаешь? Какие ты бы тесты внедрил в этот проект?\nПишите ли вы юнит тесты у себя на проекте?\nКогда бы ты хотел чтобы тесты запускались? (Про CI/CD)\nПочему тесты могут быть нестабильные? Какие тесты могут быть нестабильные?\nПриходилось ли дорабатывать какие нибудь тесты на проекте?\nПриходилось ли решать проблемы с оптимизацией\nКакие действия если тебе сказали что сайт тормозит?\nПробовал ли сам разбираться в LigthHouse?\nКакие то системные решения знаешь? Чтобы оптимизировать приложение?\nБыл ли опыт с метриками интерактивности?\nЗнаешь что такое OpenGraph?\nЗачем нужен SSR?\nВидел ли теги og? Для чего используются теги og?\n\nПро Софты:\n\nКакие улучшения ты привнес в проект?\nПриведи пример проекта, который был успешно реализованный благодаря твоему вкладу, хотя без тебя он мог бы быть не законченным?\nБыл ли кейс недопонимания?"
      },
      {
        "timestamp": "2025-06-26 12:32:30",
        "content": "2025-06-26 12:32:30\n Alexander K -> 2071074234:\nЯндекс 1 этап\n\n1 задача\n\nfunction any(promises) {\n  return new Promise((resolve, reject) => {\n    const errors = [];\n    let rejCount = 0;\n    \n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch((err) => {\n          errors[i] = err;\n          rejCount++;\n          \n          if (rejCount === promises.length) {\n            reject(new AggregateError(errors, 'No Promise in any was resolved'));\n          }\n ...",
        "full_content": "2025-06-26 12:32:30\n Alexander K -> 2071074234:\nЯндекс 1 этап\n\n1 задача\n\nfunction any(promises) {\n  return new Promise((resolve, reject) => {\n    const errors = [];\n    let rejCount = 0;\n    \n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch((err) => {\n          errors[i] = err;\n          rejCount++;\n          \n          if (rejCount === promises.length) {\n            reject(new AggregateError(errors, 'No Promise in any was resolved'));\n          }\n        });\n    });\n  });\n}\n2.\nfunction runOnce(fn) {\n  let isCalled = false;\n  \n  return function (...args) {\n    if (isCalled) {\n      return undefined;\n    }\n    isCalled = true;\n    return fn(...args);\n  }\n}\n3.\nfunction compose(...funcs) {\n  return function (...args) {\n    return funcs.reduceRight((acc, fn) => {\n      return [fn(...acc)];\n    }, args)[0];\n  };\n}\n\n4.Реализовать MaxStack с методами pop push и max \n\n```\nclass MaxStack {\n  constructor() {\n    this.stack = [];      \n    this.maxStack = [];   \n  }\n\n  push(value) {\n    this.stack.push(value);\n   \n    const currentMax = this.maxStack.length === 0 ? value : Math.max(value, this.maxStack[this.maxStack.length - 1]);\n    this.maxStack.push(currentMax);\n  }\n\n  pop() {\n    if (this.stack.length === 0) return null;\n    this.maxStack.pop();   \n    return this.stack.pop(); \n  }\n\n  max() {\n    if (this.maxStack.length === 0) return null;\n    return this.maxStack[this.maxStack.length - 1]\n  }\n}\n```"
      },
      {
        "timestamp": "2025-06-24 13:48:29",
        "content": "2025-06-24 13:48:29\n Sodnom Tyksheev -> 2071074234:\nЯндекс Фантех 1 этап лайвкодинг\nЗП:250K\nhr сам написал\n\n\n1. Сделай такую обёртку над функцией, чтобы она вызывалась только один раз - при первом вызове. Все последующие вызовы ничего не делают.\n\nРешение:\nfunction runOnce(fn) {\n    let called = false;\n\n    return function (...args) {\n        if (called) {\n            return undefined;\n            called = true;\n            return fn(...args);\n        }\n    }\n}\n\n\n2.Написать функцию sleep которая ...",
        "full_content": "2025-06-24 13:48:29\n Sodnom Tyksheev -> 2071074234:\nЯндекс Фантех 1 этап лайвкодинг\nЗП:250K\nhr сам написал\n\n\n1. Сделай такую обёртку над функцией, чтобы она вызывалась только один раз - при первом вызове. Все последующие вызовы ничего не делают.\n\nРешение:\nfunction runOnce(fn) {\n    let called = false;\n\n    return function (...args) {\n        if (called) {\n            return undefined;\n            called = true;\n            return fn(...args);\n        }\n    }\n}\n\n\n2.Написать функцию sleep которая через переданное время резолвится\n\nРешение:\nfunction sleep(time) {\n    return new Promise((resolve) => \n    setTimeout(() => resolve(), time))\n}\n\n\n\n3. Реализовать функцию groupBy, которая группирует элементы массива по ключу, полученному из коллбэка сb.\n\nРешение:\nArray.prototype.groupByV2 = function (fn) {\n    const res = {}\n    const arr = this;\n    for (let i = 0; i < arr.length; i++) {\n        const key = fn(arr[i]);\n        if (res[key]) {\n            res[key] = [];\n        }\n        res[key].push(arr[i]);\n    }\n    return res\n}\n\n4.Напиши обёртку над асинхронной функцией fn, которая вызывает её, но прерывает выполнение, если она не успевает завершиться за t миллисекунд.\nВ этом случае Promise должен быть отклонён с сообщением \"Time limit exceeded\".\n\nРешение:\nconst timeLimited = function(fn, t) {\n  return function(...args) {\n    return new Promise((resolve, reject) => {\n      const fPromise = fn(...args).then(resolve).catch(reject);\n\n      const timer = setTimeout(() => {\n        reject(\"Time limit exceeded\");\n      }, t);\n\n      fPromise.finally(() => clearTimeout(timer));\n    });\n  }\n};\n\n\n\n5.Реализовать класса MaxStack, в котором все методы push, pop и max работают за O(1):\n\nРешение:\nclass MaxStack {\n  constructor() {\n    this.stack = [];      \n    this.maxStack = [];   \n  }\n\n  push(value) {\n    this.stack.push(value);\n   \n    const currentMax = this.maxStack.length === 0 ? value : Math.max(value, this.maxStack[this.maxStack.length - 1]);\n    this.maxStack.push(currentMax);\n  }\n\n  pop() {\n    if (this.stack.length === 0) return null;\n    this.maxStack.pop();   \n    return this.stack.pop(); \n  }\n\n  max() {\n    if (this.maxStack.length === 0) return null;\n    return this.maxStack[this.maxStack.length - 1]\n  }\n}"
      },
      {
        "timestamp": "2025-06-24 12:56:12",
        "content": "2025-06-24 12:56:12\n Артем Покатилов -> 2071074234:\n2/2 часть\nЯндекс Фантех 2 этап\nЗП: от 250к\n hr сам написал\n\nБыли вопросы после решений называть сложность алгоритма и сложность по памяти\n\n2.1 С усложнением в виде size у файлов (не у папок)\n/*\nДана вложенная структура файлов и папок в виде объекта:\n*/\n\nconst data = {\n  name: \"folder\",\n  children: [\n    { name: \"file1.txt\", size: 100 },\n    { name: \"file2.txt\", size: 400 },\n    {\n      name: \"images\",\n      children: [\n        { name: \"image.pn...",
        "full_content": "2025-06-24 12:56:12\n Артем Покатилов -> 2071074234:\n2/2 часть\nЯндекс Фантех 2 этап\nЗП: от 250к\n hr сам написал\n\nБыли вопросы после решений называть сложность алгоритма и сложность по памяти\n\n2.1 С усложнением в виде size у файлов (не у папок)\n/*\nДана вложенная структура файлов и папок в виде объекта:\n*/\n\nconst data = {\n  name: \"folder\",\n  children: [\n    { name: \"file1.txt\", size: 100 },\n    { name: \"file2.txt\", size: 400 },\n    {\n      name: \"images\",\n      children: [\n        { name: \"image.png\", size: 200 },\n        {\n          name: \"vacation\",\n          children: [\n            { name: \"crocodile.png\", size: 500 },\n            { name: \"penguin.png\", size: 200 },\n          ],\n        },\n      ],\n    },\n    { name: \"shopping-list.pdf\", size: 400 },\n  ],\n};\n\n/*\n    Задача:\n    Нужно вывести в консоль файлы и папки с отступами, чтобы показать вложенность.\n    Решение должно учитывать любую вложенность элементов (т.е. не должно содержать рекурсивные вызовы).\n    \n    Ожидаемый вывод:\n    folder (1800)\n      file1.txt (100)\n      file2.txt (400)\n      images (900)\n        image.png (200)\n        vacation (700)\n          crocodile.png (500)\n          penguin.png (200)\n      shopping-list.pdf (400)\n    */\n\n//Решение должно быть реализовано без использования рекурсии\n\nответ:\nfunction printDirectoryStructure(data) {\n  const sizeMap = new Map();\n\n  // === Первый проход: считаем размеры всех узлов (файлов и папок) ===\n  const stack = [{ node: data, visited: false }];\n\n  while (stack.length > 0) {\n    const { node, visited } = stack.pop();\n\n    if (!node.children) {\n      // Файл — просто сохраняем размер\n      sizeMap.set(node, node.size || 0);\n    } else if (!visited) {\n      // Сначала кладём папку обратно с visited: true, чтобы посчитать размер после обработки детей\n      stack.push({ node, visited: true });\n\n      // Добавляем детей в стек для обработки\n      for (let i = node.children.length - 1; i >= 0; i--) {\n        stack.push({ node: node.children[i], visited: false });\n      }\n    } else {\n      // Все дети обработаны — считаем сумму их размеров\n      let totalSize = 0;\n      for (const child of node.children) {\n        totalSize += sizeMap.get(child) || 0;\n      }\n      sizeMap.set(node, totalSize);\n    }\n  }\n\n  // === Второй проход: печатаем структуру сверху вниз ===\n  const printStack = [{ node: data, tab: \"\" }];\n\n  while (printStack.length > 0) {\n    const { node, tab } = printStack.pop();\n    const size = sizeMap.get(node) || node.size || 0;\n\n    console.log(`${tab}${node.name} (${size}kb)`); // Выводим имя и размер с отступом\n\n    // Добавляем детей в стек в обратном порядке для корректного порядка вывода\n    if (node.children) {\n      for (let i = node.children.length - 1; i >= 0; i--) {\n        printStack.push({ node: node.children[i], tab: tab + \"  \" });\n      }\n    }\n  }\n}"
      },
      {
        "timestamp": "2025-06-24 12:56:05",
        "content": "2025-06-24 12:56:05\n Артем Покатилов -> 2071074234:\n1/2 части\nЯндекс Фантех 2 этап\nЗП: от 250к\n hr сам написал\n\nБыли вопросы после решений называть сложность алгоритма и сложность по памяти\n\n1 задача:\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение....",
        "full_content": "2025-06-24 12:56:05\n Артем Покатилов -> 2071074234:\n1/2 части\nЯндекс Фантех 2 этап\nЗП: от 250к\n hr сам написал\n\nБыли вопросы после решений называть сложность алгоритма и сложность по памяти\n\n1 задача:\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение.\n\nТаймлайн:\n(приходит) 7 1 2 3 6 5 4    8\n(рисунок)   . 1 2 3 . . 4 5 6 7 8\n\nСообщения от сервера приходят в обработчик функции connect:\n\nconnect((msg) => {\n    ...\n});\n\nОтображать сообщения нужно с помощью функции `render`:\nrender(msg)\n*/\n\nconst solution = (connect, render) => {};\n\nответ:\nfunction solution(connect, render) {\n  // Создаем Map для хранения полученных сообщений\n  // Ключ - ID сообщения, значение - функция для его отрисовки\n  const map = new Map();\n\n  // Текущий ожидаемый ID сообщения (начинаем с 1)\n  let currId = 1;\n\n  // Подключаемся к источнику сообщений\n  connect((msg) => {\n    // Сохраняем сообщение в Map, оборачивая render в функцию\n    // Это позволяет отложить выполнение render до нужного момента\n    map.set(msg.id, () => render(msg));\n\n    // Проверяем, есть ли в Map сообщения, которые можно отрисовать по порядку\n    while (map.has(currId)) {\n      // Получаем и вызываем функцию отрисовки для текущего ID\n      map.get(currId)();\n\n      // Удаляем обработанное сообщение из Map\n      map.delete(currId);\n\n      // Переходим к следующему ожидаемому ID\n      currId++;\n    }\n  });\n}\n\n2. задача\n/*\nДана вложенная структура файлов и папок в виде объекта:\n*/\n\nconst data = {\n  name: \"folder\",\n  children: [\n    { name: \"file1.txt\" },\n    { name: \"file2.txt\" },\n    {\n      name: \"images\",\n      children: [\n        { name: \"image.png\" },\n        {\n          name: \"vacation\",\n          children: [{ name: \"crocodile.png\" }, { name: \"penguin.png\" }],\n        },\n      ],\n    },\n    { name: \"shopping-list.pdf\" },\n  ],\n};\n\n/*\n    Задача:\n    Нужно вывести в консоль файлы и папки с отступами, чтобы показать вложенность.\n    Решение должно учитывать любую вложенность элементов (т.е. не должно содержать рекурсивные вызовы).\n    \n    Ожидаемый вывод:\n    folder\n      file1.txt\n      file2.txt\n      images\n        image.png\n        vacation\n          crocodile.png\n          penguin.png\n      shopping-list.pdf\n    */\n\n//Решение должно быть реализовано без использования рекурсии\nconst printDirectoryStructure = (data) => {};\n\nответ:\nfunction printDirectoryStructure(data) {\n  // Используем стек для итеративного обхода структуры\n  const stack = [{ data, level: 0 }];\n\n  while (stack.length > 0) {\n    // Извлекаем текущий элемент из стека\n    const { data, level } = stack.pop();\n\n    // Выводим имя с соответствующим отступом\n    console.log(\" \".repeat(level * 2) + data.name);\n\n    // Если есть дети, добавляем их в стек в обратном порядке\n    if (data.children && Array.isArray(data.children)) {\n      for (let i = data.children.length - 1; i >= 0; i--) {\n        stack.push({\n          data: data.children[i],\n          level: level + 1,\n        });\n      }\n    }\n  }\n}\n\nprintDirectoryStructure(data);"
      },
      {
        "timestamp": "2025-06-23 01:19:00",
        "content": "2025-06-23 01:19:00\n Эмир -> 2071074234:\nЯндекс \nЭтап 1\nЗадачи:\n1. Сделай такую обёртку над функцией, чтобы она вызывалась только один раз — при первом вызове. Все последующие вызовы ничего не делают.\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n2. Напиши функцию, которая принимает несколько промисов и ...",
        "full_content": "2025-06-23 01:19:00\n Эмир -> 2071074234:\nЯндекс \nЭтап 1\nЗадачи:\n1. Сделай такую обёртку над функцией, чтобы она вызывалась только один раз — при первом вызове. Все последующие вызовы ничего не делают.\nfunction runOnce(fn) {\n  let isCalled = false;\n  return (...args) => {\n    if (isCalled) {\n      return undefined; // уже вызывалась — ничего не делаем\n    }\n    isCalled = true;\n    return fn(...args); // вызываем fn только один раз\n  };\n}\n2. Напиши функцию, которая принимает несколько промисов и возвращает промис, в котором будет сумма всех результатов этих промисов\nfunction sumFulfilledPromises(...promises) {\n  return Promise.allSettled(promises)\n    .then(results => {\n      const successValues = results\n        .filter(result => result.status === 'fulfilled')\n        .map(result => result.value);\n\n      return successValues.reduce((sum, num) => sum + num, 0);\n    });\n}\n3. Реализовать функцию groupBy, которая группирует элементы массива по ключу, полученному из коллбэка cb.\nArray.prototype.groupBy = function (cb) {\n  const result = {};\n\n  for (const item of this) {\n    const key = cb(item);\n    if (!result[key]) {\n      result[key] = [];\n    }\n    result[key].push(item);\n  }\n\n  return result;\n};\n4. Сделать auth с повторными попытками: если промис auth() отклоняется, пробовать заново n раз. Если все попытки неудачны — выбросить ошибку.\nasync function tryAuth(n) {\n  try {\n    const response = await auth(); // вызываем auth\n    return response;              // если успех — возвращаем результат\n  } catch (err) {\n    n -= 1;\n    if (n < 0) return Promise.reject(err); // если попытки закончились — ошибка\n    return tryAuth(n); // пробуем снова\n  }\n}\n5. Пройти по дереву (объекту с ветками tree.branches) и собрать белок с каждой ветки с помощью функции squirrelScanner, возвращающей массив белок.\nfunction scanTree(tree) {\n  let squirrels = [];\n\n  if (tree.branches) {\n    tree.branches.forEach(branch => {\n      squirrels.push(...squirrelScanner(branch));\n    });\n  }\n\n  return squirrels;\n}"
      },
      {
        "timestamp": "2025-06-11 14:12:34",
        "content": "2025-06-11 14:12:34\n Egor -> 2071074234:\nЯндекс 2 этап \nВакансия - написала hr\nЗп - ?\nЗадачи:\nfunction solution(connect, render) {\n    let curValue = 1;\n    const map = new Map();\n\n    connect(function onMessage(message) {\n        map.set(message.id, message);\n        console.log(map);\n        while (map.has(curValue)) {\n            render(map.get(curValue));\n            map.delete(curValue);\n            curValue++;\n        }\n    });\n}\nНа 2 задачу оставалось 20 минут, интервьюер решил не продолж...",
        "full_content": "2025-06-11 14:12:34\n Egor -> 2071074234:\nЯндекс 2 этап \nВакансия - написала hr\nЗп - ?\nЗадачи:\nfunction solution(connect, render) {\n    let curValue = 1;\n    const map = new Map();\n\n    connect(function onMessage(message) {\n        map.set(message.id, message);\n        console.log(map);\n        while (map.has(curValue)) {\n            render(map.get(curValue));\n            map.delete(curValue);\n            curValue++;\n        }\n    });\n}\nНа 2 задачу оставалось 20 минут, интервьюер решил не продолжать"
      },
      {
        "timestamp": "2025-06-05 19:58:18",
        "content": "2025-06-05 19:58:18\n Лёша -> 2071074234:\nЯндекс 3 этап\n\nВопросы:\nРасскажи про опыт. В Каких командах, на какой роли, что ты делал, как ты поменял процессы, что понравилось, что не понравилось... (это один вопрос если что🤡)\nПодробнее про команду. \nТы был руководителем или смертным?\nПодробнее про процессы.\nРасскажи про процессы на примере одной задачи.\nРасскажи про уровень задач, которыми ты занимался с примерами.\nСамая интересная задача (+ очень много вопросов по ней (почему выбрал такой подход, ...",
        "full_content": "2025-06-05 19:58:18\n Лёша -> 2071074234:\nЯндекс 3 этап\n\nВопросы:\nРасскажи про опыт. В Каких командах, на какой роли, что ты делал, как ты поменял процессы, что понравилось, что не понравилось... (это один вопрос если что🤡)\nПодробнее про команду. \nТы был руководителем или смертным?\nПодробнее про процессы.\nРасскажи про процессы на примере одной задачи.\nРасскажи про уровень задач, которыми ты занимался с примерами.\nСамая интересная задача (+ очень много вопросов по ней (почему выбрал такой подход, какие еще были варианты)).\nКак зарелизить обновленный бекенд?\nКак новый код появляется на сервере?\nКакие проверки запускаются?\nКак билд устроен?\nКак выглядит релиз фронта?\nЧто такое внешний контур?\nКакие тесты прогонялись?\nНа какой машинке выполняется билд.\nДавай поговорим про кубернетис.\nЧто такое фронт (артефакты, статика)?\n\nТут он решил вернуться на 20 мин назад, когда я рассказывал про проекты на которых работал и начал спрашивать по нему.\nЧто такое деплой юнит?\n\nДалее задача на тесты(на скриншоте)\nКак бы ты организовал тестирование данного сервиса?\nКакие виды тестов?\nКак бы ты их внедрял?\n\nЧто такое ssr (он опять вернулся к примеру в самом начале)\nКакие стадии билда фронта?\nDocker-файл.\nЧто такое npm-пакет\n\nПример проекта, который можно считать успешно реализованным благодаря твоим действиям.\nПримеры позитивного и негативного общения в команде.\n\n\nОщущения: самый душный тип за все собесы, докапывался до каждой мелочи, скакал с темы на тему (делал все без смазки).\nФитбек: 1,5 недели морозили. Оценили на мидл/мидл-, но вакансий нет, предложили стажировку, чтобы показать свои силы😎."
      },
      {
        "timestamp": "2025-06-05 14:28:48",
        "content": "2025-06-05 14:28:48\n Alexander -> 2071074234:\n05.06 Честный знак\nзп: просил минимум 250к\nвакансия: https://hh.ru/vacancy/120820023 \nссылка: https://disk.yandex.ru/i/wE0ybLXOiLYCNQ (не записался звук собеседующего, но все что спрашивал рассписал, плюс по моим ответам примерно понятно, я старался повторять вопросы)\n\nгонял по опыту, спрашивал чем занимался, работал ли с бэком, что интересно в проекте, что неинтересно, спросил про первый опыт работы. Уточнял чем занималась команда, а не только я, ка...",
        "full_content": "2025-06-05 14:28:48\n Alexander -> 2071074234:\n05.06 Честный знак\nзп: просил минимум 250к\nвакансия: https://hh.ru/vacancy/120820023 \nссылка: https://disk.yandex.ru/i/wE0ybLXOiLYCNQ (не записался звук собеседующего, но все что спрашивал рассписал, плюс по моим ответам примерно понятно, я старался повторять вопросы)\n\nгонял по опыту, спрашивал чем занимался, работал ли с бэком, что интересно в проекте, что неинтересно, спросил про первый опыт работы. Уточнял чем занималась команда, а не только я, как работаете(скрам). Была одна задача в чате про таблицу новостей. Спросил как бы отобразил, где бы выполнял запрос (логику вынести в отдельный кастомный хук), как бы реализовал скрытие прочитанных новостей (websocket), что делать если 1к новостей(виртуализация, бесконечный скролл, пагинация), как сохранять поиск, чтобы при перезагрузке вкладке он сохранялся, или чтобы другой пользователь мог перейти по ссылке и у него сохранился результат поиска(query параметры), спросил как уведомлять пользователя о новой новости(вебсокет+тостр), спрашивал про методы массива, про реакт(хуки какие знаешь, для чего используешь)\n\nОриентировался на это\nfunction NewsPage() {\n  const [news, setNews] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetch('/news')\n      .then(response => response.json())\n      .then(data => {\n        setNews(data);\n        setLoading(false);\n      })\n      .catch(error => {\n        console.error('Error fetching news:', error);\n        setLoading(false);\n      });\n  }, []);\n\n  if (loading) return <div>Loading...</div>;\n  if (!news.length) return <div>No news available</div>;\n\n  return (\n    <div className=\"news-container\">\n      <table className=\"news-table\">\n        <thead>\n          <tr>\n            <th>Заголовок</th>\n            <th>Описание</th>\n          </tr>\n        </thead>\n        <tbody>\n          {news.map(item => (\n            <tr key={item.id}>\n              <td>{item.title}</td>\n              <td>{item.description}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}"
      },
      {
        "timestamp": "2025-06-03 20:47:33",
        "content": "2025-06-03 20:47:33\n Nikita -> 2071074234:\nКомпания - Яндекс (1 этап)\nВакансия - написал HR\n\nЗАДАНИЕ 1\n\nРеализовать метод times для числового объекта.\nФункция должна принимать callback и вызывать его заданное количество раз с индексом текущей итерации.\n\nРЕШЕНИЕ\n\nNumber.prototype.times = function(callback) {\n  const num = Math.floor(this);\n  for (let i = 0; i < num; i++) {\n    callback(i);\n  }\n};\n\nЗАДАНИЕ 1.1 \n\nПопросил дописать решение, добавив проверку на целые числа.\n\nРЕШЕНИЕ\n\nNumber.prototype...",
        "full_content": "2025-06-03 20:47:33\n Nikita -> 2071074234:\nКомпания - Яндекс (1 этап)\nВакансия - написал HR\n\nЗАДАНИЕ 1\n\nРеализовать метод times для числового объекта.\nФункция должна принимать callback и вызывать его заданное количество раз с индексом текущей итерации.\n\nРЕШЕНИЕ\n\nNumber.prototype.times = function(callback) {\n  const num = Math.floor(this);\n  for (let i = 0; i < num; i++) {\n    callback(i);\n  }\n};\n\nЗАДАНИЕ 1.1 \n\nПопросил дописать решение, добавив проверку на целые числа.\n\nРЕШЕНИЕ\n\nNumber.prototype.times = function(callback) {\n  if (!Number.isInteger(this)) return;\n  const num = Math.floor(this);\n  for (let i = 0; i < num; i++) {\n    callback(i);\n  }\n};\n\nЗАДАНИЕ 2\n\nРеализовать функцию sumPromises, которая принимает в качестве аргументов промисы и возвращает сумму результатов их выполнения.\nФункция может принимать любое количество аргументов.\nМожно использовать любые API промисов.\n\nconst promise1 = Promise.resolve(1);\nconst promise2 = Promise.resolve(2);\nsumPromises(promise1, promise2).then(console.log) //3\n\nРЕШЕНИЕ\n\nfunction sumPromises(...promises) {\n  return Promise.all(promises)\n    .then(results => {\n      return results.reduce((sum, num) => sum + num, 0);\n    });\n}\n\nЗАДАНИЕ 3\n\n Реализовать функцию compose, которая принимает\n переменное количество функций и возвращает новую функцию.\n Результат работы каждой функции передается в следующую.\n\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.clear();\nconsole.log(compose(square, times2)(2) === square(times2(2)));\nconsole.log(compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));\n\nРЕШЕНИЕ\n\nfunction compose(...funcs) {\n  return function (...args) {\n    return funcs.reduceRight((acc, fn) => {\n      return [fn(...acc)];\n    }, args)[0];\n  };\n}\n\nЗАДАНИЕ 4\n\nНеобходимо проверить решение задачи по двум сервисам,\nвызвав checkResult(url1, solution), checkResult(url2, solution);\ncheckResult: (url: string, solution: string | number) => Promise<boolean>;\nЕсли оба запроса вернули true - вывести success.\nЕсли хоть один вернул false - вывести fail.\nЕсли хоть зареджектился - вывести error.\nЕсли хоть один отвечает дольше 1 сек - вывести timeout.\n\nimport { checkResult } from \"myLib\"\n\nconst solution = \"Any answer\"\nconst url1 = \"yandex.ru\"\nconst url2 = \"google.com\"\n\ncheckResult(url, solution);\ncheckResult(url, solution);\n\nРЕШЕНИЕ\n\nasync function runCheck(url1, url2, solution) {\n    const timeout = (ms) => new Promise((_, reject) =>\n        setTimeout(() => reject(new Error(\"timeout\")), ms);\n    \n    async function safeCheck(url) {\n        try {\n            return await Promise.race([\n                checkResult(url, solution),\n                timeout(3000)\n            ]);\n        } catch (e) {\n            throw e.message === \"timeout\" ? \"timeout\" : \"error\";\n        }\n    }\n\n    try {\n        const [r1, r2] = await Promise.all([safeCheck(url1), safeCheck(url2)]);\n        \n        if (r1 === true && r2 === true) return \"success\";\n        if (r1 === false || r2 === false) return \"fail\";\n    } catch (e) {\n        return e; // \"timeout\" или \"error\"\n    }\n}\n\nЗАДАНИЕ 5\n\nНеобходимо написать функцию для подсчёта суммы всех числовых значений в массиве.\nВалидным числовым значением являются так же строки, которые начинаются с цифр. В этом случае в качестве числового значения нужно использовать эту начальную последовательность цифр. Массив может содержать любые типы данных, быть не плоским.\n\nНельзя использовать встроенные методы типа .flat, .flatMap.\n\nfunction sum(arr) {\n    // ...\n}\nconsole.log(sum([1, 'x', '2x', ['3', ['x2', '5']]])); //11\n\nРЕШЕНИЕ"
      },
      {
        "timestamp": "2025-06-03 18:30:31",
        "content": "2025-06-03 18:30:31\n Max -> 2071074234:\nБКС \nhr написала\nВопросы: \n- про опыт\n- key\n- как оптимизировать/улучшить, что написал\nЗадача:\nреализовать небольшое приложение\n\nimport React from 'react';\nimport { useState, useCallback } from 'react'\nimport {memo} from 'react'\n\n// 1. Вывести список акций\n// 2. Добавить фильтр по отрасли (select)\n// 3. Добавить фильтр по диапазону цены (2x input)\n// 4. есть компонент Input, как избежать лишних рендеров? (обернуть в memo + useCallback)\n\nconst items = [\n   ...",
        "full_content": "2025-06-03 18:30:31\n Max -> 2071074234:\nБКС \nhr написала\nВопросы: \n- про опыт\n- key\n- как оптимизировать/улучшить, что написал\nЗадача:\nреализовать небольшое приложение\n\nimport React from 'react';\nimport { useState, useCallback } from 'react'\nimport {memo} from 'react'\n\n// 1. Вывести список акций\n// 2. Добавить фильтр по отрасли (select)\n// 3. Добавить фильтр по диапазону цены (2x input)\n// 4. есть компонент Input, как избежать лишних рендеров? (обернуть в memo + useCallback)\n\nconst items = [\n    { ticker: 'GAZP', label: 'Газпром', industry: 'oil&gas', price: 133.44 },\n    { ticker: 'YNDX', label: 'Яндекс', industry: 'IT', price: 3907.44 },\n    { ticker: 'SBER', label: 'Сбербанк', industry: 'bank', price: 289.3 },\n    { ticker: 'LKOH', label: 'Лукойл', industry: 'oil&gas', price: 6806 },\n    { ticker: 'VTBR', label: 'ВТБ', industry: 'bank', price: 97.51 },\n    { ticker: 'TCSG', label: 'ТКС холдинг', industry: 'bank', price: 2604.5 },\n    { ticker: 'ROSN', label: 'Роснефть', industry: 'oil&gas', price: 511.95 },\n];\n\nconst Input = memo((props) => {\n    console.log('render')\n\n    return <input {...props} />\n})\n\n\nconst industries = ['all', 'oil&gas', 'bank', 'IT'];\n\nexport default function App() {\n    const [selected, setSelected] = useState('all')\n    const [minPrice, setMinPrice] = useState(0)\n    const [maxPrice, setMaxPrice] = useState(10000)\n\n    const handleChange = useCallback((e) => {\n        setMinPrice(e.target.value)\n    },[])\n\n    const filterItems = items.filter(item => {\n        const matchInd = selected === 'all' || item.industry === selected\n        const matchMin = minPrice === 0 || item.price >= minPrice\n        const matchMax = minPrice === 10000 || item.price <= maxPrice\n        return matchInd && matchMin && matchMax\n\n    })\n\n\n    return (\n        <>\n            <select onChange = {e => setSelected(e.target.value)} value = {selected} >\n                {industries.map(ind => (\n                    <option key = {ind} value={ind}>\n                    {ind}\n                        </option>\n                ))}\n            </select>\n\n\n            <Input value={minPrice} onChange={handleChange} />\n            <input value={maxPrice} onChange={e => setMaxPrice(e.target.value)} ></input>\n\n            <table>\n                <tbody>\n                    {filterItems.map((item) => (\n                        <tr key={item.ticker}>\n                            <td>{item.ticker}</td>\n                            <td>{item.label}</td>\n                            \n                            <td>{item.price}</td>\n                </tr>\n           ))}\n                        </tbody>\n                    </table>\n        </>\n    );\n}"
      },
      {
        "timestamp": "2025-06-03 11:08:23",
        "content": "2025-06-03 11:08:23\n Лёша -> 2071074234:\nЯндекс Доски - 4 этап общение с командой (тимлид)\n\nСначала говорили о моем опыте на протяжении 15 мин (тут были уточняющие вопросы:\nПочему выбрали именно эту технологи?\nНабор команды и как взаимодействовал в критических ситуациях?\n).\nОстальные 40 мин я расспрашивал тимлида о проекте.\n\n🤷‍♂️🤷‍♂️🤷‍♂️",
        "full_content": "2025-06-03 11:08:23\n Лёша -> 2071074234:\nЯндекс Доски - 4 этап общение с командой (тимлид)\n\nСначала говорили о моем опыте на протяжении 15 мин (тут были уточняющие вопросы:\nПочему выбрали именно эту технологи?\nНабор команды и как взаимодействовал в критических ситуациях?\n).\nОстальные 40 мин я расспрашивал тимлида о проекте.\n\n🤷‍♂️🤷‍♂️🤷‍♂️"
      },
      {
        "timestamp": "2025-06-02 14:32:40",
        "content": "2025-06-02 14:32:40\n Alexandro 4 -> 2071074234:\nЯндекс.Маркет 3 этап\nHR сам написал\nЗП: 250к\n\nВопросы:\n1. Про организацию работы в команде (состав команды, SCRUM)\n2. Кто составлял описание задач?\n3. Чем занимался на проекте? За что отвечал?\n4. Расскажи про несколько решенных сложных задач.\n5. Как шел деплой на проекте? (Git Flow, выгрузка в продакшен)\n6. Как тестировали приложение? (Unit тестирование, покрытие, e2e)\n7. Приходилось ли оптимизировать приложение?\n8. Работал ли с Next?\n9. Расскажи п...",
        "full_content": "2025-06-02 14:32:40\n Alexandro 4 -> 2071074234:\nЯндекс.Маркет 3 этап\nHR сам написал\nЗП: 250к\n\nВопросы:\n1. Про организацию работы в команде (состав команды, SCRUM)\n2. Кто составлял описание задач?\n3. Чем занимался на проекте? За что отвечал?\n4. Расскажи про несколько решенных сложных задач.\n5. Как шел деплой на проекте? (Git Flow, выгрузка в продакшен)\n6. Как тестировали приложение? (Unit тестирование, покрытие, e2e)\n7. Приходилось ли оптимизировать приложение?\n8. Работал ли с Next?\n9. Расскажи про плюсы и минусы SSR?\n10. Какие бы ты тесты предложил для интерфейса Яндекс.Путешествия? (Нужно рассказать про пирамиду тестирования (Unit тесты, интеграционные тесты, e2e) и привести по 2-3 примера на каждый вид)\n11. Пользователи жалуются, что при открытии приложения белый экран, что будешь делать?\n12. Были ли конфликты в команде и как действовал в таких ситуациях?\n13. Проводил ли менторство над сотрудником и с какими проблемами столкнулся?\n14. Какие улучшения внес в работу команды?"
      },
      {
        "timestamp": "2025-05-30 20:43:37",
        "content": "2025-05-30 20:43:37\n Никита -> 2071074234:\nЯндекс 1 этап\n\nЗАДАЧА 1\nfunction runOnce(fn) {\n    }\n\nconst logHello = () => {\n    console.log('hello!')\n};\n\nconst logHelloOnce = runOnce(logHello);\nconsole.clear();\nlogHelloOnce(); // 'hello!\nlogHelloOnce(); // undefined\n\nРЕШЕНИЕ\nfunction runOnce(fn) {\n    let isCalled = false;\n    let result;\n    return function(...args) {\n        if (!isCalled) {\n            isCalled = true;\n            result = fn(...args);\n            return result;\n        } else ...",
        "full_content": "2025-05-30 20:43:37\n Никита -> 2071074234:\nЯндекс 1 этап\n\nЗАДАЧА 1\nfunction runOnce(fn) {\n    }\n\nconst logHello = () => {\n    console.log('hello!')\n};\n\nconst logHelloOnce = runOnce(logHello);\nconsole.clear();\nlogHelloOnce(); // 'hello!\nlogHelloOnce(); // undefined\n\nРЕШЕНИЕ\nfunction runOnce(fn) {\n    let isCalled = false;\n    let result;\n    return function(...args) {\n        if (!isCalled) {\n            isCalled = true;\n            result = fn(...args);\n            return result;\n        } else {\n            return undefined;\n        }\n    };\n}\n\nconst logHello = () => {\n    console.log('hello!');\n};\n\nconst logHelloOnce = runOnce(logHello);\nconsole.clear();\nlogHelloOnce(); // 'hello!'\nlogHelloOnce(); // undefined\n\nЗАДАЧА 2\n\n/* */\n\n* Необходимо написать асинхронную функцию,  \n* которая будет \"спать\" заданное количество миллисекунд,  \n* а потом успешно завершаться  \n\n*/\n\nfunction sleep(duration) {\n\n}\n\n// Пример  \nconst startTime = Date.now();\n\nconsole.log(\"Start sleeping...\");\n\nsleep(2000).then(() => {\n    console.log(\"Make up after 2 seconds!\");\n    console.log(\"Time passed: \", Date.now() - startTime);\n});\n\nsleep(1000).then(() => {\n    console.log(\"Make up after 1 seconds!\");\n    console.log(\"Time passed: \", Date.now() - startTime);\n});\n\nРЕШЕНИЕ\n\nСпрашивает почему в консоль выводит\nTime passed: 2014\nОткуда взялось 14мс?\n\nfunction sleep(duration) {\n    return new Promise(resolve =>{\n    setTimeout(()=>{\n    resolve()\n    }, duration)\n    }\n}\n\nЗАДАЧА 3\n\n// code here\n\nconst array1 = [\n  { id: 1 },\n  { id: 1 },\n  { id: 2 }\n];\n\nconst fn = (item) => item.id;\n\nconsole.log(array1.groupBy(fn));\n// {\n    //  1: [{ id: 1 }, { id : 1 }],\n    //  2: [{ id: 2 }]\n    // }\n\n    // Пример 2\n    const array2 = [1, 2, 3];\n    console.log(array2.groupBy(String));\n    // {\n    // \"1\": [1],\n    // \"2\": [2],\n    // \"3\": [3]    I\n    // }\n\n    // Пример 3\n    const array3 = [3.3, 0.5, 1.4];\n    console.log(array3.groupBy(Math.round));\n    // {\n    //  3: [3.3],\n    //  1: [0.5, 1.4]\n    // }\n\nРЕШЕНИЕ \n\nArray.prototype.groupBy = function (cb) {\n    return this.reduce((acc, curr) => {\n        const key = cb(curr)\n        if (!acc[key]) {\n            acc[key] = []\n        }\n        acc[key].push(curr)\n        return acc\n    }, {})\n}\n\nЗАДАЧА 4_1\n\nimport asyncAuth from '...;\n\nfunction auth() { \n    // asyncAuth((error, data) => {});\n}\n\nРЕШЕНИЕ \n\nfunction auth() {\n    // asyncAuth((error, data) => {});\n    return new Promise((res, rej) => {\n        asyncAuth((error, data) =>) {\n            if (error) return rej(error)\n            return res(data);\n        }\n    }\n}\n\nЗАДАЧА 4_2 \nРЕШЕНИЕ\n\nasync function tryAuth(n) {\n    try {\n        const response = await auth();\n        return response;\n    } catch(err) {\n        n -= 1;\n        if (n === -1) return Promise.reglect(err);\n        return tryAuth(n);\n    }\n}\n\ntryAuth(5);\n\nЗАДАЧА 5\n\nfunction oddSort(numbers) {\n}\n\nconsole.log(oddSort([[2, 3, 7, 4, 6, 1, 5, 8, 9]])); // [2, 1, 3, 4, 6, 5, 7, 8, 9]\nconsole.log(oddSort([2, 4, 6, 8])); // [2, 4, 6, 8]\nconsole.log(oddSort([3, 7, 1, 5, 9])); // [1, 3, 5, 7, 9]\n\nРЕШЕНИЕ\nКакая сложность у алгоритма?\nO(n log n)\n\nfunction oddSort(numbers) {\n    const oddNumbers = numbers.filter(num => num % 2 !== 0).sort((a, b) => a - b);\n    let oddIndex = 0;\n\n    return numbers.map(num => {\n        if (num % 2 !== 0) {\n            return oddNumbers[oddIndex++];\n        }\n        return num;\n    });\n}\n\nconsole.log(oddSort([2, 3, 7, 4, 6, 1, 5, 8, 9])); // [2, 1, 3, 4, 6, 5, 7, 8, 9]\nconsole.log(oddSort([2, 4, 6, 8]));                // [2, 4, 6, 8]\nconsole.log(oddSort([3, 7, 1, 5, 9]));             // [1, 3, 5, 7, 9]"
      },
      {
        "timestamp": "2025-05-27 08:13:09",
        "content": "2025-05-27 08:13:09\n Артур Виноградов -> 2071074234:\nЯндекс. 1 этап\nЗП: 300к\n\nЗадача 1.\n// — 1 — \nconsole.log( typeof [] ) // ??\n\n// — 2 — \nconsole.log( typeof null ) // ??\n\n// — 3 — \nconsole.log( 1 + \"2\" ) // ??\n\n// — 4 — \nconsole.log( \"4\" - 2 ) // ??\n\n// — 5 — \nconst first = () => console.log('Один')\nconst second = () => console.log('Два')\nconst third = () => console.log('Три')\n\nfirst()\nsetTimeout(second, 0)\nthird()\n\n// ??\n\n// — 6 — \nvar a = 2\nvar b = a\nb++\n\nconsole.log(a) // ??\nconsole.log(b)...",
        "full_content": "2025-05-27 08:13:09\n Артур Виноградов -> 2071074234:\nЯндекс. 1 этап\nЗП: 300к\n\nЗадача 1.\n// — 1 — \nconsole.log( typeof [] ) // ??\n\n// — 2 — \nconsole.log( typeof null ) // ??\n\n// — 3 — \nconsole.log( 1 + \"2\" ) // ??\n\n// — 4 — \nconsole.log( \"4\" - 2 ) // ??\n\n// — 5 — \nconst first = () => console.log('Один')\nconst second = () => console.log('Два')\nconst third = () => console.log('Три')\n\nfirst()\nsetTimeout(second, 0)\nthird()\n\n// ??\n\n// — 6 — \nvar a = 2\nvar b = a\nb++\n\nconsole.log(a) // ??\nconsole.log(b) // ??\n\n// — 7 — \nvar c = [1, 2, 3]\nvar d = c\nd.push(4)\nconsole.log(c) // ??\nconsole.log(d) // ??\n\n// — 8 — \n{\n    console.log(i) // ??\n    let i = 10\n    console.log(i) // ??\n}\n\nОтвет:\nobject\nobject\n12\n2\nОдин\nТри\n2\n3\n[ 1, 2, 3, 4 ]\n[ 1, 2, 3, 4 ]\nReferenceError: Cannot access 'i' before initialization\n\nЗадача 2.\nimport asyncAuth from '...';\n\n/**\n * Функция `asyncAuth(callback)` принимает callback, в который может\n * быть передана ошибка (первым аргументом) и данные\n * с бекенда (вторым аргументом).\n * asyncAuth((error, data) => {});\n *\n * Вам нужно реализовать функцию `auth()`,\n * которая вызывает `asyncAuth()`, но возвращает Promise.\n *\n * @returns {Promise}\n */\nfunction auth() {\n  \n}\n\n/**\n * Функция `tryAuth()` использует `auth()` и, в случае ошибки,\n * совершает N дополнительных попыток.\n * в случае, если все попытки провалились - вернуть последнюю ошибку\n *\n * @returns {Promise}\n */\nfunction tryAuth(n = 5) {\n \n}\n\nОтвет:\nimport asyncAuth from '...';\n\n/**\n * Функция `asyncAuth(callback)` принимает callback, в который может\n * быть передана ошибка (первым аргументом) и данные\n * с бекенда (вторым аргументом).\n * asyncAuth((error, data) => {});\n *\n * Вам нужно реализовать функцию `auth()`,\n * которая вызывает `asyncAuth()`, но возвращает Promise.\n *\n * @returns {Promise}\n */\nfunction auth() {\n  return new Promise((res, rej) => {\n    asyncAuth((error, data) => {\n      if (error) return rej(error);\n      res(data);\n    });\n  });\n}\n\n/**\n * Функция `tryAuth()` использует `auth()` и, в случае ошибки,\n * совершает N дополнительных попыток.\n * в случае, если все попытки провалились - вернуть последнюю ошибку\n *\n * @returns {Promise}\n */\nfunction tryAuth(n = 5) {\n  return new Promise((res, rej) => {\n    auth()\n      .then(res)\n      .catch((err) => {\n        if (n) return tryAuth(n - 1);\n        rej(err);\n      });\n  });\n}\n\nЗадача 3.\n/**\n * Написать декоратор для функции, который ограничивает число вызовов.\n *\n * callLimit(fn, limit, callback) принимает следующие аргументы:\n *  fn – функция, которую декорируем;\n *  limit – максимальное число вызовов;\n *  callback – вызывается, когда совершен последний вызов. Опционально.\n * У вызываемой функции должен быть метод для перезагрузки счетчика в начальное положение.\n */\n\nfunction callLimit(fn, limit, callback) {\n    // Тут что-то написать\n}\n\nfunction log(title, message) {\n    console.log(title + ': ' + message);\n}\n\nОтвет:\nfunction callLimit(fn, limit, callback) {\n  let count = 0; // Счётчик вызовов\n\n   // Обёртка над исходной функцией\n   function wrapper(...args) {\n        if (count >= limit) return; // Прекратить выполнение, если лимит превышен\n\n        count++; // Увеличить счётчик\n\n         // Если вызов достиг лимита — вызвать callback (если он передан)\n         if (count === limit && typeof callback === 'function') {\n             callback();\n         }\n\n         // Вызов оригинальной функции с переданными аргументами\n        return fn.apply(this, args);\n    }\n\n    // Метод для ручного сброса счётчика вызовов\n    wrapper.reset = function () {\n          count = 0;\n    };\n\n  return wrapper; // Вернуть обёрнутую функцию\n}"
      },
      {
        "timestamp": "2025-05-26 19:55:06",
        "content": "2025-05-26 19:55:06\n Лёша -> 2071074234:\nЯндекс 2 этап\n\nСлетело все во время собеса. Первые 2 задачи - типовые. 3 - описал, как мог.\n\nЗадача 1:\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршрут...",
        "full_content": "2025-05-26 19:55:06\n Лёша -> 2071074234:\nЯндекс 2 этап\n\nСлетело все во время собеса. Первые 2 задачи - типовые. 3 - описал, как мог.\n\nЗадача 1:\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту. Начало маршрута известно.\n*/\n\nfunction getRoute(tickets = [], start) {\n  const routesMap = {};\n\n  tickets.forEach((item) => {\n    const { from, to } = item;\n    routesMap[from] = to;\n  });\n\n  let currentCity = start;\n  const result = [];\n\n  while (currentCity && routesMap[currentCity]) {\n    result.push({ from: currentCity, to: routesMap[currentCity] });\n    currentCity = routesMap[currentCity];\n  }\n\n  return result;\n}\n\nЗадача 2:\nЕсть некая структура папок, их нужно отрисовать в консоли. Папки могут содержать детей и т.д. Чтобы не было рекурсии.\nfunction printDirectoryStructure(data) {\n    const stack = [{ item: data, level: 0 }];\n    \n    while (stack.length > 0) {\n        const { item, level } = stack.pop();\n        \n        // Print current item with proper indentation\n        console.log('  '.repeat(level) + item.name);\n        \n        // If the item has children, add them to stack in reverse order\n        // to maintain correct output order (since we're using stack)\n        if (item.children) {\n            for (let i = item.children.length - 1; i >= 0; i--) {\n                stack.push({\n                    item: item.children[i],\n                    level: level + 1\n                });\n            }\n        }\n    }\n}\n\nЗадача 3:\nНаписать свой тротл. Из-за ошибки записи - задача не сохранилась, но вот упрощенное решение. Сюда еще нужно контекст прикрутить. Эту задачу не успел сделать.\nfunction throttle(callee, timeout) {\n  let timer = null\n\n  return function perform(...args) {\n    if (timer) return\n\n    // Если таймера нет, значит мы можем вызвать функцию:\n    timer = setTimeout(() => {\n      callee(...args)\n\n      // По окончании сбрасываем таймер:\n      timer = null\n    }, timeout)\n  }\n}"
      },
      {
        "timestamp": "2025-05-26 07:44:12",
        "content": "2025-05-26 07:44:12\n Ильдус Гизетдинов -> 2071074234:\nЯндекс 1 этап:\nЧто выведет и как исправить\nconst object = {\n    value: \"42\",\n    print() {\n      function type() {\n        return typeof this.value;\n      }\n      console.log(`${this.value} is ${type()}`);\n    },\n};\n  \nobject.print(); // 42 is string\n\nСделать свою функцию compose\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.log(compose(square, times2)(2) === square(times2(2)));\nconsole.log(co...",
        "full_content": "2025-05-26 07:44:12\n Ильдус Гизетдинов -> 2071074234:\nЯндекс 1 этап:\nЧто выведет и как исправить\nconst object = {\n    value: \"42\",\n    print() {\n      function type() {\n        return typeof this.value;\n      }\n      console.log(`${this.value} is ${type()}`);\n    },\n};\n  \nobject.print(); // 42 is string\n\nСделать свою функцию compose\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.log(compose(square, times2)(2) === square(times2(2)));\nconsole.log(compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));\n\nОтвет:\nfunction compose(...funcs) {\n  return function (...args) {\n    return funcs.reduceRight((acc, fn) => {\n      return [fn(...acc)];\n    }, args)[0];\n  };\n}\nНаписать функцию которая будет принемать url и если не получаешь данные, попробовать еще 5 раз, потом выбросить ошибку\nfunction get(url, netries = 5) {\n    // code here\n    return fetch(url).then(res => {\n        return res.json()\n    }).then(data => data).catch((err) => {\n        if (netries > 0) {\n            return get(url, netries - 1)\n        } else {\n            return Promis.reject('Заданный URL недоступен')\n        }\n    })\n}\nДан бы объект со вложенностями, нужно вывести массив name где type squirrel\nfunction squirrelScanner(tree) {\n    const result = [];\n\n    // Вспомогательная рекурсивная функция для обхода дерева\n    function fn(node) {\n        // Если в узле белка — добавляем имя в результат\n        if (node.nest.type === 'squirrel') {\n            result.push(node.nest.name);\n        }\n\n        // Если есть ветки — проходимся по каждой из них\n        if (node.branches) {\n            node.branches.forEach(fn);\n        }\n    }\n\n    fn(tree); // запускаем обход с корня\n    return result;\n}"
      },
      {
        "timestamp": "2025-05-26 07:26:12",
        "content": "2025-05-26 07:26:12\n Max -> 2071074234:\nЯндекс 2 этап Алгосы\nЗадача 1:\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту. Начало маршрута известно.\n*/\n\nfunction getRoute(tickets = [], start) {...",
        "full_content": "2025-05-26 07:26:12\n Max -> 2071074234:\nЯндекс 2 этап Алгосы\nЗадача 1:\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту. Начало маршрута известно.\n*/\n\nfunction getRoute(tickets = [], start) {\n  const routesMap = {};\n\n  tickets.forEach((item) => {\n    const { from, to } = item;\n    routesMap[from] = to;\n  });\n\n  let currentCity = start;\n  const result = [];\n\n  while (currentCity && routesMap[currentCity]) {\n    result.push({ from: currentCity, to: routesMap[currentCity] });\n    currentCity = routesMap[currentCity];\n  }\n\n  return result;\n}\n2 задача:\n//Дан массив ссылок: ['url1', 'url2', ...] и лимит одновременных запросов (limit) Необходимо реализовать функцию, которыя опросит урлы в том //порядку, в котором они идут в массиве, и вызовет callback с массивом ответов ['url1_answer', 'url2_anser', ...] так, чтобы в любой момент //времени выполнялось не более limit запросов (как только любой из них завершился, сразу же отправится следующий) Т.е. нужно реализовать шину с шириной равной limit.\n// доп. добавить мемоизацию\nfunction parallelLimit(urls, limit, callback) {\n    // Если limit больше количества URL, устанавливаем его равным длине массива URL\n    limit = Math.min(limit, urls.length);\n    \n    let results = new Array(urls.length);\n    let active = 0;\n    let index = 0;\n    const cache = new Map(); // Добавляем кэш для мемоизации\n    \n    function processNext() {\n        if (index >= urls.length && active === 0) {\n            callback(results);\n            return;\n        }\n        \n        while (index < urls.length && active < limit) {\n            const currIndex = index;\n            const url = urls[currIndex];\n            index++;\n            active++;\n            \n            // Проверяем наличие URL в кэше\n            if (cache.has(url)) {\n                // Если URL уже в кэше, берём результат оттуда\n                results[currIndex] = cache.get(url);\n                active--;\n                // Используем setTimeout для асинхронности и предотвращения переполнения стека\n                setTimeout(processNext, 0);\n            } else {\n                // Если URL нет в кэше, выполняем запрос\n                fetch(url)\n                    .then(response => {\n                        // Сохраняем ответ в кэш\n                        cache.set(url, response);\n                        results[currIndex] = response;\n                        active--;\n                        processNext();\n                    });\n            }\n        }\n    }\n    \n    // Обработка пустого массива URL\n    if (urls.length === 0) {\n        callback(results);\n        return;\n    }\n    \n    processNext();\n}"
      },
      {
        "timestamp": "2025-05-23 10:59:44",
        "content": "2025-05-23 10:59:44\n Alexandro 4 -> 2071074234:\nЯндекс.Маркет 2 этап (алгосы)\nHR сам написал\n250К\n\n1) Приложение-чат\nУСЛОВИЯ\n/**\n * Наше приложение-чат должно отображать новые сообщения, которые приходят с сервера, как можно быстрее.\n *\n * Сообщение имеет формат:\n * interface Message {\n *   id: number\n *   text: string\n * }\n *\n * Id самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\n * Нам нужно выводить сообщения в правильном порядке, однако сервер ...",
        "full_content": "2025-05-23 10:59:44\n Alexandro 4 -> 2071074234:\nЯндекс.Маркет 2 этап (алгосы)\nHR сам написал\n250К\n\n1) Приложение-чат\nУСЛОВИЯ\n/**\n * Наше приложение-чат должно отображать новые сообщения, которые приходят с сервера, как можно быстрее.\n *\n * Сообщение имеет формат:\n * interface Message {\n *   id: number\n *   text: string\n * }\n *\n * Id самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\n * Нам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\n * сообщений, отправляемых в наше приложение.\n *\n * Таймлайн:\n * // (приходит) 7  1  2  3  6  5  4  8\n * // (рисуем)   .  1  2  3  .  4  5  6  7  8\n *\n * Сообщения от сервера приходят в обработчик функции connect:\n * connect(function onMessage(message) {\n *   ...\n * }); \n * \n * Отображать сообщения нужно с помощью функции render:\n * render(message)\n */\n\n// function solution(connect, render) {\n//     connect(function onMessage(message) {\n//         render(message);\n//     });\n// }\n\n\n//приходит 7 1 2 3 6 5 4 8\n//рисунок 1 2 3 4 5 6 7 8 9\n\nРЕШЕНИЕ\nfunction solution(connect, render) {\n    let id = 1;\n    const map = new Map();\n\n    connect(function onMessage(message) {\n        map.set(message.id, message);\n        console.log(map);\n        while (map.has(id)) {\n            render(map.get(id));\n            map.delete(id);\n            id++;\n        }\n    });\n}\n\n\n2) Вывод структуры со вложенностью без рекурсии\nУСЛОВИЯ\n/*\nДана вложенная структура файлов и папок в виде объекта:\n*/\n\nconst data = {\n    name: 'folder',\n    children: [\n        { name: 'file1.txt' },\n        { name: 'file2.txt' },\n        {\n            name: 'images',\n            children: [\n                { name: 'image.png' },\n                {\n                    name: 'vacation',\n                    children: [\n                        { name: 'crocodile.png' },\n                        { name: 'penguin.png' }\n                    ]\n                }\n            ]\n        },\n        { name: 'shopping-list.pdf' }\n    ]\n};\n/*\nЗадача:\nНужно вывести в консоль файлы и папки с отступами, чтобы показать вложенность.\nРешение должно учитывать любую вложенность элементов (т.е. не должно содержать рекурсивные вызовы).\n\nОжидаемый вывод:\nfolder\n  file1.txt\n  file2.txt\n  images\n    image.png\n    vacation\n      crocodile.png\n      penguin.png\n  shopping-list.pdf\n*/\nРЕШЕНИЕ\nfunction printDirectoryStructure (data) {\n    const stack  = [{data, level: 0}]\n\n    while (stack.length > 0) {\n        const {level, data} = stack.pop()\n        console.log(' '.repeat(level) + data.name)\n\n        const children = data?.children\n        if (children) {\n            for (let i= children.length -1; i >= 0; i--) {\n                stack.push({\n                    data: children[i],\n                    level: level + 1\n                })\n            }\n        }\n    }\n}"
      },
      {
        "timestamp": "2025-05-20 15:29:58",
        "content": "2025-05-20 15:29:58\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с командами. 2 команда. \nПришел один чел в итоге, по большей части ничего не спрашивал, задал только один вопрос на который стоит обратить внимание. Собеседование прошло скучно и уныло. Собственно сам вопрос:\n1. Отлавливание ошибок на стороне фронта. Нужно рассказать про sentry",
        "full_content": "2025-05-20 15:29:58\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с командами. 2 команда. \nПришел один чел в итоге, по большей части ничего не спрашивал, задал только один вопрос на который стоит обратить внимание. Собеседование прошло скучно и уныло. Собственно сам вопрос:\n1. Отлавливание ошибок на стороне фронта. Нужно рассказать про sentry"
      },
      {
        "timestamp": "2025-05-20 14:56:17",
        "content": "2025-05-20 14:56:17\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с командами. 1 команда.\nБыли те же вопросы.\n\nПомимо них:\n1. Настраивал ли сборщики? Webpack, vite.\n2. Разбивал ли на чанки?\n3. Настраивал ли CI/CD?\n4.  Было ли требование к покрытию тестами?\n5. Как принималось решение о покрытие тестами?\n6.  Встречался с оптимизацией со стороны Next. Вопрос по нексту был так как он рендерится на серваке.\n7.  Вопрос по оптимизации(lazyload, preloader).\n8, На странице есть input, ввел символ но он мед...",
        "full_content": "2025-05-20 14:56:17\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с командами. 1 команда.\nБыли те же вопросы.\n\nПомимо них:\n1. Настраивал ли сборщики? Webpack, vite.\n2. Разбивал ли на чанки?\n3. Настраивал ли CI/CD?\n4.  Было ли требование к покрытию тестами?\n5. Как принималось решение о покрытие тестами?\n6.  Встречался с оптимизацией со стороны Next. Вопрос по нексту был так как он рендерится на серваке.\n7.  Вопрос по оптимизации(lazyload, preloader).\n8, На странице есть input, ввел символ но он медленно отработал. Что будешь делать? Если на странице много input обернуть в usecallback.\n9. Когда стоит использовать useCallback, useMemo. А когда не стоит?\n10. Реконсиляция (Reconsilation).\n11. Что может произойти если мы передали функцию в компонент, и не обернули в memo или usecallback.\n12. Что  приходит на ум. Ввел несколько символов, но они затерлись.\n13. Приходилось работать с таблицами? Оптимизировал ли таблицы? Про виртуализацию стоит рассказать.\n14. Какой выбрать стейт менеджер? Redux vs Context.\n15. Спрашивал React Hook Form. Динамическое добавление input. useFieldsArray.\n16. Где применял WebSoket?\n17.  Что делали с промежуточным данными которые могли потеряться при переподлючении к сокету?\n18. Использовал ли React Query?\n19. Что бы решил использовать из личных проектов? Из пет проектов.\n20.  Рассказать про TypeScript? Спросил про Infer.\n21. Рассказать про SCSS, есть ли сходства с новым CSS. Почему бы использовал SCSS?"
      },
      {
        "timestamp": "2025-05-19 16:16:13",
        "content": "2025-05-19 16:16:13\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с вопросами по опыту работы.\nЗапросил 200.000 - 250.000\n\nРассказать про последний опыт? За последний год.\nРассказать про работу в команде?\nНад каким проектом работали?\nКак устроена работа над проектами?\nКакая роль в команде?\nРассказать про согласование handler`ов на бэке? Надо было рассказать как устроена апиха, где что описывалось.\nРассказать про команда? \nСколько человек в команде кто за что отвечает? \nКак работали? По спринтам?\nК...",
        "full_content": "2025-05-19 16:16:13\n Sasha -> 2071074234:\nЯндекс Эйчартех, этап с вопросами по опыту работы.\nЗапросил 200.000 - 250.000\n\nРассказать про последний опыт? За последний год.\nРассказать про работу в команде?\nНад каким проектом работали?\nКак устроена работа над проектами?\nКакая роль в команде?\nРассказать про согласование handler`ов на бэке? Надо было рассказать как устроена апиха, где что описывалось.\nРассказать про команда? \nСколько человек в команде кто за что отвечает? \nКак работали? По спринтам?\nКак происходила постановка задачи?\nРассказать про фронтовую команду. Менторил ли кого то или учавствовал в найме?\n\nОбсуждение задач, которыми занимался. Тут стоит приготовить и расписать интересную задачу.\nКакие технологии использовали? Рассказать про стек, рассказывал про либы, помимо стека.\nРассказать для чего использовал WebSoket? Почему решили именно WebSoket?\nРассказать про менеджеры websoket? soketIO\nКак распределяли нагрузку по вебсокетам?\nЧто бы я сделал если вебсокеты не держат соединение? Рассказать про балансировщики, рассказать про сессии\nКакая нагрузка была на вебсокеты?\nКак отдавал данные бэкенд? Их было много\nКак выкатываем сервисы? Занимался ли релизами? Настраивал ли CI/CD? Рассказывал про CI/CD\nРазворачивал ли сам что то? Выкатывал код в продакшен?\nЕсть задачка выкатить код в прод? Как бы настраивал? Я сказал что у нас этим занимался девопс\nКак с тестированием? \nПроводим ли тестирование? \nБыли ли unit тесты?\nГоворили про e2e тесты? Какие бы добавил?\nДал задачку на тестирование, объяснить какие тесты внедрил бы? Какие виды тестов сделал?\nПриходилось ли оптимизировать приложение?\nТипичная задачка, у клиента сайт медленно грузится. Рассказывал про вкладку network, memory, react-profiler, виртуализацию, webpack, мемоизация\nРассказать про метрики отрисок? Рассказывал про lighthouse\nЕсть жалобы от клиентов. Сайт долго грузится. Рассказывал что можно замедлить соединение в network\n\nПривести пример когда что привносил в проект? Оптимизировал что то\nРассказать про конфликты внутри команды.\nРассказать пример когда наоборот положительная коммуникация оказала хорошее влияние."
      },
      {
        "timestamp": "2025-05-15 14:24:56",
        "content": "2025-05-15 14:24:56\n Артур Виноградов -> 2071074234:\nЯндекс. 2 этап (новый)\nЗП: 300\nОдна большая задача.\nт.к она реально огромная по содержанию, запилил в файлы",
        "full_content": "2025-05-15 14:24:56\n Артур Виноградов -> 2071074234:\nЯндекс. 2 этап (новый)\nЗП: 300\nОдна большая задача.\nт.к она реально огромная по содержанию, запилил в файлы"
      },
      {
        "timestamp": "2025-05-15 07:27:57",
        "content": "2025-05-15 07:27:57\n Alexandro 4 -> 2071074234:\nfunction PromiseAny (arr) {\n\n    if (arr.length === 0) {\n        return Promise.reject(new AggregateError([], 'Все промисы отклонены'))\n    }\n\n    return new Promise((resolve, reject) => {\n        const errors = []\n        let rejectedCount = 0\n        arr.forEach((promise, index) => {\n            Promise.resolve(promise)\n                .then(resolve)\n                .catch((error) => {\n                    errors[index] = error\n                   ...",
        "full_content": "2025-05-15 07:27:57\n Alexandro 4 -> 2071074234:\nfunction PromiseAny (arr) {\n\n    if (arr.length === 0) {\n        return Promise.reject(new AggregateError([], 'Все промисы отклонены'))\n    }\n\n    return new Promise((resolve, reject) => {\n        const errors = []\n        let rejectedCount = 0\n        arr.forEach((promise, index) => {\n            Promise.resolve(promise)\n                .then(resolve)\n                .catch((error) => {\n                    errors[index] = error\n                    rejectedCount += 1\n\n                    if (rejectedCount === arr.length) {\n                        reject(new AggregateError(errors, 'Все промисы отклонены'))\n                    }\n            })\n        })\n    })\n}\nP.S. Похоже Яндекс меняет стиль проведения собесов, ибо ранее на этапе JS дебажить нельзя было и шарить экран не просили."
      },
      {
        "timestamp": "2025-05-15 07:27:57",
        "content": "2025-05-15 07:27:57\n Alexandro 4 -> 2071074234:\n15.05 Яндекс.Маркет\n- Первый этап (JS)\n- HR сам написал.\n- 250 (но вилка 250-400 если верить HR с яндекс мульти трека)\n\nЗастримить не получилось, потому что собес проходил в 8 утра по мск. \nДумаю, все спят в это время. Надо будет слот брать после обеда в следующий раз.\n\nВАЖНО: В самом начале попросили проверить шаринг экрана до того как дали ссылку на комнату интервью.\nПотом с третьей задачи разрешили дебажить (появляется кнопка Run Code), но нужно...",
        "full_content": "2025-05-15 07:27:57\n Alexandro 4 -> 2071074234:\n15.05 Яндекс.Маркет\n- Первый этап (JS)\n- HR сам написал.\n- 250 (но вилка 250-400 если верить HR с яндекс мульти трека)\n\nЗастримить не получилось, потому что собес проходил в 8 утра по мск. \nДумаю, все спят в это время. Надо будет слот брать после обеда в следующий раз.\n\nВАЖНО: В самом начале попросили проверить шаринг экрана до того как дали ссылку на комнату интервью.\nПотом с третьей задачи разрешили дебажить (появляется кнопка Run Code), но нужно расшарить экран.\n\n\n1) Что будет выводиться в консоль?\nvar n = 1;\nfunction f(n) {\n  n = 3;\n}\nf(n);\nconsole.log(n); // ?? 1\n\n\nvar obj = { a: 1 };\nfunction f1(o) {\n  o.a = 5;\n}\nf1(obj);\nconsole.log(obj); // ?? { a: 5 };\n\n\nvar obj = { a: 1 };\nfunction f2(o) {\n  o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // ??{ a: 1 };\n\n2) Sleep\n/*\n  Написать функцию sleep, которая будет спать заданное количество миллисекунд, а потом успешно завершаться\n  Тут необходимо было рассказать про eventloop и как браузер будет обрабатывать код\n*/\nfunction sleep(duration) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        }, duration)\n    })\n}\n\n3) Реализовать GroupBy у массивов\n/*\n- Необходимо реализовать метод groupBy, расширяющий стандартные методы массивов.\n- Метод должен возвращать сгруппированную версию массива — объект,\n- в котором каждый ключ является результатом выполнения переданной функции fn(arr[i]),\n- а каждое значение — массивом, содержащим все элементы исходного массива с этим ключом.\n*/\nArray.prototype.groupBy = function (cb) {\n  if (!cb) {\n    throw new Error('No callback added')\n  }\n  \n  result = {}\n  \n  for (const item of this){\n        const key = cb(item)\n        if (!result[key]) {\n            result[key] = []\n        }\n        result[key].push(item)  \n  }\n   \n  return result\n}\n\nconst arr = [3.3, 0.5, 1.4]\nconsole.log(arr.groupBy(Math.round))\n\n4) get(url)\n/*\n- Необходимо написать функцию, которая на вход принимает урл,\n- асинхронно ходит по этому урлу GET запросом и возвращает данные (json).\n- Для получения данных использовать fetch.\n- Можно использовать только Promise API\n- Если во время запроса произошла ошибка, то пробовать запросить ещё 5 раз.\n- Если в итоге информацию получить не удалось, вернуть ошибку \"Заданный URL недоступен\".\n*/\nfunction get(url, retries = 5) {\n    return fetch(url).then(res => {\n        if (!res.ok) {\n            throw new Error('ошибка сети')\n        }\n        return res.json()\n    }).then(data => data).catch((err) => {\n        if (retries > 0) {\n            return get(url, retries - 1)\n        } else {\n            throw new Error('Заданный URL недоступен')\n        }\n    })\n}\n\n5) Перевод строки в из camelCase в underscore_case\nfunction convert(text){\n    const arr = text.split('')\n    let result = ''\n    for (let i = 0; i < arr.length; i++){\n        let char = arr[i];\n        if (i >= 1 && char === char.toUpperCase()){\n            result += '_' + char.toLowerCase()\n        } else {\n            result += char.toLowerCase()\n        }\n    }\n    return result;\n}\n\nconsole.log(convert(\"updatedAt\")) // updated_ad\nconsole.log(convert(\"XmlHttpRequest\")) // xml_http_request\n\nЗдесь спросили про сложность алгоритма. Сказал, что линейная O(N).\nНо был вопрос, что на самом деле в JS это не так, мол из-за конкатенации строки \"result += '_' + char.toLowerCase()\" на очень длинных строках начинаются какие то проблемы (чисто проблема JS, в других языках такого нет)\n\n6) Реализовать Promise.any"
      },
      {
        "timestamp": "2025-05-12 18:37:27",
        "content": "2025-05-12 18:37:27\n Василий -> 2071074234:\n05.05 Яндекс 1 этап - знакомство, вопросы по опыту.\n-Чем горжусь \n-Что ищу\n-Почему ушёл",
        "full_content": "2025-05-12 18:37:27\n Василий -> 2071074234:\n05.05 Яндекс 1 этап - знакомство, вопросы по опыту.\n-Чем горжусь \n-Что ищу\n-Почему ушёл"
      },
      {
        "timestamp": "2025-05-10 19:43:37",
        "content": "2025-05-10 19:43:37\n Alexandro 4 -> 2071074234:\nЯндекс Маркет. HR скрининг.\nЗП 250\n\n1) Расскажите об опыте в IT (универ, первая работа, вторая работа)\n2) Как устроена работа в команде (про scrum)\n3) Самая сложная задача на текущем месте работы?\n4) Куда планируете разиваться (сказал, что в NextJS)\n5) Готовы к офису/гибриду? (к следующему этапу, видимо, пригласят только, если готов к гибриду, предлагают помощь при релокации)\nОтвечал так себе. Как будто в любом случае позовут на этап технички.\nP.S....",
        "full_content": "2025-05-10 19:43:37\n Alexandro 4 -> 2071074234:\nЯндекс Маркет. HR скрининг.\nЗП 250\n\n1) Расскажите об опыте в IT (универ, первая работа, вторая работа)\n2) Как устроена работа в команде (про scrum)\n3) Самая сложная задача на текущем месте работы?\n4) Куда планируете разиваться (сказал, что в NextJS)\n5) Готовы к офису/гибриду? (к следующему этапу, видимо, пригласят только, если готов к гибриду, предлагают помощь при релокации)\nОтвечал так себе. Как будто в любом случае позовут на этап технички.\nP.S. Два HR написали сами и общался со вторым (Маркет), а первая скидывала ссылку на MultiTrack вакансию - https://getmatch.ru/vacancies/15519 и сразу указала вилку до 400к, но с ней общение не пошло - ответил ей, что желательна удаленка и дальше игнор на двое суток."
      },
      {
        "timestamp": "2025-05-06 14:52:41",
        "content": "2025-05-06 14:52:41\n Sasha -> 2071074234:\nЯндекс. Эйчартех. 1 этап проверка знаний на js.\n1.  Тут все понятно, реализация своего intersection\n\nSet.prototype.intersection = function (otherSet) {\n  const result = new Set();\n  const [small, large] = this.size < otherSet.size ? [this, otherSet] : [otherSet, this];\n\n  for (const item of small) {\n    if (large.has(item)) {\n      result.add(item);\n    }\n  }\n\n  return result;\n};\n2. В комментах написано что нужно сделать\n\n/**\n * ✅ Реализовать функцию any...",
        "full_content": "2025-05-06 14:52:41\n Sasha -> 2071074234:\nЯндекс. Эйчартех. 1 этап проверка знаний на js.\n1.  Тут все понятно, реализация своего intersection\n\nSet.prototype.intersection = function (otherSet) {\n  const result = new Set();\n  const [small, large] = this.size < otherSet.size ? [this, otherSet] : [otherSet, this];\n\n  for (const item of small) {\n    if (large.has(item)) {\n      result.add(item);\n    }\n  }\n\n  return result;\n};\n2. В комментах написано что нужно сделать\n\n/**\n * ✅ Реализовать функцию any, которая бы работала, как Promise.any().\n * ▪️ Функция принимает массив промисов (считаем, что не пустой) и возвращает промис.\n * ▪️ Если какой-то из переданных промисов резолвится (успешно выполняется), то возвращаемый промис резолвится с этим значением.\n * ▪️ Если все переданные промисы реджектятся, то возвращаемый промис реджектится с ошибкой AggregateError, в которой сгруппированы все ошибки, с учётом порядка.\n *\n * AggregateError можно создавать таким образом:\n * new AggregateError(errors, 'No Promise in any was resolved')\n */\n\nclass AggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.name = 'AggregateError';\n  }\n}\n\nfunction any(promises) {\n  return new Promise((resolve, reject) => {\n    const errors = [];\n    let rejectedCount = 0;\n\n    promises.forEach((p, i) => {\n      Promise.resolve(p)\n        .then(resolve)\n        .catch((err) => {\n          errors[i] = err;\n          rejectedCount++;\n          if (rejectedCount === promises.length) {\n            reject(new AggregateError(errors, 'No Promise in any was resolved'));\n          }\n        });\n    });\n  });\n}\n\n// Примеры использования\nconsole.clear();\nconst p1 = Promise.reject('Error 1');\nconst p2 = Promise.reject('Error 2');\nconst p3 = Promise.resolve(3);\n\nany([p1, p2, p3]).then(console.log); // 3\n3. Что то типо реализации методов массива + вывод максимального значения\n\nclass MaxStack {\n  constructor() {\n    this.stack = [];\n    this.maxStack = [];\n  }\n\n  push(value) {\n    this.stack.push(value);\n    const max = this.maxStack.length === 0\n      ? value\n      : Math.max(value, this.maxStack[this.maxStack.length - 1]);\n    this.maxStack.push(max);\n  }\n\n  pop() {\n    if (this.stack.length === 0) throw new Error('Stack is empty');\n    this.maxStack.pop();\n    return this.stack.pop();\n  }\n\n  max() {\n    if (this.maxStack.length === 0) throw new Error('Stack is empty');\n    return this.maxStack[this.maxStack.length - 1];\n  }\n}\n\nconst stack = new MaxStack();\nstack.push(2); // max = 2, stack = [2]\nstack.push(1); // max = 2, stack = [2, 1]\nstack.push(3); // max = 3, stack = [2, 1, 3]\nstack.push(3); // max = 3"
      },
      {
        "timestamp": "2025-05-05 13:43:43",
        "content": "2025-05-05 13:43:43\n Василий -> 2071074234:\n- Яндекс Кинопоиск Smart TV 1 этап. \n- Вакансия https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-kinopoisk-smart-tv-33211\nТолько софтовые вопросы.\n\n- опыт\n- какие сложные задачи я делал\n- что меня мотивирует в работе\n- как устроена команда, как происходит управление (scrum, kanban)\n- какими своими фичами я горжусь в проекте",
        "full_content": "2025-05-05 13:43:43\n Василий -> 2071074234:\n- Яндекс Кинопоиск Smart TV 1 этап. \n- Вакансия https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-kinopoisk-smart-tv-33211\nТолько софтовые вопросы.\n\n- опыт\n- какие сложные задачи я делал\n- что меня мотивирует в работе\n- как устроена команда, как происходит управление (scrum, kanban)\n- какими своими фичами я горжусь в проекте"
      },
      {
        "timestamp": "2025-05-04 19:00:42",
        "content": "2025-05-04 19:00:42\n Артур Виноградов -> 2071074234:\nЯндекс. Скрининг\nЗП: 300\n\n1) Готовы ли рассмотреть гибридный или офисный формат работы (2-3 дня в неделю в офисе)?\n2) Есть ли офферы на руках? Есть ли дедлайн по принятию решения?\n3) Сколько лет опыта TypeScript и React? Сколько лет опыта на NodeJS. Что именно делали? \n4) Какая роль на последнем месте? Какими задачами занимаетесь?\n5) Были ли тесты на проекте, если да, то какие?\n6) Когда вы готовы предварительно начать процесс прохождения техни...",
        "full_content": "2025-05-04 19:00:42\n Артур Виноградов -> 2071074234:\nЯндекс. Скрининг\nЗП: 300\n\n1) Готовы ли рассмотреть гибридный или офисный формат работы (2-3 дня в неделю в офисе)?\n2) Есть ли офферы на руках? Есть ли дедлайн по принятию решения?\n3) Сколько лет опыта TypeScript и React? Сколько лет опыта на NodeJS. Что именно делали? \n4) Какая роль на последнем месте? Какими задачами занимаетесь?\n5) Были ли тесты на проекте, если да, то какие?\n6) Когда вы готовы предварительно начать процесс прохождения технических этапов?"
      },
      {
        "timestamp": "2025-04-29 16:34:48",
        "content": "2025-04-29 16:34:48\n Равиль Васильев -> 2071074234:\nЯндекс с командой\n\nЗП - 240/270 на руки\n\n📢 Вакансия -hr написала\n\n🎥 Запись собеса - https://www.youtube.com/watch?v=UEF3s7jxl40",
        "full_content": "2025-04-29 16:34:48\n Равиль Васильев -> 2071074234:\nЯндекс с командой\n\nЗП - 240/270 на руки\n\n📢 Вакансия -hr написала\n\n🎥 Запись собеса - https://www.youtube.com/watch?v=UEF3s7jxl40"
      },
      {
        "timestamp": "2025-04-22 10:48:11",
        "content": "2025-04-22 10:48:11\n Лёша -> 2071074234:\nКомпания: Яндекс 2 этап\n\nЗадачи:\n1\n/**\n * Наше приложение-чат должно отображать новые сообщения, которые приходят с сервера, как можно быстрее.\n *\n * Сообщение имеет формат:\n * interface Message {\n *   id: number\n *   text: string\n * }\n *\n * Id самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\n * Нам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\n * сообщений, о...",
        "full_content": "2025-04-22 10:48:11\n Лёша -> 2071074234:\nКомпания: Яндекс 2 этап\n\nЗадачи:\n1\n/**\n * Наше приложение-чат должно отображать новые сообщения, которые приходят с сервера, как можно быстрее.\n *\n * Сообщение имеет формат:\n * interface Message {\n *   id: number\n *   text: string\n * }\n *\n * Id самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\n * Нам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\n * сообщений, отправляемых в наше приложение.\n *\n * Таймлайн:\n * // (приходит) 7  1  2  3  6  5  4  8\n * // (рисуем)   .  1  2  3  .  4  5  6  7  8\n *\n * Сообщения от сервера приходят в обработчик функции connect:\n * connect(function onMessage(message) {\n *   ...\n * }); \n * \n * Отображать сообщения нужно с помощью функции render:\n * render(message)\n */\n\nfunction solution(connect, render) {\n    connect(function onMessage(message) {\n        render(message);\n    });\n}\n\n2\n/**\n * В прототипе рекламной сети продажа рекламных мест устроена \n * следующим образом: покупатели заранее называют свою цену,\n * а на каждом рекламном месте отвечают, готовы ли его купить или нет. \n * Необходимо реализовать функцию, которая будет проводить продажу рекламного места.\n * Buyer ожидает согласия или отказа от покупателя с самой высокой цены,\n * а затем предлагает рекламное место покупателю с самой низкой ценой\n * среди тех, кто согласился на покупку.\n * \n * Вернуть ответ из функции нужно настолько быстро, насколько это возможно.\n * \n * Примеры:\n * \n * Покупатели предлагают цену 1, 5, 10\n * Покупатель с предложением 10 отвечает отказом\n * Покупатель с предложением 1 отвечает согласием // Всё ещё ждём, \n * проверяем покупателя с предложением 5 \n * \n * ------------\n * \n * Покупатели предлагают цену 1, 5, 10\n * Покупатель с предложением 1 отвечает отказом\n * Покупатель с предложением 10 отвечает согласием // Ждём ответа от покупателя с предложением 1 – его точно не выберем\n * \n * ------------\n * \n * Покупатели предлагают цену 1, 2\n * Покупатель с предложением 1 отвечает отказом\n * Покупатель с предложением 2 отвечает отказом // Не выбираем ни одного покупателя\n */\n\n/* \ntype Buyer = {\n    price: number,\n    accepts: () => Promise<boolean>,\n}\n*/"
      },
      {
        "timestamp": "2025-04-22 10:44:24",
        "content": "2025-04-22 10:44:24\n Лёша -> 2071074234:\nКомпания: Яндекс 1 этап\n\nЗадачи:\n1\n// — 1 — \nconsole.log( typeof [] ) // ??\n\n// — 2 — \nconsole.log( typeof null ) // ??\n\n// — 3 — \nconsole.log( 1 + \"2\" ) // ??\n\n// — 4 — \nconsole.log( \"4\" - 2 ) // ??\n\n// — 5 — \nconst first = () => console.log('Один')\nconst second = () => console.log('Два')\nconst third = () => console.log('Три')\n\nfirst()\nsetTimeout(second, 0)\nthird()\n\n// ??\n\n// — 6 — \nvar a = 2\nvar b = a\nb++\n\nconsole.log(a) // ??\nconsole.log(b) // ??\n\n// —...",
        "full_content": "2025-04-22 10:44:24\n Лёша -> 2071074234:\nКомпания: Яндекс 1 этап\n\nЗадачи:\n1\n// — 1 — \nconsole.log( typeof [] ) // ??\n\n// — 2 — \nconsole.log( typeof null ) // ??\n\n// — 3 — \nconsole.log( 1 + \"2\" ) // ??\n\n// — 4 — \nconsole.log( \"4\" - 2 ) // ??\n\n// — 5 — \nconst first = () => console.log('Один')\nconst second = () => console.log('Два')\nconst third = () => console.log('Три')\n\nfirst()\nsetTimeout(second, 0)\nthird()\n\n// ??\n\n// — 6 — \nvar a = 2\nvar b = a\nb++\n\nconsole.log(a) // ??\nconsole.log(b) // ??\n\n// — 7 — \nvar c = [1, 2, 3]\nvar d = c\nd.push(4)\nconsole.log(c) // ??\nconsole.log(d) // ??\n\n// — 8 — \n{\n    console.log(i) // ??\n    var i = 10\n    console.log(i) // ??\n}\n\n2\n// Необходимо реализовать метод groupBy, расширяющий стандартные методы массивов.\n// Метод должен возвращать сгруппированную версию массива — объект,\n// в котором каждый ключ является результатом выполнения переданной функции fn(arr[i]),\n// а каждое значение — массивом, содержащим все элементы исходного массива с этим ключом.\n\n// code here\n\n3\n/**\n * Необходимо написать функцию, которая на вход принимает url,\n * асинхронно ходит по этому урлу GET запросом и возвращает данные (json).\n * Для получения данных использовать fetch.\n * Можно использовать только Promise API\n * Если во время запроса произошла ошибка, то пробовать запросить ещё 5 раз.\n * Если в итоге информацию получить не удалось, вернуть ошибку \"Заданный URL недоступен\".\n */\n\nfunction get(url) {\n    // code here\n}\n\nget(url)\n  .then(res => console.log(res))\n  .catch(err => console.error(err))\n\n4\n// Вам задана строка, состоящая из латинских букв, пробелов и знаков препинания.\n// Строка называется панграммой, если она содержит каждую из 26 латинских\n// букв хотя бы раз. Определите, является ли строка панграммой.\n// Сложность O(n)\n\nconst LETTERS = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\nfunction isPangram(text) {\n    // your code here\n}\n\n5\n/**\n * Написать декоратор для функции, который ограничивает число вызовов.\n *\n * callLimit(fn, limit, callback) принимает следующие аргументы:\n *  fn – функция, которую декорируем;\n *  limit – максимальное число вызовов;\n *  callback – вызывается, когда совершен последний вызов. Опционально.\n * У вызываемой функции должен быть метод для перезагрузки счетчика в начальное положение.\n */\n\nfunction callLimit(fn, limit, callback) {\n    // Тут что-то написать\n}\n\nfunction log(title, message) {\n    console.log(title + ': ' + message);\n}"
      },
      {
        "timestamp": "2025-04-16 17:20:01",
        "content": "2025-04-16 17:20:01\n Max -> 2071074234:\n- Яндекс (1 этап)\n- зп: 200 \n- hr написал\nЗадачи:\n1. Написать функцию, которая вызывается один раз\nfunction runOnce(fn) {\n  let called = false;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      return fn.apply(this, args);\n    }\n  };\n}\n\nconst logHello = () => {\n  console.clear();\n  console.log('hello');\n};\n\nconst logHelloOnce = runOnce(logHello);\nlogHelloOnce(); // 'hello'\nlogHelloOnce(); // undefined\n2 задача:\nРеализуйте функцию ...",
        "full_content": "2025-04-16 17:20:01\n Max -> 2071074234:\n- Яндекс (1 этап)\n- зп: 200 \n- hr написал\nЗадачи:\n1. Написать функцию, которая вызывается один раз\nfunction runOnce(fn) {\n  let called = false;\n  return function (...args) {\n    if (!called) {\n      called = true;\n      return fn.apply(this, args);\n    }\n  };\n}\n\nconst logHello = () => {\n  console.clear();\n  console.log('hello');\n};\n\nconst logHelloOnce = runOnce(logHello);\nlogHelloOnce(); // 'hello'\nlogHelloOnce(); // undefined\n2 задача:\nРеализуйте функцию compose, которая принимает любое количество функций и возвращает новую функцию.\nfunction compose(...fns) {\n  return function (...args) {\n    return fns.reduceRight((res, fn, index) => {\n      // Если это самая правая функция, она вызывается с аргументами\n      return index === fns.length - 1 ? fn(...res) : fn(res);\n    }, args);\n  };\n}"
      },
      {
        "timestamp": "2025-04-11 09:22:49",
        "content": "2025-04-11 09:22:49\n Dan -> 2071074234:\nЯндекс (алгосы) 2й этап\nзп - ?\nхрка сама написала \n\nДан массив чисел (возможно неупорядоченный). Требуется преобразовать его в строку, где последовательные числа представлены в виде диапазонов через дефис (например, \"1-3\"), а отдельные числа или диапазоны разделены запятыми.\nfunction compress(numbers) {\n  if (numbers.length === 0) return '';\n  \n  // Сортируем числа\n  const sorted = [...numbers].sort((a, b) => a - b);\n  \n  const ranges = [];\n  let start = s...",
        "full_content": "2025-04-11 09:22:49\n Dan -> 2071074234:\nЯндекс (алгосы) 2й этап\nзп - ?\nхрка сама написала \n\nДан массив чисел (возможно неупорядоченный). Требуется преобразовать его в строку, где последовательные числа представлены в виде диапазонов через дефис (например, \"1-3\"), а отдельные числа или диапазоны разделены запятыми.\nfunction compress(numbers) {\n  if (numbers.length === 0) return '';\n  \n  // Сортируем числа\n  const sorted = [...numbers].sort((a, b) => a - b);\n  \n  const ranges = [];\n  let start = sorted[0];\n  let end = start;\n  \n  for (let i = 1; i < sorted.length; i++) {\n    const current = sorted[i];\n    \n    // Если текущее число следует за предыдущим, расширяем диапазон\n    if (current === end + 1) {\n      end = current;\n    } else {\n      // Иначе закрываем текущий диапазон и начинаем новый\n      if (start === end) {\n        ranges.push(`${start}`);\n      } else {\n        ranges.push(`${start}-${end}`);\n      }\n      \n      start = current;\n      end = current;\n    }\n  }\n  \n  // Добавляем последний диапазон\n  if (start === end) {\n    ranges.push(`${start}`);\n  } else {\n    ranges.push(`${start}-${end}`);\n  }\n  \n  return ranges.join(',');\n}\n\nРазработать функцию для загрузки данных по массиву URL-адресов, соблюдая два ключевых требования:\n\nОграничение одновременных запросов: В любой момент времени должно выполняться не более limit параллельных запросов (где limit - заданный лимит)\nКеширование результатов: Если определенный URL встречается несколько раз, физический запрос должен выполняться только один раз, а результат переиспользоваться\n\n\nfunction parallelLimit(urls, limit, callback) {\n  const cache = new Map();\n  const results = new Array(urls.length);\n  let active = 0;\n  let index = 0;\n\n  function next() {\n    if (index >= urls.length && active === 0) {\n      callback(results);\n      return;\n    }\n\n    while (active < limit && index < urls.length) {\n      const i = index;\n      const url = urls[i];\n      index++;\n      active++;\n\n      let fetchPromise;\n      if (cache.has(url)) {\n        fetchPromise = cache.get(url);\n      } else {\n        fetchPromise = mockFetch(url); // замените на fetch(url).then(res => res.text()) для реального запроса\n        cache.set(url, fetchPromise);\n      }\n\n      fetchPromise\n        .then((res) => {\n          results[i] = res;\n        })\n        .finally(() => {\n          active--;\n          next();\n        });\n    }\n  }\n\n  next();\n}"
      },
      {
        "timestamp": "2025-04-08 17:36:15",
        "content": "2025-04-08 17:36:15\n Ostrov Ostrov -> 2071074234:\nКомпания: Яндекс вертикали (1  этап)\nЧистые условия задач без решений смотри выше 👆\nВалидные решения: \n        ///////////////////// Задача 1\n        /// Реализовать функция sumPromises, которая принимает в качестве аргументов промисы и возвращает сумму результатов их выполнения.\n        /// Функция может принимать любое количество аргументов\n        /// Можно использовать любые API промисов.\n\n\n        ///Пример использования: \n        const prom...",
        "full_content": "2025-04-08 17:36:15\n Ostrov Ostrov -> 2071074234:\nКомпания: Яндекс вертикали (1  этап)\nЧистые условия задач без решений смотри выше 👆\nВалидные решения: \n        ///////////////////// Задача 1\n        /// Реализовать функция sumPromises, которая принимает в качестве аргументов промисы и возвращает сумму результатов их выполнения.\n        /// Функция может принимать любое количество аргументов\n        /// Можно использовать любые API промисов.\n\n\n        ///Пример использования: \n        const promise1 = Promise.resolve(1);\n        const promise2 = Promise.resolve(2)\n\n\n        Number.prototype.times = function (callback) {\n            for (let i = 0; i < this; i++) {\n                callback(i);\n            }\n        };\n\n        function sumPromises(...promises) {\n            return Promise.all(promises)\n                .then(results => results.reduce((sum, value) => sum + value, 0));\n        }\n\n\n\n\n        ///////////////////// Задача 2\n        // Написать декоратор для функции, который ограничивает число вызовов.\n        //\n        // callLimit(fn, limit, callback), принимает следующие аргументы:\n        // fn - функция, которую декодируем;\n        // limit - маскимальное число вызовов\n        // callback - вызывается, когда совершен последний вызов. Опционально.\n        // У вызываемой функции должен быть метод для перезагрузки счетчика в начале\n\n        function callLimit(fn, limit, callback) {\n            let count = 0; // Счётчик вызовов\n\n            // Обёртка над исходной функцией\n            function wrapper(...args) {\n                if (count >= limit) return; // Прекратить выполнение, если лимит превышен\n\n                count++; // Увеличить счётчик\n\n                // Если вызов достиг лимита — вызвать callback (если он передан)\n                if (count === limit && typeof callback === 'function') {\n                    callback();\n                }\n\n                // Вызов оригинальной функции с переданными аргументами\n                return fn.apply(this, args);\n            }\n\n            // Метод для ручного сброса счётчика вызовов\n            wrapper.reset = function () {\n                count = 0;\n            };\n\n            return wrapper; // Вернуть обёрнутую функцию\n        }\n\n\n\n        ///////////////////// Задача 3\n        // Необходимо проверить решение задачи по двум сервисам,\n        // вызвав checkResult(url1, solution), checkResult(url2, solution)\n        // checkResult: (url: string, solution: string | number) => Promise<boolean>;\n        // * Если оба запроса вернули true - вывести succes\n        // * Если хоть один вернул false - вывести fail\n        // * Если хоть зареджектился - вывести error\n        // * Если хоть один отвечает дольше 1 сек - вывести timeout\n\n        import { checkResult } from \"myLib\"\n\n        const solution = \"Any answer\"\n        const url1 = \"yandex.ru\"\n        const url2 = \"google.com\"\n\n        checkResult(url, solution);\n        checkResult(url, solution);\n\n        async function check() {\n            const TIMEOUT_MS = 1000;\n\n            // Оборачиваем каждый вызов в Promise.race с таймаутом\n            const withTimeout = (url) => {\n                return Promise.race([\n                    checkResult(url, solution), // основной вызов\n                    new Promise((_, reject) =>  // таймаут\n                        setTimeout(() => reject(new Error('timeout')), TIMEOUT_MS)\n                    )\n                ]);\n            };\n\n            try {\n                // Запускаем оба запроса параллельно\n                const [res1, res2] = await Promise.all([\n                    withTimeout(url1),\n                    withTimeout(url2)\n                ]);\n\n                // Если оба true\n                if (res1 === true && res2 === true) {\n                    console.log('success');\n                }\n                // Если хотя бы один false\n                else if (res1 === false || res2 === false) {\n                    console.log('fail');\n                }"
      },
      {
        "timestamp": "2025-04-08 17:34:36",
        "content": "2025-04-08 17:34:36\n Ostrov Ostrov -> 2071074234:\nКомпания: Яндекс вертикали (1  этап)\n\nЗП - от 250k\n\n📢 Вакансия - https://hh.ru/vacancy/118934714\n\n❓Лайвкодинг\n\nЗадачи: \n/// Задача 1\n/// Реализовать функция sumPromises, которая принимает в качестве аргументов промисы и возвращает сумму результатов их выполнения.\n/// Функция может принимать любое количество аргументов\n/// Можно использовать любые API промисов.\n\n\nПример использования: \nconst promise1 = Promise.resolve(1);\nconst promise2 = Promise....",
        "full_content": "2025-04-08 17:34:36\n Ostrov Ostrov -> 2071074234:\nКомпания: Яндекс вертикали (1  этап)\n\nЗП - от 250k\n\n📢 Вакансия - https://hh.ru/vacancy/118934714\n\n❓Лайвкодинг\n\nЗадачи: \n/// Задача 1\n/// Реализовать функция sumPromises, которая принимает в качестве аргументов промисы и возвращает сумму результатов их выполнения.\n/// Функция может принимать любое количество аргументов\n/// Можно использовать любые API промисов.\n\n\nПример использования: \nconst promise1 = Promise.resolve(1);\nconst promise2 = Promise.resolve(2)\n\n\n/// Задача 2\n/// Написать декоратор для функции, который ограничивает число вызовов.\n///\n/// callLimit(fn, limit, callback), принимает следующие аргументы:\n/// fn - функция, которую декодируем;\n/// limit - маскимальное число вызовов\n/// callback - вызывается, когда совершен последний вызов. Опционально.\n/// У вызываемой функции должен быть метод для перезагрузки счетчика в начале\n\n/// Задача 3\n/// Необходимо проверить решение задачи по двум сервисам, вызвав chekResult(url1, solution), checkResult(url2, solution)\n/// checkResult: (url: string, solution: string | number) => Promise<boolean>;\n// * Если оба запроса вернули true - вывести succes\n// * Если хоть один вернул false - вывести fail\n// * Если хоть зареджектился - вывести error\n// * Если хоть один отвечает дольше 1 сек - вывести timeout\n\nimport {checkResult} from \"myLib\"\n\nconst solution = \"Any answer\"\nconst url1 = \"yandex.ru\"\nconst url2 = \"google.com\"\n\ncheckResult(url, solution);\ncheckResult(url, solution);\n\n/// Задача 4\n/// Есть дерево, на котором сидят белки (squirrels) и вороны (ravens). Необходимо написать функцию\n/// которая находит всех белок на дереве и возвращает их имена в массиве.\n///\nfunction squirrelScanner(tree) {\n //you code here\n \n}\n\n\n// type Tree = {\n//   nest: Squirrel | Raven;\n//   branches?: Tree[];\n// };\n\n// type Squirrel = {\n//   name: string;\n//   type: 'squirrel';\n// };\n\n// type Raven = {\n//   name: string;\n//   type: 'raven';\n// };\n\n/////////////////////\n\nconst tree = {\n  nest: { name: 'NEVERMORE!', type: 'raven' },\n  branches: [\n    {\n      nest: { name: 'Acorn', type: 'squirrel' },\n      branches: [\n        {\n          nest: { name: 'Sir Salty', type: 'squirrel' },\n        },\n        {\n          nest: { name: 'Huginn', type: 'raven' },\n          branches: [\n            {\n              nest: { name: 'Muninn', type: 'raven' },\n            },\n            {\n              nest: { name: 'Kernel', type: 'squirrel' },\n  branches:[]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n};"
      },
      {
        "timestamp": "2025-04-08 10:31:57",
        "content": "2025-04-08 10:31:57\n Равиль Васильев -> 2071074234:\nЯндекс систем дизайн\n\n📢 Вакансия - https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-komandu-platformennih-produktov-30780\n\n❓Вопросы:\n\nНужно было задизайнить архитектуру конструктора сайтов (Tilda).\nВообще к такому виду собеседований нужно готовиться отдельно, тут нет каких то \nопределенных вопросов классических, которые тебе задают. Наоборот ты задаешь вопросы и ведешь собеседующего.\n\n- какую БД бы выбрал и почему?\n- что использовал ...",
        "full_content": "2025-04-08 10:31:57\n Равиль Васильев -> 2071074234:\nЯндекс систем дизайн\n\n📢 Вакансия - https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-komandu-platformennih-produktov-30780\n\n❓Вопросы:\n\nНужно было задизайнить архитектуру конструктора сайтов (Tilda).\nВообще к такому виду собеседований нужно готовиться отдельно, тут нет каких то \nопределенных вопросов классических, которые тебе задают. Наоборот ты задаешь вопросы и ведешь собеседующего.\n\n- какую БД бы выбрал и почему?\n- что использовал бы под капотом в сервисах? \n- что использовал бы на фронтенде? \n- как реализовывал бы кеширование данных? \n- какие есть уязвимости и как с ними бороться?"
      },
      {
        "timestamp": "2025-04-03 17:42:20",
        "content": "2025-04-03 17:42:20\n Равиль Васильев -> 2071074234:\nЯндекс платформа 2 этап \n\n📢 Вакансия - https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-komandu-platformennih-produktov-30780\n\n\n📌 Задачи:\n\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение...",
        "full_content": "2025-04-03 17:42:20\n Равиль Васильев -> 2071074234:\nЯндекс платформа 2 этап \n\n📢 Вакансия - https://yandex.ru/jobs/vacancies/razrabotchik-interfeysov-v-komandu-platformennih-produktov-30780\n\n\n📌 Задачи:\n\n/*\ninterface Message {\n    id: number\n    text: string\n}\n\nId самого первого сообщения = 1, а id каждого следующего сообщения на 1 больше, чем id предыдущего.\nНам нужно выводить сообщения в правильном порядке, однако сервер не гарантирует правильный порядок\nсообщений, отправляемых в наше приложение.\n\nТаймлайн:\n// (приходит) 7 1 2 3 6 5 4    8\n// (рисунок)   . 1 2 3 . . 4 5 6 7 8\n\nСообщения от сервера приходят в обработчик функции connect:\n\nconnect((msg) => {\n    ...\n});\n\nОтображать сообщения нужно с помощью функции `render`:\nrender(msg)\n*/\n\n// РЕШЕНИЕ \n\nfunction solution(connect, render) {\n    // Создаем Map для хранения полученных сообщений\n    // Ключ - ID сообщения, значение - функция для его отрисовки\n    const map = new Map();\n    \n    // Текущий ожидаемый ID сообщения (начинаем с 1)\n    let currId = 1;\n    \n    // Подключаемся к источнику сообщений\n    connect((msg) => {\n        // Сохраняем сообщение в Map, оборачивая render в функцию\n        // Это позволяет отложить выполнение render до нужного момента\n        map.set(msg.id, () => render(msg));\n        \n        // Проверяем, есть ли в Map сообщения, которые можно отрисовать по порядку\n        while (map.has(currId)) {\n            // Получаем и вызываем функцию отрисовки для текущего ID\n            map.get(currId)();\n            \n            // Удаляем обработанное сообщение из Map\n            map.delete(currId);\n            \n            // Переходим к следующему ожидаемому ID\n            currId++;\n        }\n    });\n}\n\n/*\nДана вложенная структура файлов и папок в виде объекта:\n*/\n\nconst data = {\n    name: 'folder',\n    children: [\n        { name: 'file1.txt' },\n        { name: 'file2.txt' },\n        {\n            name: 'images',\n            children: [\n                { name: 'image.png' },\n                {\n                    name: 'vacation',\n                    children: [\n                        { name: 'crocodile.png' },\n                        { name: 'penguin.png' }\n                    ]\n                }\n            ]\n        },\n        { name: 'shopping-list.pdf' }\n    ]\n};\n\n/*\nЗадача:\nНужно вывести в консоль файлы и папки с отступами, чтобы показать вложенность.\nРешение должно учитывать любую вложенность элементов (т.е. не должно содержать рекурсивные вызовы).\n\nОжидаемый вывод:\nfolder\n  file1.txt\n  file2.txt\n  images\n    image.png\n    vacation\n      crocodile.png\n      penguin.png\n  shopping-list.pdf\n*/\n\n// Решение должно быть реализовано без использования рекурсии\n\n// РЕШЕНИЕ \n\nfunction printDirectoryStructure(data) {\n    // Используем стек для итеративного обхода структуры\n    const stack = [{ data, level: 0 }];\n    \n    while (stack.length > 0) {\n        // Извлекаем текущий элемент из стека\n        const { data, level } = stack.pop();\n        \n        // Выводим имя с соответствующим отступом\n        console.log(' '.repeat(level * 2) + data.name);\n        \n        // Если есть дети, добавляем их в стек в обратном порядке\n        if (data.children && Array.isArray(data.children)) {\n            for (let i = data.children.length - 1; i >= 0; i--) {\n                stack.push({\n                    data: data.children[i],\n                    level: level + 1\n                });\n            }\n        }\n    }\n}"
      },
      {
        "timestamp": "2025-04-02 09:09:18",
        "content": "2025-04-02 09:09:18\n Dan -> 2071074234:\nКомпания: Yandex ( Taxi )\n\nВопросы:\nРассказать про методы Promise-ов\n\nЗадачи: \n\nРеализовать функцию, которая принимает асинхронную функцию и время ограничения, и возвращает новую функцию. Новая функция должна выполнить исходную функцию, но с ограничением по времени. Если исходная функция не выполнится за указанное время, должна отклонить промис с сообщением “Time limit exceeded”.\n\n/**\n * @param {Function} fn - Асинхронная функция\n * @param {number} t - Вре...",
        "full_content": "2025-04-02 09:09:18\n Dan -> 2071074234:\nКомпания: Yandex ( Taxi )\n\nВопросы:\nРассказать про методы Promise-ов\n\nЗадачи: \n\nРеализовать функцию, которая принимает асинхронную функцию и время ограничения, и возвращает новую функцию. Новая функция должна выполнить исходную функцию, но с ограничением по времени. Если исходная функция не выполнится за указанное время, должна отклонить промис с сообщением “Time limit exceeded”.\n\n/**\n * @param {Function} fn - Асинхронная функция\n * @param {number} t - Время ограничения в миллисекундах\n**/\nconst timelimited = function (fn, t) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      // Запускаем асинхронную функцию\n      const fnPromise = fn(...args).then(resolve).catch(reject);\n\n      // Устанавливаем таймер на t миллисекунд\n      const timer = setTimeout(() => {\n        reject(\"Time limit exceeded\"); // Реджектим, если время истекло\n      }, t);\n\n      // Если функция успевает выполниться, очищаем таймер\n      fnPromise.finally(() => clearTimeout(timer));\n    });\n  };\n};\n\n// Пример использования\nasync function exampleFunction(x) {\n  return new Promise(resolve => setTimeout(() => resolve(x * 2), 1000)); // Выполняется за 1 секунду\n}\n\nconst limitedFunction = timelimited(exampleFunction, 500); // Ограничение 500 мс\n\nlimitedFunction(5)\n  .then(console.log)\n  .catch(console.error); // \"Time limit exceeded\"\n\n\nРеализовать функцию, которая проверяет, является ли строка панграммой (содержит все буквы алфавита). Функция должна возвращать true, если строка содержит все буквы из набора letters, и false в противном случае. \n\nfunction isPangramV2 (str) {\n    const lettersSet = new Set(letters)\n    const resultSet = new Set()\n\n    for (const item of str.toUpperCase()) {\n        if (lettersSet.has(item)) {\n            resultSet.add(item)\n        }\n\n        if (lettersSet.size === resultSet.size) return true\n    }\n\n    return lettersSet.size === resultSet.size\n\n}\n\n- Функция auth() оборачивает асинхронную функцию обратного вызова asyncAuth в промис, который резолвится с данными или отклоняется с ошибкой.\n- Функция tryAuth(n) должна пытаться аутентифицироваться с помощью функции auth(), делая до n+1 попыток. Если все попытки не удались, выбрасывает последнюю ошибку.\n\nfunction auth() {\n  return new Promise((resolve, reject) => {\n    asyncAuth((error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\nasync function tryAuth(n) {\n  let attempts = n + 1; // Первая попытка + n дополнительных\n  let lastError;\n\n  while (attempts > 0) {\n    try {\n      return await auth();\n    } catch (error) {\n      lastError = error;\n      attempts--;\n    }\n  }\n\n  throw lastError; // Если все попытки не удались, выбрасываем последнюю ошибку\n}\n\nРеализовать функцию композиции, которая принимает произвольное количество функций и возвращает новую функцию. Эта новая функция должна применять переданные функции к аргументам в порядке справа налево (как математическая композиция функций).\n\n    function compose(...fns) {\n  return function (...args) {\n    let result = fns[fns.length - 1](...args); // Начинаем с последней функции\n    for (let i = fns.length - 2; i >= 0; i--) {  // Двигаемся в обратном порядке\n      result = fns[i](result);\n    }\n    return result;\n  };\n}\n\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.clear();\nconsole.log(compose(square, times2)(2) === square(times2(2)));  // true\nconsole.log(compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));  // true\nПри последующих вызовах должна возвращатьve, reject) = Функция должна сохранять переданные аргументы при первом вызове.\nfunction runOnce(fn) {\n  let called = false;  // Флаг, чтобы отслеживать, был ли вызов\n  return function(...args) {\n    if (called) {\n      return undefined;  // Возвращаем undefined, если функция уже вызвана\n    }\n    called = true;  // Отмечаем, что функция вызвана\n    return fn(...args);  // Вызываем переданную функцию с аргументами\n  };\n}"
      },
      {
        "timestamp": "2025-03-12 19:56:50",
        "content": "2025-03-12 19:56:50\n Лёша -> 2071074234:\nКомпания Яндекс 2 этап\nЗП: просил 300\nВакансия: hr написала, яндекс вертикали\n\nЗадача 1\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов \nв порядке следования по маршруту. Начало марш...",
        "full_content": "2025-03-12 19:56:50\n Лёша -> 2071074234:\nКомпания Яндекс 2 этап\nЗП: просил 300\nВакансия: hr написала, яндекс вертикали\n\nЗадача 1\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов \nв порядке следования по маршруту. Начало маршрута известно.\n*/\n\nfunction getRoute(tickets = [], start) {\n    // your code here\n}\n\nconsole.clear()\nconsole.log(getRoute([\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n], 'NY')) /*[\n    { from: 'NY', to: 'London' },\n    { from: 'London', to: 'Moscow' },\n    { from: 'Moscow', to: 'SPb' }\n]*/\n\nРешение:\nfunction getRoute(tickets = [], start) {\n  // Создаем объект, где ключи - пункты отправления, а значения - пункты назначения\n  const routeMap = {};\n  \n  // Заполняем карту маршрутов\n  tickets.forEach(ticket => {\n    routeMap[ticket.from] = ticket.to;\n  });\n  \n  // Строим маршрут\n  const route = [];\n  let currentCity = start;\n  \n  // Проходим по маршруту, добавляя билеты в результат\n  while (currentCity && routeMap[currentCity]) {\n    route.push({\n      from: currentCity,\n      to: routeMap[currentCity]\n    });\n    \n    currentCity = routeMap[currentCity];\n  }\n  \n  return route;\n}\n\nЗадача 2\n/*\nДан массив ссылок: ['url1', 'url2', ...] и лимит одновременных запросов (limit)\nНеобходимо реализовать функцию, которая опросит урлы в том порядке, в котором они идут в массиве, и вызовет callback с массивом ответов\n['url1_answer', 'url2_answer', ...] так, чтобы в любой момент времени выполнялось не более limit \nзапросов (как только любой из них завершился, сразу же отправляется следующий)\nТ.е. нужно реализовать шину с шириной равной limit.\n\nТребования:\n\n- Порядок в массиве ответов должен совпадать с порядком в массиве ссылок\n\nДополнительно:\n- Функция должна обладать мемоизацией (один и тот же урл не опрашивать дважды)\n\nДля опроса можно использовать fetch\nОшибки обрабатывать не нужно\n*/\n\n// declare function fetch(url: string): Promise<string>;\n\nfunction parallelLimit(urls, limit, callback) {\n    // code here\n}\n\n\nРешение:\nfunction par(urls, limit, callback) {\n  const results = new Array(urls.length);\n  let count = 0;\n  const cache = new Map();\n\n  async function fn(index) {\n    if(index >= urls.length) {\n      return\n    }\n\n    let resp;\n\n    if(cache.has(urls[index])) {\n        resp = cache.get(urls[index])\n    } else {\n      resp = await urls[index];\n      cache.set(urls[index], resp);\n    }\n\n    results[index] = resp;\n    count++;\n\n    if(count === urls.length) {\n      callback(results)\n    } else {\n      fn(index + limit)\n    }\n  }\n\n  for (let i = 0; i < limit; i++) fn(i);\n}\n\nfunction sleep(ms, ...args) {\n  return new Promise((res) => setTimeout(res, ms, ...args))\n}\n\nconst arr = [sleep(1500, 1), sleep(1000, 2), sleep(1000, 1), sleep(3000, 3), sleep(500, 5), sleep(500, 3)];\npar(arr, 2, console.log);"
      },
      {
        "timestamp": "2025-03-12 18:12:37",
        "content": "2025-03-12 18:12:37\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали); 3 этап\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\n1. Блок: Опыт и текущая работа\n\n👨‍💻 Расскажи о себе\nЧем занимаешься сейчас? Что за проекты? Какой стек?\n\n👥 Про команду\nСколько человек в команде? Кто кроме фронтенда (бек, тестировщики, менеджеры)?\n\n📝 Как задачи попадают к вам?\nКто их декомпозирует — ты или продакт?\n\n💬 Как часто общаешься с бекендерами/дизайнерами?\nЕсть ли регулярные мити...",
        "full_content": "2025-03-12 18:12:37\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали); 3 этап\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\n1. Блок: Опыт и текущая работа\n\n👨‍💻 Расскажи о себе\nЧем занимаешься сейчас? Что за проекты? Какой стек?\n\n👥 Про команду\nСколько человек в команде? Кто кроме фронтенда (бек, тестировщики, менеджеры)?\n\n📝 Как задачи попадают к вам?\nКто их декомпозирует — ты или продакт?\n\n💬 Как часто общаешься с бекендерами/дизайнерами?\nЕсть ли регулярные митинги?\n\n2. Блок: Технические проекты\n\n🖥 Про UIKit\nЗачем создавали свой UIKit? Какие проблемы решали (дублирование кода, консистентность)?\n\n🚀 Как публиковали компоненты в npm?\nРасскажи про процесс: версионирование, приватный реестр, монорепо.\n\n⚙️ Почему выбрали Lerna + npm, а не другие тулзы?\n\n📦 Как делили компоненты на отдельные пакеты?\nНапример, кнопка — отдельный пакет?\n\n🔧 С какими косяками столкнулись при настройке монорепо?\nБаги с зависимостями?\n\n🧪 Интеграция и тесты\nКак убедили команду использовать ваш UIKit? Пришлось ли переписывать старый код?\n\n🔄 Как проходил процесс перехода на UI Kit?\n\n📝 Какие тесты писали для компонентов?\nЮниты, скриншотные?\n\n3. Блок: npm и инфраструктура\n\n🔐 npm-специфика\nКак настроен ваш приватный npm-реестр? Это облачное решение (GitHub Packages) или самописное?\n\n⚙️ CI/CD и Docker\nКакие шаги в GitHub Actions настраивали? Линтеры, сборку, публикацию в реестр?\n\n🧪 Как тестировали пакеты перед публикацией?\nЗапускали линтеры/юнит-тесты в CI?\n\n4. Блок: Проблемы и решения\n\n🐞 Баги и костыли\n\n📉 Оптимизация\nКак снижали TTFB (Time to First Byte) для страниц? CDN, кэширование, пререндер?\n\n⚡️ Что делал, если страница тормозила из-за скролла?\nКак искал узкие места (Chrome DevTools, Lighthouse)?\n\n5. Блок: Софт-скиллы и процессы\n\n🗣 Коммуникация\nКак решал споры с бекендерами? Например, если они не успевали отдать API.\n\n🎤 Как презентовал UIKit команде?\nПроводил ли демо или писал документацию?\n\n🧑‍🏫 Менторство\nПомогал ли новичкам? Как обучал их работать с монорепо и npm-пакетами?\n\n📚 Какую доку для онбординга писал?\nПример: как запустить проект, как публиковать пакеты.\n\n6. Блок: Детали\n\n🧪 Про Cypress и тесты\nПочему выбрали Cypress, а не Playwright? Что понравилось/не понравилось?\n\n🔧 Как настраивали моки для API в тестах?\nДописывали ли кастомные команды?\n\n🛠 Костыли в сборке\nТы говорил, что правили конфиг вебпака для Cypress. Зачем? Какой баг фиксили?\n\n📄 Как делили общие конфиги между проектами?\nНапример, Babel или ESLint-настройки."
      },
      {
        "timestamp": "2025-03-07 09:57:47",
        "content": "2025-03-07 09:57:47\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали); 2 этап\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗапись: писалась, но потом до залива я решил себе поставить параллельно с виндой линукс, что было не самым удачным решением. По итогу, пришлось форматировать весь диск, поэтому записи нет\n\n🖥 Задачи:",
        "full_content": "2025-03-07 09:57:47\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали); 2 этап\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗапись: писалась, но потом до залива я решил себе поставить параллельно с виндой линукс, что было не самым удачным решением. По итогу, пришлось форматировать весь диск, поэтому записи нет\n\n🖥 Задачи:"
      },
      {
        "timestamp": "2025-03-06 16:02:13",
        "content": "2025-03-06 16:02:13\n Pavlov Alekseyi -> 2071074234:\nКомпания яндекс 2 этап\n\nПервая задача\n\nНужно вывести структуру разделов:\n\n\nfunction printDirectoryStructure(data) {\n    // Code hera\n}\n\nprintDirectoryStructure({\n    name: 'Home',\n    children: [\n        {\n            name: 'Dir 1',\n        },\n        {\n            name: 'Dir 2',\n            children: [\n                {\n                    name: 'Dir 2 1',\n                }, {\n                    name: 'Dir 2 2',\n                    children: ...",
        "full_content": "2025-03-06 16:02:13\n Pavlov Alekseyi -> 2071074234:\nКомпания яндекс 2 этап\n\nПервая задача\n\nНужно вывести структуру разделов:\n\n\nfunction printDirectoryStructure(data) {\n    // Code hera\n}\n\nprintDirectoryStructure({\n    name: 'Home',\n    children: [\n        {\n            name: 'Dir 1',\n        },\n        {\n            name: 'Dir 2',\n            children: [\n                {\n                    name: 'Dir 2 1',\n                }, {\n                    name: 'Dir 2 2',\n                    children: [ {\n                        name: 'Dir 3 1',\n                    } ]\n                }, {\n                    name: 'Dir 2 3',\n                }\n            ]\n        },\n        {\n            name: 'Dir 3',\n        }\n    ]\n})\n\n\n\nHome\n    Dir 1\n    Dir 2\n        Dir 2 1\n        Dir 2 2\n            Dir 3 1\n        Dir 2 3\n    Dir 3\n\n\nРешение:\n\n\nfunction printDirectoryStructure(data) {\n    const stack = [ {\n        data: data,\n        level: 0\n    } ]\n\n    while (stack.length > 0) {\n        const pop = stack.pop()\n\n        console.log(' '.repeat(pop.level) + pop.data.name)\n\n        const children = pop.data.children\n\n        if (Array.isArray(children) && children.length > 0) {\n            for (let i = children.length - 1; i >= 0; i--) {\n                stack.push({\n                    data: children[i],\n                    level: pop.level + 1,\n                })\n            }\n        }\n    }\n}\n\n\n2 задача:\n\nПриходят сообщения в не известном порядке\n\n\ntype Message {\n    id: number;\n    message: string;\n}\n\n\nПорядок начинается с id = 1, но прийти может сообщение с любым id. Нужно выводить их по порядку.\n\n\nfunction solution(connect, render) {\n     connect((message) => {\n        // Code hera\n     })\n}\n\nfunction connect(callback) {\n    setTimeout(() => {\n        callback({\n            id: 2,\n            message: 'Message 2'\n        })\n    }, 1000)\n\n    setTimeout(() => {\n        callback({\n            id: 1,\n            message: 'Message 1'\n        })\n    }, 1500)\n\n    setTimeout(() => {\n        callback({\n            id: 4,\n            message: 'Message 4'\n        })\n    }, 2000)\n\n    setTimeout(() => {\n        callback({\n            id: 3,\n            message: 'Message 3'\n        })\n    }, 2250)\n\n    setTimeout(() => {\n        callback({\n            id: 5,\n            message: 'Message 5'\n        })\n    }, 3000)\n}\n\nfunction render(message) {\n    console.log(message.message)\n}\n\nsolution(connect, render)\n\n\nРешение:\n\n\nfunction solution(connect, render) {\n    let lastId = 1\n    const messages = new Map()\n\n    connect((message) => {\n        messages.set(message.id, message)\n\n        while (messages.has(lastId)) {\n            render(messages.get(lastId))\n            messages.delete(lastId)\n            lastId++\n        }\n    })\n}\n\n\nТретья задача.\nСо структурой counter подсказал что можно сделать через массив и я переписал с JSON.stringify на массивы\n\n// Дан массив целых неотрицательных чисел, нужно сгруппировать друг с другом числа,\n// которые можно получить путём перестановки цифр их составляющих,\n// нули при этом игнорируем, т. к. нет числа 011.\n// Решение должно быть максимально эффективно по памяти и времени.\n\n// Нельзя через sort отсортировать числа и сделать ключем, надо было через другую структуру {[число]:[количество чисел в номере]}\n\n\nfunction digitPermutation(arr) {\n\n}\n\nconsole.clear()\nconsole.log('start test')\nconsole.log(digitPermutation([ 1230, 99, 23001, 123, 111, 300021, 101010, 90000009, 9 ]))\n// [[99, 90000009], [111, 101010], [1230, 23001, 123, 300021], [9]]\nconsole.log(digitPermutation([ 11, 22 ])) // [[11], [22]]\nconsole.log(digitPermutation([ 111111111112, 122222222222 ])) // [[111111111112], [122222222222]]\nconsole.log('end test')"
      },
      {
        "timestamp": "2025-03-05 15:50:08",
        "content": "2025-03-05 15:50:08\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап знакмоство с командой\nЗП: -\nВакансия: сами написали",
        "full_content": "2025-03-05 15:50:08\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап знакмоство с командой\nЗП: -\nВакансия: сами написали"
      },
      {
        "timestamp": "2025-03-02 20:20:53",
        "content": "2025-03-02 20:20:53\n Артем -> 2071074234:\nКомпания: Яндекс\n\nЗадачи: \n\n1. Реализовать функцию sleep, чтобы выполнение откладывалось на то время что мы передаем в slepp\nfunction sleep(duration) {\n    // Возвращаем новый промис\n    return new Promise((resolve) => {\n        // Используем setTimeout для задержки\n        setTimeout(() => {\n            // После завершения задержки, вызываем resolve промиса\n            resolve();\n        }, duration);\n    });\n}\n\n2. Реализовать в прототипи массива функию...",
        "full_content": "2025-03-02 20:20:53\n Артем -> 2071074234:\nКомпания: Яндекс\n\nЗадачи: \n\n1. Реализовать функцию sleep, чтобы выполнение откладывалось на то время что мы передаем в slepp\nfunction sleep(duration) {\n    // Возвращаем новый промис\n    return new Promise((resolve) => {\n        // Используем setTimeout для задержки\n        setTimeout(() => {\n            // После завершения задержки, вызываем resolve промиса\n            resolve();\n        }, duration);\n    });\n}\n\n2. Реализовать в прототипи массива функию groupBy \nArray.prototype.groupBy = function(fn) {\n    return this.reduce((acc, item) => {\n        const key = fn(item);\n        if (!acc[key]) {\n            acc[key] = [];\n        }\n        acc[key].push(item);\n        return acc;\n    }, {});\n};\n\n3 Реализовать Promise.any\n\n\nfunction any(promises) {\n    // Массив для хранения ошибок\n    const errors = [];\n    \n    return new Promise((resolve, reject) => {\n        // Переменная для подсчета завершенных промисов\n        let completedPromises = 0;\n\n        // Проходим по каждому промису\n        for (const promise of promises) {\n            // Используем метод Promise.resolve, чтобы работать с обычными значениями и промисами\n            Promise.resolve(promise)\n                .then(resolve) // Если промис успешен, разрешаем главный промис\n                .catch(error => {\n                    // Если промис отклонен, добавляем ошибку в массив и увеличиваем счетчик\n                    errors.push(error);\n                    completedPromises++;\n\n                    // Проверяем, были ли завершены все промисы\n                    if (completedPromises === promises.length) {\n                        // Если все промисы отклонены, реджектим с AggregateError\n                        reject(new AggregateError(errors, 'No Promise in any was resolved'));\n                    }\n                });\n        }\n    });\n}\n\n\n4 Реализовать функцию в который передаем массив массивов и нужно ссумировать все значения\n\nfunction flattenSum(arr) {\n    let sum = 0\n\n    for (const num of arr) {\n        if (Array.isArray(num)) {\n            sum += flattenSum(num)\n        } else {\n            sum += parseInt(num)\n        }\n    }\n\n    return sum\n}"
      },
      {
        "timestamp": "2025-03-02 17:14:36",
        "content": "2025-03-02 17:14:36\n Лёша -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали)\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗадачи:\n1) Написать функцию которая вызывается только один раз. Функция должна принимать аргументы.\nfunction runOnce(fn) {\n   //Code here\n}\n\nfunction logHello = () => {\n    console.log('hello!')\n}\n\nconst logHelloOnce = runOnce(logHello)\nconsole.clear();\nlogHelloOnce(); // 'hello!'\nlogHelloOnce(); // undefined\nРешение:\nfunction runOnce(tm) {\n  let call...",
        "full_content": "2025-03-02 17:14:36\n Лёша -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали)\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗадачи:\n1) Написать функцию которая вызывается только один раз. Функция должна принимать аргументы.\nfunction runOnce(fn) {\n   //Code here\n}\n\nfunction logHello = () => {\n    console.log('hello!')\n}\n\nconst logHelloOnce = runOnce(logHello)\nconsole.clear();\nlogHelloOnce(); // 'hello!'\nlogHelloOnce(); // undefined\nРешение:\nfunction runOnce(tm) {\n  let called = false;\n\n  return function(...args) {\n    if (called) return undefined;\n    called = true;\n    return tm.apply(this, args);\n  };\n}\n\n2) Написать асинхронную функцию, которая будет спать заданное количество милисекунд  и потом успешно завершаться.\nfunction sleep(){}\n\n// Пример\nconst startTime = Date.now();\nconsole.log('Starting sleeping...');\nsleep(2000).then(() => {\nconsole.log('Wake up after 2 seconds!');\nconsole.log('Time passed: ', Date.now() - startTime);\n});\n\nsleep(1000).then(() => {\nconsole.log('Wake up after 3 seconds!');\nconsole.log('Time passed: ', Date.now() - startTime);\n});\n\nРешение:\nfunction sleep(duration) {\n    return new Promise(resolve => setTimeout(resolve, duration));\n}\nВопросы к этой задаче:\nПочему 2 слип завершился раньше?\n- Наш слип асинхронный, 1 секунда проходит быстрее чем 2.\nПочему в консоле выводиться 'Time passed: 1005' а не 1000?\n- SetTimeout гарантирует, что пройдет минимум заданное количество милисекунд, но тк браузер занят другими задачами, то SetTimeout может и завершиться позже.\n\n3)\n/*\nНужно написать полифил для Array.prototype.some\n\nПараметры:\n- callback – функция проверки каждого элемента, принимает три аргумента:\n  - element – текущий обрабатываемый элемент массива.\n  - index (необязательный) – индекс текущего обрабатываемого элемента массива.\n  - array (необязательный) – массив, по которому осуществляется проход.\n  - thisArg (необязательный) – значение, используемое в качестве this при выполнении функции callback.\n\nВозвращаемое значение:\ntrue, если функция проверки возвращает truthy значение хотя бы для одного элемента массива. Иначе false.\n*/\n\nArray.prototype.some =\n\nРешение:\n  Array.prototype.some = function(callback, thisArg) {\n    if (this == null) {\n      throw new TypeError('Array.prototype.some called on null or undefined');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback + ' is not a function');\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (callback.call(thisArg, this[i], i, O)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n4)\n/*\nНапишите функцию any, которая бы работала, как Promise.any().\n\n- Принимает массив промисов (значений, не опуская), и возвращает промис.\n- Если хоть один из переданных промисов резолвится (успешно выполняется), то возвращённый промис резолвится с этим значением.\n- Если все переданные промисы реджектятся, то возвращённый промис реджектится с ошибкой AggregateError, в которой сгруппированы все ошибки.\n\nAggregateError можно создать таким образом:\nnew AggregateError(errors, 'No Promise in any was resolved')\n*/\n\nclass AggregateError extends Error {\n    constructor(errors, message) {\n        super(message);\n        this.errors = errors;\n        this.name = \"AggregateError\";\n    }\n}\n\nfunction any(promises) {\n    // your code here\n}\n\n// Пример использования\nconsole.clear();\n\nconst p1 = Promise.reject(\"Error 3\");\nconst p2 = Promise.reject(\"Error 1\");\nconst p3 = Promise.resolve(3);\n\nany([p1, p2, p3]).then(console.log); // 3"
      },
      {
        "timestamp": "2025-02-28 17:19:13",
        "content": "2025-02-28 17:19:13\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап (знакомство с командой)\nВакансия: сами написали",
        "full_content": "2025-02-28 17:19:13\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап (знакомство с командой)\nВакансия: сами написали"
      },
      {
        "timestamp": "2025-02-28 16:10:51",
        "content": "2025-02-28 16:10:51\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап\nВакансия: хр написал",
        "full_content": "2025-02-28 16:10:51\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 4 этап\nВакансия: хр написал"
      },
      {
        "timestamp": "2025-02-26 15:07:56",
        "content": "2025-02-26 15:07:56\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 3 этап\nВакансия: сами написали через хх",
        "full_content": "2025-02-26 15:07:56\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 3 этап\nВакансия: сами написали через хх"
      },
      {
        "timestamp": "2025-02-26 14:26:04",
        "content": "2025-02-26 14:26:04\n Pavlov Alekseyi -> 2071074234:\nКомпания: Яндекс (первый этап)\n\nБыли только задачи, экран не шарил, немного помогали.\n\n\n1. Что выведет в консоль и почему?\n\nПервая задача\n\nvar n = 5\n\nfunction fn(n) {\n    n = 10\n}\n\nfn(n)\nconsole.log(n) //???\n\nОтвет: 5\n\nВторая задача\n\nvar obj = { a : 1}\n\nfunction fn(obj) {\n    obj = { c : 5}\n}\n\nfn(obj)\nconsole.log(obj) //???\n\nОтвет: { a : 1}\n\nТретья задача\n\nvar obj = { a : 5}\n\nfunction fn(obj) {\n    obj.c = 10\n}\n\nfn(obj)\nconsole.log(obj) //???\n\n...",
        "full_content": "2025-02-26 14:26:04\n Pavlov Alekseyi -> 2071074234:\nКомпания: Яндекс (первый этап)\n\nБыли только задачи, экран не шарил, немного помогали.\n\n\n1. Что выведет в консоль и почему?\n\nПервая задача\n\nvar n = 5\n\nfunction fn(n) {\n    n = 10\n}\n\nfn(n)\nconsole.log(n) //???\n\nОтвет: 5\n\nВторая задача\n\nvar obj = { a : 1}\n\nfunction fn(obj) {\n    obj = { c : 5}\n}\n\nfn(obj)\nconsole.log(obj) //???\n\nОтвет: { a : 1}\n\nТретья задача\n\nvar obj = { a : 5}\n\nfunction fn(obj) {\n    obj.c = 10\n}\n\nfn(obj)\nconsole.log(obj) //???\n\nОтвет: { a : 5, c : 10 }\n\n2. onceFn — Написать функцию которая вызывается только один раз\n\n\nfunction onceFn(fn) {\n   //Code here\n}\n\nfunction log(value) {\n    console.log(value)\n}\n\nconst onceLog = onceFn(log)\n\nonceLog('1') // Выведет 1\nonceLog('2') // Вернёт undefined\nonceLog('3') // Вернёт undefined\n\nconst onceLog2 = onceFn(log)\nonceLog2('4') // Выведет 4\nonceLog2('5') // Вернёт undefined\nonceLog2('6') // Вернёт undefined\n\n\nРешение:\n\nfunction onceFn(fn) {\n    let isCall = false\n\n    return (...args) => {\n        if (!isCall) {\n            isCall = true\n            return fn(...args)\n        }\n    };\n}\n\n//P.S.(можно сделать с привязкой контекста):\n\n\n3. Написать полифил для groupBy у массивов\nArray.prototype.groupBy\n\nРешение:\n\nArray.prototype.groupBy = function (callback) {\n    const result = {}\n\n    for (let i = 0; i < this.length; i++) {\n        const key = callback(this[i])\n\n        if (!result[key]) result[key] = []\n\n        result[key].push(this[i])\n    }\n\n    return result\n}\n\nconst arr = [ 1, 2, 3, 4, 5 ]\nconst grouped = arr.groupBy((num) => num % 2 === 0 ? 'even' : 'odd')\n\nconsole.log(grouped)\n\n// P.S. Можно написать более продвинутое решение с дополнительными проверками и передачей доп. аргументов в callback\n\n\n4. Функция Auth должная вернуть промис после выполнения callback в asyncAuth c error (rejected) либо data (fullfiled)\n\n\nimport asyncAuth from 'lib/auth'\n\nfunction Auth() {\n    asyncAuth((error, data) => {\n        //Code here\n    })\n}\n\n\nРешение:\n\nfunction Auth() {\n    return new Promise((resolve, reject) => {\n        asyncAuth((error, data) => {\n            if (error) {\n                reject(error);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n\n5. Задача немного связанная с предыдущей Auth.\nРеализовать функцию которая будет вызывать попытки авторизации\n\nРешение:\n\nfunction auth(count = 5) {\n    return new Promise(() => {\n        function tryAuth(count) {\n            Auth.then((value) => {\n                resolve(value)\n            }).catch((error) => {\n                if (count === 0) {\n                    reject(error)\n                } else {\n                    tryAuth(url, count - 1)\n                }\n            })\n        }\n\n        tryAuth(5)\n    })\n}\n\n\n6. Сложить числа из массива\nДан массив [1, [2, '2x', 3], ['5', ['x7', ['6', '4']]]]\nНужно сложить все числа массива.\nЕсли попадается число на подобии '2x' считать его как 2\nЕсли 'x7', то игнорировать\nP.S. Методы flat и flatMap нельзя использовать\n\nРешение 1 (постое, думаю бы приняли его):\n\nfunction flattenSum(arr) {\n    let sum = 0\n\n    for (let i = 0; i < arr.length; i++) {\n        const el = arr[i]\n\n        if (Array.isArray(el)) {\n            sum += flattenSum(el)\n        } else {\n            sum += parseFloat(el) || 0\n        }\n    }\n\n    return sum\n}\n\n\nРешение более сложное (написал его):\n\nfunction helper(num) {\n    return parseFloat(num) || 0\n}\n\nfunction flattenSum(arr) {\n    const stack = [ arr ]\n    let sum = 0\n\n    while (stack.length > 0) {\n        const pop = stack.pop()\n\n        if (Array.isArray(pop)) {\n            stack.push(...pop)\n        } else {\n            sum += helper(pop)\n        }\n    }\n\n    return sum\n}\n\nconsole.log(flattenSum([ 1, [ 2, '2x', 3 ], [ '5', [ 'x7', [ '6', '4' ] ] ] ]))\n\n\n7. Задача MaxStack — это классическая задача, которая требует реализации структуры данных, похожей на стек, но с дополнительной функциональностью: она должна поддерживать не только стандартные операции стека (push, pop), но и операцию быстрого получения максимального элемента в стеке."
      },
      {
        "timestamp": "2025-02-25 17:36:13",
        "content": "2025-02-25 17:36:13\n Никита -> 2071074234:\nКомпания: Яндекс 2 этап\nЗП: 350к+\nЗадачи:\n\nfunction flatten(array) {\n  const stack = [...array]; // Инициализируем стек с элементами исходного массива\n  const result = []; // Массив для хранения результата\n\n  while (stack.length) {\n    const current = stack.pop(); // Извлекаем последний элемент из стека\n\n    if (Array.isArray(current)) {\n      // Если элемент является массивом, добавляем его элементы в стек\n      for (let i = current.length - 1; i >= 0;...",
        "full_content": "2025-02-25 17:36:13\n Никита -> 2071074234:\nКомпания: Яндекс 2 этап\nЗП: 350к+\nЗадачи:\n\nfunction flatten(array) {\n  const stack = [...array]; // Инициализируем стек с элементами исходного массива\n  const result = []; // Массив для хранения результата\n\n  while (stack.length) {\n    const current = stack.pop(); // Извлекаем последний элемент из стека\n\n    if (Array.isArray(current)) {\n      // Если элемент является массивом, добавляем его элементы в стек\n      for (let i = current.length - 1; i >= 0; i--) {\n        stack.push(current[i]);\n      }\n    } else {\n      // Если элемент не является массивом, добавляем его в результат\n      result.push(current);\n    }\n  }\n\n  return result.reverse(); // Возвращаем результат, развернутый в правильном порядке\n}\n\n// Пример использования\nconsole.log(flatten([0, [1, [2, 3]], 4])); // [0, 1, 2, 3, 4]\nconsole.log(flatten([1, [2, [3, [4, [5]]]])); // [1, 2, 3, 4, 5]\nconsole.log(flatten([1, 2, [3, 4], 5, [6, [7, 8]]])); // [1, 2, 3,\n\n2.\n\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту.\n*/\n\nfunction getRoute(tickets = []) {\n  // TODO\n  const set = new Set();\n\n  const result = [];\n  const map = new Map();\n\n  tickets.forEach((item) => {\n    if (!set.has(item.from)) set.add(item.from);\n    map.set(item.from, item);\n  });\n\n  tickets.forEach((item) => {\n    if (set.has(item.to)) set.delete(item.to);\n  });\n\n\n  let i = 0;\n  let current = [...set][0];\n\n  while (i < map.size) {\n    const cur = map.get(current);\n    result.push(cur);\n    current = cur.to;\n    i++;\n  }\n\n  return result;\n}"
      },
      {
        "timestamp": "2025-02-22 06:25:16",
        "content": "2025-02-22 06:25:16\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 2 этап\nВакансия: сами написали\nЗП: не обговаривали\nЗадачи: две задачи сразу с решением, никто не копировал, так что описание задачи нет\nfunction solution(connect, render) {\n    let lastId = 1;\n    const map = new Map();\n    \n    connect(({id, text}) => {\n        if(lastId === id) {\n            render({id, text});\n            lastId++;\n            \n            while(true) {\n                const nextMessage = map.get(lastId);\n...",
        "full_content": "2025-02-22 06:25:16\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 2 этап\nВакансия: сами написали\nЗП: не обговаривали\nЗадачи: две задачи сразу с решением, никто не копировал, так что описание задачи нет\nfunction solution(connect, render) {\n    let lastId = 1;\n    const map = new Map();\n    \n    connect(({id, text}) => {\n        if(lastId === id) {\n            render({id, text});\n            lastId++;\n            \n            while(true) {\n                const nextMessage = map.get(lastId);\n                if(!nextMessage) break;\n                \n                render(nextMessage);\n                map.delete(lastId);\n                lastId++;\n            }\n        } else {\n            map.set(id, {id, text});\n        }\n    });\n}\nfunction printDirectoryStructure(data) {\n    const stack = [{ item: data, level: 0 }];\n    \n    while (stack.length > 0) {\n        const { item, level } = stack.pop();\n        \n        // Print current item with proper indentation\n        console.log('  '.repeat(level) + item.name);\n        \n        // If the item has children, add them to stack in reverse order\n        // to maintain correct output order (since we're using stack)\n        if (item.children) {\n            for (let i = item.children.length - 1; i >= 0; i--) {\n                stack.push({\n                    item: item.children[i],\n                    level: level + 1\n                });\n            }\n        }\n    }\n}"
      },
      {
        "timestamp": "2025-02-22 01:28:18",
        "content": "2025-02-22 01:28:18\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали)\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗадачи:\n\n📌1. \nУ нас есть строка. Надо написать функцию, которая будет принимать delimiter первым аргументом, а потом просто по буквам. Нужно за'join'ить\n\nВыглядеть должно как-то так:\n\nstrjoin(\"-\", \"a\", \"b\", \"c\")  //  \"a-b-c\"\nstrjoin(\":\", \"hello\", \"world\")  //  \"hello:world\"\n\nP.S. можно использовать join:\nconst strjoin = (delimiter, ...args) => ar...",
        "full_content": "2025-02-22 01:28:18\n Aintripin -> 2071074234:\nКомпания: Яндекс (Яндекс.Вертикали)\nВакансия: frontend-разработчик; hr написала сама\nЗП: не обговаривали\n\nЗадачи:\n\n📌1. \nУ нас есть строка. Надо написать функцию, которая будет принимать delimiter первым аргументом, а потом просто по буквам. Нужно за'join'ить\n\nВыглядеть должно как-то так:\n\nstrjoin(\"-\", \"a\", \"b\", \"c\")  //  \"a-b-c\"\nstrjoin(\":\", \"hello\", \"world\")  //  \"hello:world\"\n\nP.S. можно использовать join:\nconst strjoin = (delimiter, ...args) => args.join(delimiter);\n\nПрост потом попросит через синтаксис ES5\n\nfunction strjoin(divider) {\n    var args = Array.prototype.slice.apply(arguments, [1]);\n    return args.join(divider);\n}\n\n📌2. \nПромисы, что выведется в консоль:\nPromise.resolve(1)\n    .then(x => x + 1)       // (1) 1 + 1 = 2\n    .then(x => { throw x }) // (2) Ошибка: выбрасываем 2\n    .then(x => console.log(x)) // (3) Пропускается из-за ошибки\n    .catch(err => console.log(err)) // (4) Ловим ошибку (выведет 2)\n    .then(x => Promise.resolve(x)) // (5) x здесь `undefined`\n    .catch(err => console.log(err)) // (6) Пропускается, так как нет ошибки\n    .then(x => console.log(x)); // (7) Выведет `undefined`\n\n📌3.\nНаписать функцию. Функция у нас принимает URL и продолжает пытаться за'fetch'ить дату из данного URL, но делает это максимум 5 раз (задаём ограничение)\nfunction get(url) {\n    const maxRetries = 5;\n\n    function fetchWithRetry(url, retries) {\n        return fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error('Network response was not ok');\n                }\n                return response.json();\n            })\n            .catch(error => {\n                if (retries > 0) {\n                    return fetchWithRetry(url, retries - 1);\n                } else {\n                    throw new Error(\"Заданный URL недоступен\");\n                }\n            });\n    }\n\n    return new Promise((resolve, reject) => {\n        fetchWithRetry(url, maxRetries)\n            .then(data => resolve(data))\n            .catch(error => reject(error));\n    });\n}\n\n// Example usage:\nget('https://example.com/api/data')\n    .then(res => console.log(res))\n    .catch(err => console.error(err));\n\n📌 4. \nДаны два отсортированных списка с интервалами присутствия пользователей в онлайне в течение дня. Начало интервала строго меньше конца. Нужно вычислить интервалы, когда оба пользователя были в онлайне. Интервалы указаны в часах; считаем, что могут быть часы от 0 до 24\n\nПример #1:\nintersection(\n    [[8, 12], [17, 22]],\n    [[5, 11], [14, 18], [20, 23]]\n)\n\nДолжно вывести:\n\n[[8, 11], [17, 18], [20, 22]]\n\nПример #2:\nintersection(\n    [[9, 15], [18, 21]],\n    [[10, 14], [21, 22]]\n)\n\nДолжно вывести:\n[[10, 14]]\n\nboilerplate:\nfunction intersection(user1, user2) {\n    // your code here\n}\n\nРешение:\nfunction intersection(user1, user2) {\n    let result = [];\n    let i = 0, j = 0;\n\n    while (i < user1.length && j < user2.length) {\n        let start = Math.max(user1[i][0], user2[j][0]);\n        let end = Math.min(user1[i][1], user2[j][1]);\n\n        if (start < end) {\n            result.push([start, end]);\n        }\n\n        // Move the pointer of the interval that ends first\n        if (user1[i][1] < user2[j][1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n\n    return result;\n}"
      },
      {
        "timestamp": "2025-02-17 14:43:05",
        "content": "2025-02-17 14:43:05\n Никита -> 2071074234:\n1. Яндекс 1 этап\n2. Написал hr\n3. Зп 350К+\n\nВопрос: Что такое Promise?\n\nЗадачи:\n1. Что выведет в консоль?\n\n\nPromise.resolve(1)\n  .then(x => x + 1)       // (1) 1 + 1 = 2\n  .then(x => { throw x }) // (2) Ошибка: выбрасываем 2\n  .then(x => console.log(x)) // (3) Пропускается из-за ошибки\n  .catch(err => console.log(err)) // (4) Ловим ошибку (выведет 2)\n  .then(x => Promise.resolve(x)) // (5) x здесь `undefined`\n  .catch(err => console.log(err)) // (6) Про...",
        "full_content": "2025-02-17 14:43:05\n Никита -> 2071074234:\n1. Яндекс 1 этап\n2. Написал hr\n3. Зп 350К+\n\nВопрос: Что такое Promise?\n\nЗадачи:\n1. Что выведет в консоль?\n\n\nPromise.resolve(1)\n  .then(x => x + 1)       // (1) 1 + 1 = 2\n  .then(x => { throw x }) // (2) Ошибка: выбрасываем 2\n  .then(x => console.log(x)) // (3) Пропускается из-за ошибки\n  .catch(err => console.log(err)) // (4) Ловим ошибку (выведет 2)\n  .then(x => Promise.resolve(x)) // (5) x здесь `undefined`\n  .catch(err => console.log(err)) // (6) Пропускается, так как нет ошибки\n  .then(x => console.log(x)); // (7) Выведет `undefined\n\n2. Написать функцию, которая принимает другую функцию и вызывает ее 1 раз\n\n\n\nfunction logger(fn) {\n  let isCalled = false; // Флаг вызова функции\n  let result; // Переменная для хранения результата\n\n  return function (...args) {\n    if (isCalled) return undefined; // Если уже вызывали, возвращаем undefined\n    isCalled = true; // Ставим флаг\n    result = fn(...args); // Вызываем функцию и сохраняем результат\n    return result; // Возвращаем результат первого вызова\n  };\n}\n\n// Пример с консольным выводом\nconst logHello = () => {\n  console.log(\"hello!\");\n};\n\nconst logHelloOnce = logger(logHello);\nlogHelloOnce(); // Выведет: \"hello!\"\nlogHelloOnce(); // Вернёт: undefined\nlogHelloOnce(); // Вернёт: undefined\n\n// Пример с возвратом результата\nconst add = (a, b) => a + b;\nconst addOnce = logger(add);\n\nconsole.log(addOnce(2, 3)); // 5\nconsole.log(addOnce(10, 20)); // undefined\n\n3. checkResult(url1, solution) возвращает Promise<boolean>.\nВыполните оба запроса и обработайте их результаты.\n\nЕсли хотя бы один запрос возвращает ошибку, выведите в консоль сообщение 'error'.\nЕсли оба запроса выполняются успешно, но хотя бы один из них возвращает false, выведите сообщение 'fail'.\nЕсли оба запроса выполняются успешно и оба возвращают true, выведите сообщение 'success'.\nЕсли ни один из запросов не завершился за 1000 миллисекунд, выведите 'timeout'.\n\n\n\nimport { checkResult } from \"myLib\"; // возвращает Promise<boolean>\n\nconst solution = \"Any answer\";\nconst url1 = \"yandex.ru\";\nconst url2 = \"google.com\";\n\nconst checkWithTimeout = (url, solution, timeout) =>\n  Promise.race([\n    checkResult(url, solution).catch(() => \"error\"), // Ловим ошибку, но не прерываем выполнение\n    new Promise((_, reject) => setTimeout(() => reject(\"timeout\"), timeout))\n  ]);\n\nconst checkoutTwoService = async (url1, url2, solution) => {\n  const timeout = 1000;\n  try {\n    const result = await Promise.race([\n      Promise.all([checkWithTimeout(url1, solution, timeout), checkWithTimeout(url2, solution, timeout)]),\n      new Promise((_, reject) => setTimeout(() => reject(\"timeout\"), timeout))\n    ]);\n\n    if (result.includes(\"timeout\")) {\n      console.log(\"timeout\");\n    } else if (result.includes(\"error\")) {\n      console.log(\"error\");\n    } else if (result.includes(false)) {\n      console.log(\"fail\");\n    } else {\n      console.log(\"success\");\n    }\n  } catch (err) {\n    console.log(err === \"timeout\" ? \"timeout\" : \"error\");\n  }\n};\n\ncheckoutTwoService(url1, url2, solution);\n\n4. Определить, является ли задача пангромой\n\n\nconst LETTERS = ['A', 'B', 'C' , 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\nconst LETTERS_SET = new Set(LETTERS); // O(1) доступ к буквам\n\nfunction isPangram(text) {\n  const uniqueLetters = new Set(); // O(1) на добавление\n\n  for (const char of text.toUpperCase()) { // O(N)\n    if (LETTERS_SET.has(char)) { // O(1) \n      uniqueLetters.add(char); // O(1)\n      if (uniqueLetters.size === LETTERS.length) return true; // Ранний выход\n    }\n  }\n\n  return false;\n}\n\n\nИли такое нужно было\n\n\nfunction isPangram(text) {\n  const uniqueLetters = new Set(); // O(1) на добавление\n\n  for (const char of text) { // O(N)\n    const upperChar = char.toUpperCase();\n    if (upperChar >= 'A' && upperChar <= 'Z') { // Проверка ASCII-кодов\n      uniqueLetters.add(upperChar);\n      if (uniqueLetters.size === 26) return true; // Ранний выход\n    }\n  }\n\n  return false;\n}"
      },
      {
        "timestamp": "2025-02-11 15:02:55",
        "content": "2025-02-11 15:02:55\n Марк -> 2071074234:\nКомпания: Яндекс\nВакансия: hr написала\nЗП: Просил 320к\nЗапись: Звук собеседующего очень тихий на записи, так что посути звук не записался\nЗадачи:\n// Задача 1. Что выведет в консоль?\nPromise.resolve(1)\n  .then((x) => x + 1)\n  .then((x) => {\n    throw x;\n  })\n  .then((x) => console.log(x))\n  .catch((err) => console.log(err))\n  .then((x) => Promise.resolve(x))\n  .catch((err) => console.log(err))\n  .then((x) => console.log(x));\n\n// Задача 2.\n/*\nНужно реализов...",
        "full_content": "2025-02-11 15:02:55\n Марк -> 2071074234:\nКомпания: Яндекс\nВакансия: hr написала\nЗП: Просил 320к\nЗапись: Звук собеседующего очень тихий на записи, так что посути звук не записался\nЗадачи:\n// Задача 1. Что выведет в консоль?\nPromise.resolve(1)\n  .then((x) => x + 1)\n  .then((x) => {\n    throw x;\n  })\n  .then((x) => console.log(x))\n  .catch((err) => console.log(err))\n  .then((x) => Promise.resolve(x))\n  .catch((err) => console.log(err))\n  .then((x) => console.log(x));\n\n// Задача 2.\n/*\nНужно реализовать функцию-обёртку, которая позволяет вызывать оборачиваемую функцию только один раз.\nЕсли функция вызывается больше одного раза, она всегда возвращает undefined:\n\nconst logHello = () => {\n    console.log('hello!');\n};\n\nconst logHelloOnce = runOnce(logHello);\nlogHelloOnce(); // 'hello!'\nlogHelloOnce(); // undefined\n\nОборачиваемая функция может принимать аргументы и возвращать результат.\n*/\n\nconst logger = (callback) => {\n  let called = false;\n\n  return function (...args) {\n    if (!called) {\n      called = true;\n      return callback(...args);\n    }\n    return undefined;\n  };\n};\n\n// Задача 3. Что выведет в консоль, так же были вопросы, типо а почему так и.т.д, плюс задачу дополняли постоянно\nconst object = {\n  value: \"42\",\n  print() {\n    // Потом просит функцию переделать на стрелочную\n    function type() {\n      return typeof this.value;\n    }\n    // Тут тупо нужно bind вызвать у type и this прибиндить\n    console.log(`${this.value} is ${type()}`);\n  },\n};\n// Спрашивали чему равен контекст в этом случае (объекту слева от точки), так же спрашивали когда присваивается контекст (в момент вызова)\nobject.print(); // 42 is undefined\n\n// Дополнение к этой задаче\nconst test = {\n  value: true,\n};\n\ntest.print = object.print;\ntest.print(); //true is boolean;\n\n// Задача 4. Написать каррирование\n/**\n * Нужно написать каррирование,\n * и предусмотреть что кол-во аргументов может быть неограниченно.\n */\n\nfunction curry(fn) {\n  function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    } else {\n      return function (...nextArgs) {\n        return curried(...args, ...nextArgs);\n      };\n    }\n  }\n\n  return curried;\n}\n\nfunction multiply(a, b, c) {\n  return a * b * c;\n}\n\nconsole.log(curry(multiply)(2, 3, 4)); // 24\nconsole.log(curry(multiply)(2, 3)(4)); // 24\nconsole.log(curry(multiply)(2)(3)(4)); // 24\n\n// Задача 5\n// Необходимо проверить решение задачи по двум сервисам, вызвав checkResult(url1, solution), checkResult(url2, solution)\n// checkResult: (url: string, solution: string | number) => Promise<boolean>;\n//\n// * Если оба запроса вернули true - вывести success\n// * Если хоть один вернул false - вывести fail\n// * Если хоть один не ответил - вывести error\n// * Если хоть один отвечает дольше 1 сек - вывести timeout\n\nimport { checkResult } from \"myLib\";\n\nconst solution = \"Any answer\";\nconst url1 = \"yandex.ru\";\nconst url2 = \"google.com\";\n// Кейс с таймаутом решил декоратором\nfunction withTimeout(promise, ms = 1000) {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(\"timeout\"));\n    }, ms);\n\n    promise.then(\n      (value) => {\n        clearTimeout(timer);\n        resolve(value);\n      },\n      (error) => {\n        clearTimeout(timer);\n        reject(error);\n      },\n    );\n  });\n}\n\nasync function check(url1, url2, solution) {\n  // Запускаем оба вызова checkResult с ограничением в 1 сек:\n  const p1 = withTimeout(checkResult(url1, solution), 1000);\n  const p2 = withTimeout(checkResult(url2, solution), 1000);\n\n  // Ждём, пока оба завершатся — вне зависимости от успеха или ошибки (allSettled).\n  // Результат будет массив объектов вида { status, value?, reason? }\n  const [res1, res2] = await Promise.allSettled([p1, p2]);\n\n  // 2) Проверяем, не было ли других ошибок (rejected не по таймауту):\n  if (res1.status === \"rejected\" || res2.status === \"rejected\") {\n    return \"error\";\n  }\n\n  // 3) Если оба fulfilled, смотрим значения (true / false):\n  //    Если хотя бы одно false, выводим \"fail\"\n  if (!res1.value || !res2.value) {\n    return \"fail\";\n  }\n\n  // 4) Остался случай — оба true:\n  return \"success\";\n}"
      },
      {
        "timestamp": "2025-02-07 18:36:11",
        "content": "2025-02-07 18:36:11\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 1 этап\nВопросы:\nрешить задачу isPangram (leetcode like); попросил решение O(n) с одним циклом, с наиболее ранним выходом из цикла, если уже нашли все необходимые символы во инпут строке\nсделать sleep функцию + уточнение почему и когда может таймаут отрабатывать через большее время, чем задано изначально; объяснение такое, что если основной поток, в котором исполняется ЖС и так уже загружен, например, синхронными задачами или ...",
        "full_content": "2025-02-07 18:36:11\n Klimenty Karavaev -> 2071074234:\nКомпания: Яндекс 1 этап\nВопросы:\nрешить задачу isPangram (leetcode like); попросил решение O(n) с одним циклом, с наиболее ранним выходом из цикла, если уже нашли все необходимые символы во инпут строке\nсделать sleep функцию + уточнение почему и когда может таймаут отрабатывать через большее время, чем задано изначально; объяснение такое, что если основной поток, в котором исполняется ЖС и так уже загружен, например, синхронными задачами или микротасками, то несмотря на то, что таймауту задали например 100 миллисекунд, он может выполнится хоть через 10000, пока исполнение не дойдет до выполнения собсна таймаут коллбэка\nнаписать свой Promise.any\nнаписать полифил для array.prototype.some"
      },
      {
        "timestamp": "2025-02-06 20:59:09",
        "content": "2025-02-06 20:59:09\n Эмир -> 2071074234:\nКомпания: Яндекс\nВакансия: HR сам написал\nВопросы: Не было. Сразу перешли к задачам.\nЗадачи: \n1. Что выведет в консоли?\nvar n = 1;\nfunction f(n) {\n    n = 3;\n}\nf(n);\nconsole.log(n); // Выведет 1\n2. Что выведет в консоли?\nvar obj = { a: 1 };\nfunction f1(o) {\n    o.a = 5;\n}\nf1(obj);\nconsole.log(obj); // Выведет { a: 5 }\n3. Что выведет в консоли?\nvar obj = { a: 1 };\nfunction f2(o) {\n    o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // Выведет { a: 1 }\n4. чт...",
        "full_content": "2025-02-06 20:59:09\n Эмир -> 2071074234:\nКомпания: Яндекс\nВакансия: HR сам написал\nВопросы: Не было. Сразу перешли к задачам.\nЗадачи: \n1. Что выведет в консоли?\nvar n = 1;\nfunction f(n) {\n    n = 3;\n}\nf(n);\nconsole.log(n); // Выведет 1\n2. Что выведет в консоли?\nvar obj = { a: 1 };\nfunction f1(o) {\n    o.a = 5;\n}\nf1(obj);\nconsole.log(obj); // Выведет { a: 5 }\n3. Что выведет в консоли?\nvar obj = { a: 1 };\nfunction f2(o) {\n    o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // Выведет { a: 1 }\n4. что выведет в консоли?\nvar obj = { a: 1 };\nfunction f2(o) {\n    o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // Выведет { a: 1 }\n5. Реализуй функцию strjoin(separator, ...strings), которая объединяет переданные строки с указанным разделителем\nfunction strjoin(separator, ...strings) {\n    return strings.reduce((result, str, index) => \n        index === 0 ? str : result + separator + str, \n    '');\n}\n6. Реализуй функцию callLimit(fn, limit, callback), которая ограничивает количество вызовов переданной функции fn.\nfunction callLimit(fn, limit, callback) {\n    let count = 0;\n    \n    const wrapped = function (...args) {\n        if (count >= limit) {\n            if (callback) {\n                callback();\n            }\n            return; // Прерываем выполнение, если превышен лимит\n        }\n        \n        count++;\n        const result = fn.apply(this, args);\n        \n        if (count === limit && callback) {\n            callback();\n        }\n\n        return result; // Возвращаем результат вызова `fn`\n    };\n\n    wrapped.reset = function () {\n        count = 0;\n        return wrapped;\n    };\n\n    return wrapped;\n}\n\n// Пример использования:\nconst limitedFn = callLimit((x) => x * 2, 3, () => console.log(\"Лимит достигнут\"));\n\nconsole.log(limitedFn(2)); // 4\nconsole.log(limitedFn(3)); // 6\nconsole.log(limitedFn(4)); // 8\nconsole.log(limitedFn(5)); // \"Лимит достигнут\", undefined\nconsole.log(limitedFn(6)); // \"Лимит достигнут\", undefined\n\nlimitedFn.reset();\nconsole.log(limitedFn(2)); // 4 (счётчик сброшен)\n7. Написать функцию get(url), которая выполняет HTTP-запрос по заданному URL с повторными попытками в случае ошибки. Максимальное количество попыток — 5. Если после всех попыток запрос не удался, функция должна вернуть ошибку \"Заданный URL недоступен\".\nfunction get(url) {\n    const MAX_RETRIES = 5; // Максимальное количество попыток\n\n    function fetchWithRetry(attempt) {\n        return fetch(url)\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(`Ошибка HTTP! Статус: ${response.status}`);\n                }\n                return response.json();\n            })\n            .catch(error => {\n                if (attempt >= MAX_RETRIES - 1) {\n                    return Promise.reject(new Error(\"Заданный URL недоступен\"));\n                }\n                \n    }\n\n    return fetchWithRetry(0);\n}"
      },
      {
        "timestamp": "2025-02-06 13:11:38",
        "content": "2025-02-06 13:11:38\n Petr Zabrodniy -> 2071074234:\nКомпания : Яндекс, 2 (второй) этап \nВакансия : рекрутер сам написал \nЗП : не обсуждали \nЗадачи : \n\n1)  atm-machine aka БАНКОМАТ\n\n/**  \n * Банкомат. * * В банкомате есть купюры — 50, 100, 500, 1000, 5000 руб. Номиналы купюр только такие, они не меняются * и доступны в константе nominals. * Есть ограничение на количество каждой из купюр (аргумент limits), его нужно держать в актуальном * состоянии (мутировать). * Нужно вернуть купюры и их количест...",
        "full_content": "2025-02-06 13:11:38\n Petr Zabrodniy -> 2071074234:\nКомпания : Яндекс, 2 (второй) этап \nВакансия : рекрутер сам написал \nЗП : не обсуждали \nЗадачи : \n\n1)  atm-machine aka БАНКОМАТ\n\n/**  \n * Банкомат. * * В банкомате есть купюры — 50, 100, 500, 1000, 5000 руб. Номиналы купюр только такие, они не меняются * и доступны в константе nominals. * Есть ограничение на количество каждой из купюр (аргумент limits), его нужно держать в актуальном * состоянии (мутировать). * Нужно вернуть купюры и их количество, которыми можно выдать запрашиваемую сумму, в виде * объекта в формате, аналогичном объекту лимитов. * При прочих равных возможностях выдать одну и ту же сумму разными купюрами приоритет отдаётся крупным. * Если выдать запрашиваемую сумму не получится в принципе (сумма не кратна минимальному номиналу) — * выбросить ошибку 'Incorrect value'. * Если в банкомате недостаточно нужных купюр — выбросить ошибку 'Not enough money'. */  \n  \n  \nconst nominals = [5000, 1000, 500, 100, 50];  \n  \nconst limits = {50:10,100:10,500:10,1000:10,5000:10};  \n  \nfunction atmGiveMoneyObj(amount, limits) {  \n  \n    if (amount % 50 !== 0) {  \n        throw new Error(\"Incorrect value\");  \n    }  \n  \n    let remaining = amount;  \n    const result = {50:0,100:0,500:0,1000:0,5000:0};  \n  \n    for (const nominal of nominals) {  \n        if (remaining === 0) break;  \n        const needed = Math.floor(remaining / nominal);  \n        if (needed > 0) {  \n            const available = limits[nominal] || 0;  \n            const take = Math.min(needed, available);  \n            if (take > 0) {  \n                remaining -= take * nominal;  \n                limits[nominal] = available - take;  \n                result[nominal] = take;  \n            }  \n        }    }  \n    if (remaining > 0) {  \n        throw new Error(\"Not enough money\");  \n    }  \n  \n    return result;  \n}  \n  \n  \n  \nconsole.log(atmGiveMoneyObj(2350, limits));   \n// { 50: 1, 100: 3, 500: 0, 1000: 2, 5000: 0 }\n\n2) Вывод сообщений \n\n\n\nfunction solution(connect, render) {\n    let messages = new Map();\n    let lastRenderedId = 0;\n\n    connect((msg) => {\n        messages.set(msg.id, msg);\n\n        while (messages.has(lastRenderedId + 1)) {\n            lastRenderedId++;\n            render(messages.get(lastRenderedId));\n            messages.delete(lastRenderedId); // Удаляем сообщение после отображения\n        }\n\n        // Логирование или проверка на количество сообщений в Map, если необходимо\n        if (messages.size > 1000) {\n            console.warn(\"Более 1000 сообщений ожидают отображения\");\n        }\n    });\n}"
      },
      {
        "timestamp": "2025-01-31 15:18:06",
        "content": "2025-01-31 15:18:06\n Aintripin -> 2071074234:\nКомпания: Яндекс\nВакансия: frontend разработчик; написала hr сама\nЗП: по-моему, говорил, что ориентрируюсь на 280-330\n\nЗадачи:\n\n1. Реализовать функцию runOnce, которая оборачивает другую функцию таким образом, что если мы вызываем эту функцию через runOnce в первый раз, то она работает как обычно, а при последующий разах выводит в консоль undefined:\n\nfunction runOnce(fn) {\n    let hasBeenCalled = false;\n    let result;\n\n    return function(...args) {...",
        "full_content": "2025-01-31 15:18:06\n Aintripin -> 2071074234:\nКомпания: Яндекс\nВакансия: frontend разработчик; написала hr сама\nЗП: по-моему, говорил, что ориентрируюсь на 280-330\n\nЗадачи:\n\n1. Реализовать функцию runOnce, которая оборачивает другую функцию таким образом, что если мы вызываем эту функцию через runOnce в первый раз, то она работает как обычно, а при последующий разах выводит в консоль undefined:\n\nfunction runOnce(fn) {\n    let hasBeenCalled = false;\n    let result;\n\n    return function(...args) {\n        if (!hasBeenCalled) {\n            hasBeenCalled = true;\n            result = fn(...args);\n            return result;\n        } else {\n            return undefined;\n        }\n    };\n}\n\n// Пример использования\nconst logHello = () => {\n    console.log(\"hello!\");\n};\n\nconst logHelloOnce = runOnce(logHello);\n\nlogHelloOnce(); // 'hello!'\nlogHelloOnce(); // undefined\n\n2. Написать такую функцию, чтобы при передаче в неё двух промисов, она складывала их результаты выполнения:\n\n\nfunction sumPromises(...promises) {\n    return Promise.all(promises)\n        .then(results => {\n            return results.reduce((sum, value) => sum + value, 0);\n        });\n}\n\n// Пример использования\nconst promise1 = Promise.resolve(1);\nconst promise2 = Promise.resolve(2);\n\nsumPromises(promise1, promise2).then(console.log); // 3\n\n3. Есть функция callLimit: она принимает в себя три параметра: другую функцию (fn), количество раз, которое эта другая функция будет вызываться (limit), и callback, если у этой другой передаваемой функции он есть. Нужно реализовать этот функционал, сделав так, что всё то количество раз, когда мы вызываем функцию через callLimit, которое не превышает limit, выводилось сообщение передаваемой функции fn, а потом в самом конце callback (если он имеется)\n\n\nfunction callLimit(fn, limit, callback) {\n    let count = 0;\n    \n    const wrapped = function(...args) {\n        if (count >= limit) {\n            if (callback) {\n                callback();\n            }\n            return;\n        }\n        \n        count++;\n        // Вызываем callback когда это последний разрешенный вызов\n        const result = fn.apply(this, args);\n        if (count === limit && callback) {\n            callback();\n        }\n        return result;\n    };\n    \n    wrapped.reset = function() {\n        count = 0;\n    };\n    \n    return wrapped;\n}\n\n4. Есть функция, которая выполняется за время t, которое мы передаём, как один из параметров этой функции. Если эта функции выполняется за время t ил меньше, то сообщение об успехе выводится; если не успевает, то выбрасывается ошибка. Реализовать такую функцию:\n\nconst timeLimited = function(fn, t) {\n    return function(...args) {\n        const timeoutPromise = new Promise((_, reject) => {\n            setTimeout(() => {\n                reject(new Error('Time limit exceeded'));\n            }, t);\n        });\n\n        const functionPromise = fn(...args);\n\n        return Promise.race([functionPromise, timeoutPromise]);\n    };\n};\n\n4.1: Что будет происходить с таймером для`functionPromise`?\n        Ответ: он просто будет накапливаться, его можно очистить через clearTimeout\n       Как это сделать?\n\nconst timeLimited = function (fn, t) {\n  return function (...args) {\n    const timeoutPromise = new Promise((_, reject) => {\n      let id;\n      id = setTimeout(() => {\n        reject(new Error(\"Time limit exceeded\"));\n      }, t);\n    });\n\n    const functionPromise = fn(...args).then(clearTimeout(id));\n\n    return Promise.race([functionPromise, timeoutPromise]);\n  };\n};\n\nТипо, мы привязываем к каждому промису в каждой новой итерации по id'шнику и потом чистим через clearTimeout(id)\n\n4.2 Если functionPromise упадёт, то чё делать будем?\n      Обернуть в catch:\n    const functionPromise = fn(...args)\n      .then(clearTimeout(id))\n      .catch((err) => console.log(err));\n\n4.3 А почему в \ncatch((err) => console.log(err))\nты пишешь (err) => ..., а в then(clearTimeout(id)) — там такого нет?\nОтвет: в catch мы саму ошибку передаём, а в then там ничё нет, поэтому необязательно. Я так понял, можно было \n.then(() => clearTimeout(id))"
      },
      {
        "timestamp": "2025-01-30 05:58:26",
        "content": "2025-01-30 05:58:26\n Кирилл -> 2071074234:\nНазвание компании: Яндекс\nСсылка на вакансию:  hr сама написала\nЗП: от 250 тыс. руб\nВопросы: \n- async await \n- == vs ===\n- != vs !==\n- как работает eventloop\nЗадачи:\n- По задачам нужно было сначала рассказать как буду решать, а после написания задачи нужно было объяснить как работает код\n// Задача 1\n// Что будет выведено в консоль\n\nvar n = 1;\nfunction f(n) {\n    n = 3;\n}\nf(n);\nconsole.log(n); // 1\n\n\nvar obj = { a: 1 };\nfunction f1(o) {\n    o.a = 5;\n}\nf1...",
        "full_content": "2025-01-30 05:58:26\n Кирилл -> 2071074234:\nНазвание компании: Яндекс\nСсылка на вакансию:  hr сама написала\nЗП: от 250 тыс. руб\nВопросы: \n- async await \n- == vs ===\n- != vs !==\n- как работает eventloop\nЗадачи:\n- По задачам нужно было сначала рассказать как буду решать, а после написания задачи нужно было объяснить как работает код\n// Задача 1\n// Что будет выведено в консоль\n\nvar n = 1;\nfunction f(n) {\n    n = 3;\n}\nf(n);\nconsole.log(n); // 1\n\n\nvar obj = { a: 1 };\nfunction f1(o) {\n    o.a = 5;\n}\nf1(obj);\nconsole.log(obj); //  { a: 5 };\n\n\nvar obj = { a: 1 };\nfunction f2(o) {\n    o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // { a: 1 };\n\n\n// Задача 2:\n// Написать функцию sleep, которая будет спать заданное количество миллисекунд, а потом успешно завершаться\n// Тут необходимо было рассказать про eventloop и как браузер будет обрабатывать код\nfunction sleep(duration) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        }, duration)\n    })\n}\n\n\n// Задача 3:\n// 1)Написать декоратор для функции, который ограничивает число вызывов\n// callback передается опционально. Если передали, то вывывать на последней операции\n// 2) У вызываемой фукнции должен быть метод для перезагрузки счетчика в начальное положение\nfunction callLimit(fn, limit, callback) {\n    let сounter = 0\n    function limitedFn(...args) {\n        сounter++\n        if (сounter <= limit) {\n\n            if (сounter === limit && callback) {\n                callback()\n            }\n\n            return fn.applay(this, args)\n        }\n        return null\n    }\n    limitedFn.reset = () => {\n        сounter = 0\n    }\n    return limitedFn\n}\n\n\n// Задача 4:\n//Необходимо реализовать функцию timeLimited, которая принимает асинхронную функцию и временной лимит в миллисекундах. \n//Функция timeLimited должна возвращать новую асинхронную функцию, которая выполняет переданную функцию, \n// но отклоняется с ошибкой, если выполнение занимает больше заданного времени.\n\nconst timeLimited = function (fn, t) {\n    return async function (...args) {\n\n        return Promise.race([\n            fn(...args),\n\n            new Promise((_, reject) => {\n                setTimeout(() => reject(\"Time limit exceeded\"), t)\n            }),\n        ]);\n    };\n};\n- Успех собеса: ✅"
      },
      {
        "timestamp": "2025-01-28 13:24:43",
        "content": "2025-01-28 13:24:43\n Владислав -> 2071074234:\n- компания: Яндекс (1 этап)\n- вакансия: hr написал\n- зп не обсуждалось\n\nЗадачи: \n#Задача 1\nЧто выведет консоль\nКак исправить\n\nУсловие: \nconst object = {\n  value: '42',\n  print() {\n    function type() {\n      return this.value;\n    }\n    \n    console.log(`${this.value} is ${type()}`);\n  },\n};\n\nobject.print();\nРешение \n// Консоль выведет 42 undefined\n// Чтоб исправить нужно задать контекст функции, либо сделать ее стрелочной, чтоб она брала контекст вы...",
        "full_content": "2025-01-28 13:24:43\n Владислав -> 2071074234:\n- компания: Яндекс (1 этап)\n- вакансия: hr написал\n- зп не обсуждалось\n\nЗадачи: \n#Задача 1\nЧто выведет консоль\nКак исправить\n\nУсловие: \nconst object = {\n  value: '42',\n  print() {\n    function type() {\n      return this.value;\n    }\n    \n    console.log(`${this.value} is ${type()}`);\n  },\n};\n\nobject.print();\nРешение \n// Консоль выведет 42 undefined\n// Чтоб исправить нужно задать контекст функции, либо сделать ее стрелочной, чтоб она брала контекст выше\n\nconst object = {\n  value: '42',\n  print() {\n    const type = () => {\n      return this.value;\n    }\n    \n    console.log(`${this.value} is ${type()}`);\n  },\n};\n\nobject.print();\n\n#Задача 2\nНаписать ф-цию compose\n\nУсловие:\nfunction compose() {\n  // code here\n}\n\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.log(compose(square, times2)(2) === square(times2(2)));\nconsole.log(compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));\nРешение\nfunction compose(...funcs) {\n  return function(...args) {\n    return funcs.reduceRight((acc, fn) => [fn(...acc)], args)[0];\n  };\n}\n\n#Задача 3\nНаписать функцию get, которая принимает url, делать запрос и отдает ответ. В случае ошибки делает 5 попыток \n\nрешение\nfunction get(url, count = 5) {\n  return (\n    fetch(url)\n    .then((res) => {\n      return res.json();\n    })\n    .catch(() => {\n      if (count > 0) {\n        return get(url, count - 1)\n      }\n\n      return Promise.reject('Задача не выполнена')\n    })\n  )\n}\n\nget('https://api.example.com/data')\n    .then(res => console.log(res))\n    .catch(err => console.error(err));\n\n#Задача 4\nЕсть дерево, на котором сидят белки (squirrel) и вороны(raven). Нужно написать функцию, которая проходит по дереву, собирает всех белок и выводит их имена\n\nУсловие\nfunction squirrelScanner(tree) {\n  // code here\n}\n\n// Пример дерева\nconst tree = {\n  nest: { name: 'NEVERMORE!', type: 'raven' },\n  branches: [\n    {\n      nest: { name: 'Acorn', type: 'squirrel' },\n      branches: [\n        {\n          nest: { name: 'Sir Salty', type: 'squirrel' },\n        },\n        {\n          nest: { name: 'Huginn', type: 'raven' },\n          branches: [\n            {},\n            { nest: { name: 'Muninn', type: 'raven' } },\n            { nest: { name: 'Kernel', type: 'squirrel' } },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nconsole.log(squirrelScanner(tree)); // ['Acorn', 'Sir Salty', 'Kernel']\nРешение:\nfunction squirrelScanner(tree) {\n  const squirrels = [];\n\n  // Проверяем текущий узел дерева\n  if (tree.nest.type === 'squirrel') {\n    squirrels.push(tree.nest.name);\n  }\n\n  // Если есть ветви, рекурсивно ищем белок в каждой ветви\n  if (tree.branches) {\n    tree.branches.forEach(branch => {\n      squirrels.push(...squirrelScanner(branch));  // Собираем белок из дочерних ветвей\n    });\n  }\n\n  return squirrels;\n}"
      },
      {
        "timestamp": "2024-12-26 14:04:09",
        "content": "2024-12-26 14:04:09\n Дастан -> 2071074234:\nКомпания: Яндекс, второй этап\nСсылка на вакансию: hr написала\nЗП: не обсуждали\n\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту.\n*/\n\nfunction getRo...",
        "full_content": "2024-12-26 14:04:09\n Дастан -> 2071074234:\nКомпания: Яндекс, второй этап\nСсылка на вакансию: hr написала\nЗП: не обсуждали\n\n/*\nУ нас есть набор билетов вида:\n\n[\n    { from: 'London', to: 'Moscow' },\n    { from: 'NY', to: 'London' },\n    { from: 'Moscow', to: 'SPb' },\n    ...\n]\n\nИз этих билетов можно построить единственный, неразрывный маршрут.\nПетель и повторов в маршруте нет.\n\nНужно написать программу, которая возвращает эти же объекты билетов\nв порядке следования по маршруту.\n*/\n\nfunction getRoute(tickets = []) {\n  // TODO\n  const set = new Set();\n\n  const result = [];\n  const map = new Map();\n\n  tickets.forEach((item) => {\n    if (!set.has(item.from)) set.add(item.from);\n    map.set(item.from, item);\n  });\n\n  tickets.forEach((item) => {\n    if (set.has(item.to)) set.delete(item.to);\n  });\n\n\n  let i = 0;\n  let current = [...set][0];\n\n  while (i < map.size) {\n    const cur = map.get(current);\n    result.push(cur);\n    current = cur.to;\n    i++;\n  }\n\n  return result;\n}\n\n\n/*\nДан массив ссылок: ['url1', 'url2', ...] и лимит одновременных запросов (limit)\nНеобходимо реализовать функцию, которая опросит урлы в том порядке, в котором они идут в массиве, и вызовет callback c массивом ответов\n['url1_answer', 'url2_answer', ...] так, чтобы в любой момент времени выполнялось не более limit\nзапросов (как только любой из них завершился, сразу же отправляется следующий)\nТ.е. нужно реализовать шину с шириной равной limit.\n\nТребования:\n- Порядок в массиве ответов должен совпадать с порядком в массиве ссылок\nДополнительно:\n- Функция должна обладать мемоизацией (один и тот же урл не опрашивать дважды)\n\nДля опроса можно использовать fetch\nОшибки обрабатывать не нужно\n*/\n\n\n\nasync function parallelLimit(urls, limit, callback) {\n  // TODO\n  const result = [];\n  const cache = {};\n  const set = new Set();\n\n  for (let i = 0; i < urls.length; i++) {\n    const promise = fetchUrl(urls[i], i).finally(() => set.delete(promise));\n    set.add(promise);\n\n    if (set.size >= limit) {\n      await Promise.race(set);\n    }\n  }\n\n  await Promise.all(set);\n\n  async function fetchUrl(url, index) {\n    try {\n      if (!cache[url]) {\n        const response = await fetch(url);\n        result[index] = response;\n        cache[url] = response;\n      } else {\n        result[index] = cache[url];\n      }\n    } catch (error) {\n      result[index] = error;\n      cache[url] = error;\n    }\n  }\n\n\n  return callback(result);\n}"
      },
      {
        "timestamp": "2024-12-24 08:43:19",
        "content": "2024-12-24 08:43:19\n Дастан -> 2071074234:\nКомпания: Яндекс, первый этап\nссылка на вакансию: hr написала\nзп: не обсуждали\n// Первая секция:\n\nvar n = 1;\nfunction f(n) {\n  n = 3;\n}\nf(n);\nconsole.log(n); // ?? 1\n\n\nvar obj = { a: 1 };\nfunction f1(o) {\n  o.a = 5;\n}\nf1(obj);\nconsole.log(obj); // ?? { a: 5 };\n\n\nvar obj = { a: 1 };\nfunction f2(o) {\n  o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // ??{ a: 1 };\n\n\n\n/**\n * Необходимо написать функцию strjoin, которая склеивает строки через разделитель.\n *...",
        "full_content": "2024-12-24 08:43:19\n Дастан -> 2071074234:\nКомпания: Яндекс, первый этап\nссылка на вакансию: hr написала\nзп: не обсуждали\n// Первая секция:\n\nvar n = 1;\nfunction f(n) {\n  n = 3;\n}\nf(n);\nconsole.log(n); // ?? 1\n\n\nvar obj = { a: 1 };\nfunction f1(o) {\n  o.a = 5;\n}\nf1(obj);\nconsole.log(obj); // ?? { a: 5 };\n\n\nvar obj = { a: 1 };\nfunction f2(o) {\n  o = { hello: 1 };\n}\nf2(obj);\nconsole.log(obj); // ??{ a: 1 };\n\n\n\n/**\n * Необходимо написать функцию strjoin, которая склеивает строки через разделитель.\n */\n\nfunction strjoin(splitter, ...strings) {\n  // return strings.join(splitter);\n  let result = '';\n  for (let i = 0; i < strings.length; i++) {\n    let current = strings[i];\n    if (i === 0) result += `${current}`;\n    else result += `${splitter}${current}`;\n  }\n\n  return result;\n}\n\nconsole.log(strjoin('.', 'a', 'b', 'c')); // 'a.b.c'\nconsole.log(strjoin('-', 'a', 'b', 'c', 'd', 'e', 'f')); // 'a-b-c-d-e-f'\n\n\n/*\n * Нужно написать функцию compose.\n * Количество входящих функций в compose и число аргументов результирующей функции не ограничены.\n */\n\nconst square = (x) => x * x;\nconst times2 = (x) => x * 2;\nconst sum = (a, b) => a + b;\n\nconsole.log(compose(square, times2)(2) === square(times2(2)));\nconsole.log(compose(square, times2, sum)(3, 4) === square(times2(sum(3, 4))));\n\n\nfunction compose(...funcs) {\n  return function (...args) {\n    return funcs.reduceRight((acc, fn) => {\n      return [fn(...acc)];\n    }, args)[0];\n  };\n}\n\n\n/*Задача: Реализация функции timeLimited\nОписание:\n\nВам необходимо реализовать функцию timeLimited, которая принимает асинхронную функцию и временной лимит в миллисекундах. \nФункция timeLimited должна возвращать новую асинхронную функцию, которая выполняет переданную функцию, но отклоняется с ошибкой, если выполнение занимает больше заданного времени.\n\nТребования:\n\nФункция timeLimited должна принимать два аргумента:\nfn: асинхронная функция, выполнение которой нужно ограничить.\nt: временной лимит в миллисекундах (число).\nФункция timeLimited должна возвращать новую асинхронную функцию, которая:\nПринимает произвольное количество аргументов, которые будут переданы в fn.\nИспользует Promise.race для одновременного выполнения двух промисов:\nПервый промис — это вызов функции fn с переданными аргументами.\nВторой промис — это таймер, который отклоняется через t миллисекунд с сообщением \"Time limit exceeded\".\nЕсли функция fn выполняется в пределах временного лимита, результат выполнения должен быть возвращён.\nЕсли функция fn не завершает выполнение в течение времени t, функция должна отклоняться с ошибкой \"Time limit exceeded\". */\n\nconst timeLimited = function (fn, t) {\n  return async function (...args) {\n\n    return Promise.race([\n      fn(...args),\n\n      new Promise((_, reject) =>\n        setTimeout(\n          () =>\n            reject(\"Time limit exceeded\"),\n          t\n        )\n      ),\n    ]);\n  };\n};\n\n\n/**\n * \n * Реализовать задачу isMonotonic, на вход приходит массив с цифрами, нужно отдать true, если айтемы в массиве идут \n * вверх или вних, последовательно, а если нет то false \n * \n * [1, 2, 3, 5, 7, 8] => true\n * [6, 4, 2, 1 ] => true\n * [2, 3, 7, 4] => false\n *\n */\n\nfunction isMonotonic(numbers) {\n  if (numbers.length <= 1) return true;\n\n  let isIncreasing = true;\n  let isDecreasing = true;\n\n  for (let i = 1; i < numbers.length; i++) {\n      if (numbers[i] > numbers[i - 1]) {\n          isDecreasing = false;\n      }\n      if (numbers[i] < numbers[i - 1]) {\n          isIncreasing = false;\n      }\n  }\n\n  return isIncreasing || isDecreasing;\n}\n\n/*\n   Напишите код, который при клике на любой div\n   внутри root будет выводить в консоль его id.\n   Можно использовать jQuery\n   */\n\n<div id=\"root\" style=\"background: red;\">\n  root\n  <span id=\"id1\" style=\"background: lightblue;\">id1</span>\n  <div id=\"id2\" style=\"background: green;\">\n    id2\n    <div id=\"id3\" style=\"background: yellow;\">id3</div>\n  </div>\n</div>;\n\nconst root = document.getElementById(\"root\");\nroot.addEventListener(\"click\", (event) => {\n  if (event.target.tagName === \"DIV\") {\n    console.log(event.target.id);\n  }\n});"
      },
      {
        "timestamp": "2024-12-19 16:36:42",
        "content": "2024-12-19 16:36:42\n Egor -> 2071074234:\nКомпания: Яндекс 2 этап\nСсылка на вакансию: hr написала\nЗп: ???\nЗапись: https://youtu.be/PZxhhMAhfWc",
        "full_content": "2024-12-19 16:36:42\n Egor -> 2071074234:\nКомпания: Яндекс 2 этап\nСсылка на вакансию: hr написала\nЗп: ???\nЗапись: https://youtu.be/PZxhhMAhfWc"
      },
      {
        "timestamp": "2024-12-17 14:07:43",
        "content": "2024-12-17 14:07:43\n Egor -> 2071074234:\nКомпания: Яндекс 1 этап\nСсылка на вакансию: hr написала\nЗп: не обсуждалась \nСсылка на собес: https://youtu.be/ZGpMwk8nCbc",
        "full_content": "2024-12-17 14:07:43\n Egor -> 2071074234:\nКомпания: Яндекс 1 этап\nСсылка на вакансию: hr написала\nЗп: не обсуждалась \nСсылка на собес: https://youtu.be/ZGpMwk8nCbc"
      },
      {
        "timestamp": "2024-11-26 11:31:05",
        "content": "2024-11-26 11:31:05\n Maksim -> 2071074234:\nКомпания: Яндекс (3 этап Софт)                                                                                                                                                                                        Вопросы:                                                                                                                                                                                                                              1)Расскажи пр...",
        "full_content": "2024-11-26 11:31:05\n Maksim -> 2071074234:\nКомпания: Яндекс (3 этап Софт)                                                                                                                                                                                        Вопросы:                                                                                                                                                                                                                              1)Расскажи про опыт                                                                                                                                                                                                                          2)Что вкладывал в архитектуру проекта                                                                                                                                                                            3)Пример 1-2 задач которыми гордишься                                                                                                                                                                            4)Как бы ты деплоил и кто у вас этим занимается                                                                                                                                                             5)Приходилось ли тебе настраивать Ci/ Cd                                                                                                                                                                        6)Какие тесты используете на проекте                                                                                                                                                                   7)Приходилось ли тебе Оптимизировать приложение                                                                                                                                    8)Приложение долго грузиться как бы ты это решал                                                                                                                                                  9)Работал ли с SSR плюсы и минусы                                                                                                                                                                                       10)Что привнес в проект                                                                                                                                                                                                             11)Был ли опыт менторства                                                                                                                                                                                                    12)Были ли кейсы недопонимания                                                                                                                                                                                13)Расскажи про опыт позитивной интеграции со сверстниками"
      },
      {
        "timestamp": "2024-11-20 11:18:10",
        "content": "2024-11-20 11:18:10\n Maksim -> 2071074234:\nКомпания: Яндекс (2этап)                                                                                                                                                                                                                        Вакансия:Hr сама написала                                                                                                                                                                                                ...",
        "full_content": "2024-11-20 11:18:10\n Maksim -> 2071074234:\nКомпания: Яндекс (2этап)                                                                                                                                                                                                                        Вакансия:Hr сама написала                                                                                                                                                                                                              Зп: не обсуждали                                                                                                                                                                                                                            Расскажи про опыт и задачи(была еще задача легкая на eventLoop не сохранилась):                                                                                                  \n   const price = [2, 3, 5, 8, 7, 6];\n\nfunction getIceCream(amount) {\n \n    const map = new Map();  // Для хранения индексов, которые могут составить сумму\n\n    for (let i = 0; i < price.length; i++) {\n        const complement = amount - price[i];  // Искомое число для текущей цены\n        if (map.has(complement)) {\n            // Если complement найден в map, возвращаем индексы\n            return [map.get(complement), i];\n        }\n        // Если complement не найден, добавляем текущую цену и ее индекс в map\n        map.set(price[i], i);\n    }\n\n    return [];  // Если не нашли пары, возвращаем пустой массив\n}\nclass EventEmmiter {\n    constructor() {\n        // Инициализация объекта для хранения событий\n        this.events = {}\n    }\n\n    addEventListener(event, listener) {\n        // Проверяем, существует ли список слушателей для данного события\n        if (!this.events[event]) {\n            this.events[event] = [] // Если нет, создаем новый\n        }\n        this.events[event].push(listener) // Добавляем слушателя в список\n\n        // Возвращаем функцию, которая удаляет слушателя\n        return () => {\n            this.events[event] = this.events[event].filter(el => el !== listener)\n        }\n    }\n\n    dispatchEvent(event, payload) {\n        // Если для события нет слушателей, ничего не делаем\n        if (!this.events[event]) {\n            return\n        }\n        // Вызываем каждого слушателя с переданным payload\n        this.events[event].forEach(listener => listener(payload))\n    }\n}\nДоработка: \nconstructor(method) {\n        this.events = {}\n        this.method = method\n    }\ndispatchEvent(event, payload) {\n        if (!this.events[event]) {\n            return\n        }\n        this.events[event].forEach(listener => {\n            this.method(() => {\n                listener(payload)\n            })\n        });\n    }"
      },
      {
        "timestamp": "2024-11-17 08:20:07",
        "content": "2024-11-17 08:20:07\n Вадим -> 2071074234:\nКомпания: Яндекс\nВакансия: https://yandex.ru/jobs/vacancies/разработчик-интерфейсов-в-финансовые-продукты-hr-tech-24409\nЗП: не обсуждали \nВопросы:\n1.Задача \n- Создать функцию которая предназначена для составления маршрута по предоставленным билетам. Она принимает массив билетов tickets, каждый из которых содержит информацию о маршруте от пункта отправления (from) до пункта назначения (to). Примерное решение:\n\n  const fromMap = {};\n  const toMap = {};\n\n  ...",
        "full_content": "2024-11-17 08:20:07\n Вадим -> 2071074234:\nКомпания: Яндекс\nВакансия: https://yandex.ru/jobs/vacancies/разработчик-интерфейсов-в-финансовые-продукты-hr-tech-24409\nЗП: не обсуждали \nВопросы:\n1.Задача \n- Создать функцию которая предназначена для составления маршрута по предоставленным билетам. Она принимает массив билетов tickets, каждый из которых содержит информацию о маршруте от пункта отправления (from) до пункта назначения (to). Примерное решение:\n\n  const fromMap = {};\n  const toMap = {};\n\n  // Создаем карты маршрутов\n  tickets.forEach(ticket => {\n    fromMap[ticket.from] = ticket;\n    toMap[ticket.to] = ticket;\n  });\n\n  // Определяем начальную точку\n  let startName = null;\n  let currentTicket = null;\n  for (const ticket of tickets) {\n    const name = ticket.from;\n    if (!(name in toMap)) {\n      startName = name;\n      currentTicket = ticket;\n      break;\n    }\n  }\n\n  // Построение полного маршрута\n  const result = [currentTicket];\n  while (result.length < tickets.length) {\n    const prev = result[result.length - 1];\n    const next = fromMap[prev.to];\n    result.push(next);\n  }\n\n  return result;\n}\n\n2.Задача: создать функцию, которая преобразует массив чисел в строку, представляющую диапазоны чисел из входного массива.\nПримерное решение: \n\n.sort((a, b) => a - b)\n.reduce((agg, v) => {\nconst currRange = agg[agg.length - 1]\nif (!currRange || v > currRange.last + 1) {\nagg.push({first: v, last: v})\n} else {\ncurrRange.last = v\n}\nreturn agg\n}, [])\n.map(v => v.first + (v.first !== v.last ? '-' + v.last : '')).join()"
      },
      {
        "timestamp": "2024-11-15 14:16:36",
        "content": "2024-11-15 14:16:36\n Sergey Chizhikov -> 2071074234:\nКомпания: Яндекс(2 этап)\nВакансия: Написала hr\nЗадачи:\nfunction range(start, stop, step = 1) {\nif (stop === undefined) {\nstop = start;\nstart = 0;\n}\n\nconst result = [];\nif (step > 0) {\nfor (let i = start; i < stop; i += step) {\nresult.push(i);\n}\n} else if (step < 0) {\nfor (let i = start; i > stop; i += step) {\nresult.push(i);\n}\n}\n\nreturn result;\n}\n\n function compress(list) {\nif (list.length === 0) return '';\n\nlist.sort((a, b) => a - b);\n\nlet re...",
        "full_content": "2024-11-15 14:16:36\n Sergey Chizhikov -> 2071074234:\nКомпания: Яндекс(2 этап)\nВакансия: Написала hr\nЗадачи:\nfunction range(start, stop, step = 1) {\nif (stop === undefined) {\nstop = start;\nstart = 0;\n}\n\nconst result = [];\nif (step > 0) {\nfor (let i = start; i < stop; i += step) {\nresult.push(i);\n}\n} else if (step < 0) {\nfor (let i = start; i > stop; i += step) {\nresult.push(i);\n}\n}\n\nreturn result;\n}\n\n function compress(list) {\nif (list.length === 0) return '';\n\nlist.sort((a, b) => a - b);\n\nlet result = [];\nlet start = list[0];\nlet end = start;\n\nfor (let i = 1; i <= list.length; i++) {\nif (list[i] === end + 1) {\nend = list[i];\n} else {\nif (start === end) {\nresult.push(start);\n} else {\nresult.push(`${start}-${end}`);\n}\nstart = list[i];\nend = start;\n}\n}\n\nreturn result.join(',');\n}\n\n function getRoute(tickets = []) {\n// Создаем Map для хранения маршрутов и Set для хранения всех пунктов назначения\nconst map = new Map();\nconst destinationSet = new Set();\n\n// Заполняем карту и множество всех пунктов назначения\ntickets.forEach(ticket => {\n// Добавляем в карту маршрут: ключ - пункт отправления, значение - пункт назначения\nmap.set(ticket.from, ticket.to);\n// Добавляем пункт назначения в множество, чтобы отслеживать все назначения\ndestinationSet.add(ticket.to);\n});\n\n// Определяем начальную точку маршрута\nlet start = null;\n\n// Ищем пункт отправления, который не является пунктом назначения\ntickets.forEach(ticket => {\n// Если пункт отправления не находится в множестве пунктов назначения, это начальная точка\nif (!destinationSet.has(ticket.from)) {\nstart = ticket.from;\n}\n});\n\n// Восстанавливаем маршрут\nconst route = [];\nlet current = start;\n\n// Пока есть следующий пункт назначения в карте\nwhile (map.has(current)) {\n// Получаем следующий пункт назначения из карты\nconst next = map.get(current);\n// Добавляем объект маршрута в результирующий массив\nroute.push({ from: current, to: next });\n// Переходим к следующему пункту\ncurrent = next;\n}\n\n// Возвращаем восстановленный маршрут\nreturn route;\n}"
      },
      {
        "timestamp": "2024-11-14 19:35:55",
        "content": "2024-11-14 19:35:55\n Maksim -> 2071074234:\nЯндекс (1этап) (меня собесили в яндекс музыку)                                                                                                                                                                                                                           Вакансия:Hr сама написала                                                                                                                                                                       ...",
        "full_content": "2024-11-14 19:35:55\n Maksim -> 2071074234:\nЯндекс (1этап) (меня собесили в яндекс музыку)                                                                                                                                                                                                                           Вакансия:Hr сама написала                                                                                                                                                                                                  Вопросы:                                                                                                                                                                                                                                                                       - Расскажи про опыт                                                                                                                                                                                                                           - Про Promise                                                                                                                                                                                                                                         - Про Event bubbling                                                                                                                                                                                                                 Задачи:                                                                                                                                                                                                                                                        - Стандартная задача какого цвета будет <div> : Оба дива будут синими.\n\nВ CSS, когда у элемента несколько классов, приоритет имеют стили, указанные позже. Поскольку .blue определяется после .red, стили .blue будут применяться ко всем элементам, поэтому оба дива будут с синим фоном.                                                                               - \nfunction canGetCount(n) {\n    let count = 0;\n    return function() {\n        if (count < n) {\n            count++;\n            return 'yes';\n        } else {\n            return 'no';\n        }\n    };\n}\n- \nPromise.resolve(1)\n    .then(x => x + 1)                   // x = 1, возвращает 2\n    .then(x => { throw x })             // выбрасывает ошибку со значением 2\n    .then(x => console.log(x))          // пропускается, так как была ошибка\n    .catch(err => console.log(err))     // ловит ошибку и выводит 2 в консоль\n    .then(x => Promise.resolve(1))      // возвращает промис, который резолвится в 1\n    .catch(err => console.log(err))     // пропускается, так как нет ошибки\n    .then(x => console.log(x));         // выводит 1 в консоль\n- \nfunction isValid(str) {\n  const stack = [];\n  const brackets = {\n    '(': ')',\n    '{': '}',\n    '[': ']'\n  };\n\n  for (let char of str) {\n    if (brackets[char]) {\n      // если открывающая скобка, добавляем в стек\n      stack.push(char);\n    } else if (Object.values(brackets).includes(char)) {\n      // если закрывающая скобка, проверяем соответствие\n      if (brackets[stack.pop()] !== char) {\n        return false;\n      }\n    }\n  }\n\n  // если стек не пуст, значит есть незакрытые скобки\n  return stack.length === 0;\n}"
      },
      {
        "timestamp": "2024-11-12 18:31:49",
        "content": "2024-11-12 18:31:49\n Гладких Александр -> 2071074234:\nКомпания Яндекс Фантех 2 этап \nВакансия hr сама написала\nЗП: не обсуждали\n\nВопросов не было сразу задачи\n\nзадачи \n\n1 задача\n\nfunction namespace(str) {\n    // Разделяем входную строку по символу точки, чтобы получить массив ключей\n    const keys = str.split('.');\n\n    // Инициализируем результирующий объект\n    let result = {};\n\n    // Инициализируем переменную для отслеживания текущего уровня вложенности\n    let currentLevel = result;\n\n    //...",
        "full_content": "2024-11-12 18:31:49\n Гладких Александр -> 2071074234:\nКомпания Яндекс Фантех 2 этап \nВакансия hr сама написала\nЗП: не обсуждали\n\nВопросов не было сразу задачи\n\nзадачи \n\n1 задача\n\nfunction namespace(str) {\n    // Разделяем входную строку по символу точки, чтобы получить массив ключей\n    const keys = str.split('.');\n\n    // Инициализируем результирующий объект\n    let result = {};\n\n    // Инициализируем переменную для отслеживания текущего уровня вложенности\n    let currentLevel = result;\n\n    // Перебираем ключи\n    for (let i = 0; i < keys.length; i++) {\n        // Создаем новый объект для текущего ключа\n        currentLevel[keys[i]] = {};\n\n        // Перемещаем текущий уровень на новый созданный объект\n        currentLevel = currentLevel[keys[i]];\n    }\n\n    // Возвращаем итоговый вложенный объект\n    return result;\n}\n\n// Пример использования:\nconsole.log(namespace('a.b.c.d.e'));\n// Вывод: { a: { b: { c: { d: { e: {} } } } } }\n\n\n2 задача \n\n\nfunction compress(list) {\n    // Сортируем массив\n    list.sort((a, b) => a - b);\n\n    // Инициализируем массив для хранения диапазонов\n    let ranges = [];\n\n    // Инициализируем переменные для текущего диапазона\n    let start = list[0];\n    let end = list[0];\n\n    // Функция для добавления диапазона в массив ranges\n    function addRange() {\n        if (start === end) {\n            ranges.push(start.toString());\n        } else {\n            ranges.push(start + '-' + end);\n        }\n    }\n\n    // Перебираем массив, начиная со второго элемента\n    for (let i = 1; i < list.length; i++) {\n        if (list[i] === end + 1) {\n            // Если текущий элемент следует за предыдущим, обновляем конец диапазона\n            end = list[i];\n        } else {\n            // Если текущий элемент не следует за предыдущим, добавляем текущий диапазон в массив диапазонов\n            addRange();\n            // Начинаем новый диапазон\n            start = list[i];\n            end = list[i];\n        }\n    }\n\n    // Добавляем последний диапазон\n    addRange();\n\n    // Возвращаем строку, объединяя диапазоны запятыми\n    return ranges.join(',');\n}\n\n// Примеры использования:\nconsole.log(compress([1, 4, 5, 2, 3, 9, 8, 11, 0])); // '0-5,8-9,11'\nconsole.log(compress([1, 4, 3, 2])); // '1-4'\nconsole.log(compress([1, 4])); // '1,4'\nconsole.log(compress([1, 2])); // '1-2'\n\n\n3 задача\n\nfunction range(start, stop, step) {\n    // Определяем значения по умолчанию для start, stop и step\n    if (arguments.length === 1) {\n        // Если передан только один аргумент, он считается stop, start = 0, step = 1\n        stop = start;\n        start = 0;\n        step = 1;\n    } else if (arguments.length === 2) {\n        // Если передано два аргумента, они считаются start и stop, step = 1\n        step = 1;\n    }\n\n    // Инициализируем массив для хранения результата\n    let result = [];\n\n    // Определяем направление итерации\n    if (step > 0) {\n        // Если step положительный, итерируем от start до stop с шагом step\n        for (let i = start; i < stop; i += step) {\n            result.push(i);\n        }\n    } else {\n        // Если step отрицательный, итерируем от start до stop с шагом step\n        for (let i = start; i > stop; i += step) {\n            result.push(i);\n        }\n    }\n\n    // Возвращаем массив с результатом\n    return result;\n}\n\n// Примеры использования:\nconsole.log(range(10)); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(range(1, 11)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconsole.log(range(0, 30, 5)); // [0, 5, 10, 15, 20, 25]\nconsole.log(range(0, 10, 3)); // [0, 3, 6, 9]\nconsole.log(range(0)); // []\nconsole.log(range(-6)); // []\nconsole.log(range(-6, 0)); // [-6, -5, -4, -3, -2, -1]\nconsole.log(range(-6, 0, 2)); // [-6, -4, -2]\nconsole.log(range(0, -10, -2)); // [0, -2, -4, -6, -8]"
      },
      {
        "timestamp": "2024-11-11 10:58:30",
        "content": "2024-11-11 10:58:30\n Ivan -> 2071074234:\nКомпания: Яндекс\nЗП: 220\nВопросы: \nСпрашивал про технологии, которыми пользуешься, про опыт\nЗадачи:\nvar str = 'qwerty';\nstr[0] = '$';\n\nconsole.log(str);\n\n// Что произойдет в консоли после выполнения следующего фрагмента кода?\n\nvar i = 10;\nvar array = [];\n\n// const a = --i;\n\nwhile (i--) {\n    let b = i\n    array.push(function() {\n      return b + b;\n    });\n}\n\nconsole.log([\n    array[0](), \n    array[1](), \n]);\n\n\n/**\n * Нужно написать функцию get. На вход ...",
        "full_content": "2024-11-11 10:58:30\n Ivan -> 2071074234:\nКомпания: Яндекс\nЗП: 220\nВопросы: \nСпрашивал про технологии, которыми пользуешься, про опыт\nЗадачи:\nvar str = 'qwerty';\nstr[0] = '$';\n\nconsole.log(str);\n\n// Что произойдет в консоли после выполнения следующего фрагмента кода?\n\nvar i = 10;\nvar array = [];\n\n// const a = --i;\n\nwhile (i--) {\n    let b = i\n    array.push(function() {\n      return b + b;\n    });\n}\n\nconsole.log([\n    array[0](), \n    array[1](), \n]);\n\n\n/**\n * Нужно написать функцию get. На вход функция принимает объект и путь до поля объекта. \n * Путь – это строка, разделенная точкой. Функция должна вернуть соответствующее поле объекта. \n * Запрашиваемого поля в объекте может не быть.\n */\n\nfunction get(obj, path) {\n    const keys = path.split('.');\n    let result = obj;\n\n    for (let key of keys){\n        if(typeof result === 'object' && result !== null && key in result){\n            result = result[key]\n        }else{\n             return undefined\n        }\n    }\n    return result;\n}\n\nconst obj = { \n  a: { \n    b: { \n      c: 'd' \n    },\n    e: 'f',\n    g: ['h', 'i', 'j']\n  }\n};\n\nget(obj, 'a.b');   // { c : 'd' }\nget(obj, 'a.b.c'); // 'd'\nget(obj, 'a.e');   // 'f'\nget(obj, 'a.x.e'); // undefined\nget(obj, 'a.g.1'); // 'i'"
      },
      {
        "timestamp": "2024-11-10 02:10:14",
        "content": "2024-11-10 02:10:14\n Sergey Chizhikov -> 2071074234:\nкомпания: яндекс\nВакансия: нет, написала hr\nВопросов не было\n\nЗадачи:\n// 1\n\nfunction strJoin(separator, ...arr){\n    return arr.join(separator)\n}\n\n\n//==============================================================================\n\n// 2\n\nfunction sleep(duration){\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        }, duration)\n    })\n}\n\n//===================================================================...",
        "full_content": "2024-11-10 02:10:14\n Sergey Chizhikov -> 2071074234:\nкомпания: яндекс\nВакансия: нет, написала hr\nВопросов не было\n\nЗадачи:\n// 1\n\nfunction strJoin(separator, ...arr){\n    return arr.join(separator)\n}\n\n\n//==============================================================================\n\n// 2\n\nfunction sleep(duration){\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve()\n        }, duration)\n    })\n}\n\n//==============================================================================\n\n// 3\n\nArray.prototype.groupBy = function(callback){\n    return this.reduce((acc, item) => {\n        let key = callback(item)\n        \n        if(!acc[key]){\n            acc[key] = [item]\n        } else {\n            acc[key].push(item)\n        }\n        \n        return acc\n    }, {})\n}\n\n//==============================================================================\n\n// 4\n\nfunction get(url, count = 5){\n    return (\n        fetch(url)\n        .then(response => {\n            return response.json()\n        })\n        .catch(() => {\n            if (count > 0){\n                return get(url, count-1)\n            } else {\n                trow new Error('Заданный урл недоступен')\n            }\n        })\n    )\n               \n}\n\n//==============================================================================\n\n// 5\n\nfunction camelToSnake(text){\n    let result = []\n    for (let i=0; i < text.length; i++){\n        if (i === 0) {\n            result.push(text[0].toLowerCase())\n        } else {\n            if (text[i] === text[i].toUpperCase()) {\n                result.push(`_${text[i].toLowerCase()}`)\n            }   else {\n                result.push(text[i])\n            }\n        }\n    }\n    return result.join('')\n}\n\n\n//==============================================================================\n\n// 6\n\nfunction callLimit(fn, limit, callback) {\n    let callCount = 0\n    \n    function limitedFn(...args){\n        callCount++\n        \n        if (callCount <= limit){\n            \n            return fn.applay(this, args)\n            \n            if (callCount === limit && callback){\n                \n                callback()\n            }\n        }\n        \n        return null\n        \n    }\n    \n    limitedFn.reset = () => {\n            callCount = 0\n    }\n    \n    return limitedFn\n}"
      },
      {
        "timestamp": "2024-10-30 13:20:30",
        "content": "2024-10-30 13:20:30\n Гладких Александр -> 2071074234:\nЯндекс (фантех) 1 этап\nзп: не обсуждалось                                                                                                                          вакансия: hr сама написала                                                                                                                      \n1. задача на контекст\n\nconst obj = {\n  value: '42',\n  foo: function () {\n    function type() {\n      return typeof this.value; \n      \n   ...",
        "full_content": "2024-10-30 13:20:30\n Гладких Александр -> 2071074234:\nЯндекс (фантех) 1 этап\nзп: не обсуждалось                                                                                                                          вакансия: hr сама написала                                                                                                                      \n1. задача на контекст\n\nconst obj = {\n  value: '42',\n  foo: function () {\n    function type() {\n      return typeof this.value; \n      \n    }\n    console.log(${42} is ${type()});\n  }\n}\n\nobj.foo()\n\nчто выведет консоль как исправить чтобы было 42 is string\n\n\n2. задача \n\nНеобходимо реализовать метод groupBy, расширяющий стандарные\nметоды массивов. Метод должен возвращать сгруппированную \nверсию массива - объект, в котором каждый ключ является результатом\nвыполнения переданой функции fn(arr[i]), а каждое значение - массивом\nсодержащим все элементы исходного массива с этим ключом\n\nArray.prototype.groupBy = function(callback) {\n  return this.reduce((acc, item) => {\n    let key = [callback(item)]\n    if(!acc[key]) {\n      acc[key] = [item]\n    } else {\n      acc[key].push(item)\n    }\n    return acc\n  }, {})\n}\n\nconst array1 = [\n  {id: 1},\n  {id: 1},\n  {id: 2}\n]\nconst fn = (item) => item.id;\n\nconsole.log(array1.groupBy(fn))\n\n3. Задача\n\nchekResult(url1, solution) и chekResult(url2, solution)  возвращают Promise<boolean>\nВыполните оба запроса и обработайте их результаты\nЕсли хотя бы один запрос возвращает ошибку, выведите в консоль сообщение 'error'.\nЕсли оба запроса выполняются успешно, но хотя бы один из них возвращает false, выведите сообщение 'fail'.\nЕсли оба запроса выполняются успешно и оба возвращают true, выведите сообщение 'success'.\nЕсли ни один из запросов не завершился за 1000 миллисекунд, выведите 'timeout'.\n\nPromise.all([\n  checkResult(url1, solution).catch(() => 'error'),\n  checkResult(url2, solution).catch(() => 'error')\n])\n  .then(results => {\n    if (results.includes('error')) {\n      console.log('error');\n    } else if (results.includes(false)) {\n      console.log('fail');\n    } else {\n      console.log('success');\n    }\n  })\n  .catch(() => {\n    console.log('timeout');\n  });\n\n// Добавление таймаута\nconst timeout = new Promise((_, reject) => \n  setTimeout(() => reject(new Error('timeout')), 1000)\n);\n\nPromise.race([\n  Promise.allSettled([\n    checkResult(url1, solution),\n    checkResult(url2, solution)\n  ]),\n  timeout\n])\n  .then(results => {\n    if (results === 'timeout') {\n      console.log('timeout');\n    } else {\n      const statuses = results.map(r => r.status === 'fulfilled' && r.value);\n      if (statuses.includes(false)) {\n        console.log('fail');\n      } else if (statuses.includes(true)) {\n        console.log('success');\n      } else {\n        console.log('error');\n      }\n    }\n  })\n  .catch(() => {\n    console.log('timeout');\n  });\n\n\n4. Задача\nНапишите функцию, которая принимает массив чисел и возвращает новый массив,\n в котором все нечетные числа отсортированы по возрастанию, сохраняя при этом\n свои оригинальные позиции среди четных чисел.\n\n\nfunction sortOdds(arr) {\n  // Извлекаем все нечетные числа из массива\n  const odds = arr.filter(num => num % 2 !== 0);\n\n  // Сортируем нечетные числа по возрастанию\n  odds.sort((a, b) => a - b);\n\n  // Создаем новый массив, заменяя нечетные числа отсортированными\n  return arr.map(num => (num % 2 !== 0 ? odds.shift() : num));\n}"
      },
      {
        "timestamp": "2024-10-29 10:27:52",
        "content": "2024-10-29 10:27:52\n Вадим -> 2071074234:\nКомпания: Яндекс \nЗп: не обсуждали \nВакансия: hr написала\nВопросы: \n- были задачи на promise\n- создать свой метод some для массива\n- создать функцию которая делает определенное количество перезапросов, когда запрос возвращался с ошибкой\n- задача на попрание this \nПараллельно спрашивал все что знаю по этим темам",
        "full_content": "2024-10-29 10:27:52\n Вадим -> 2071074234:\nКомпания: Яндекс \nЗп: не обсуждали \nВакансия: hr написала\nВопросы: \n- были задачи на promise\n- создать свой метод some для массива\n- создать функцию которая делает определенное количество перезапросов, когда запрос возвращался с ошибкой\n- задача на попрание this \nПараллельно спрашивал все что знаю по этим темам"
      },
      {
        "timestamp": "2024-10-25 14:54:40",
        "content": "2024-10-25 14:54:40\n Artyom Sozykin -> 2071074234:\nКомпания: Яндекс (2 этап технический) JFoRecruitment\nЗП: 250к\nВакансия: https://hh.ru/vacancy/108013960?hhtmFrom=employer_vacancies\n\nЗадача 1:\nУсловия такие, что нужно решить более быстрым алгоритмом чем O(n^2)\n\nconst prices = [k, 3, 5, 8, 7, 6];\nfunction getIcecream (amount)\n}\nconsole. log (getIcecream (10)); // [0, 31 или [ 1, 4] и т.п.\n\nРешение: через хешмап и перебор массива\n\nЗадача 2: \nНеобходимо написать компонент ProfilePage\n\nРешение: нап...",
        "full_content": "2024-10-25 14:54:40\n Artyom Sozykin -> 2071074234:\nКомпания: Яндекс (2 этап технический) JFoRecruitment\nЗП: 250к\nВакансия: https://hh.ru/vacancy/108013960?hhtmFrom=employer_vacancies\n\nЗадача 1:\nУсловия такие, что нужно решить более быстрым алгоритмом чем O(n^2)\n\nconst prices = [k, 3, 5, 8, 7, 6];\nfunction getIcecream (amount)\n}\nconsole. log (getIcecream (10)); // [0, 31 или [ 1, 4] и т.п.\n\nРешение: через хешмап и перебор массива\n\nЗадача 2: \nНеобходимо написать компонент ProfilePage\n\nРешение: написал через три useEffecta в первом onmount загрузил токен, второй useEffect делал запросы в api, где аргументом требовался только токен, третий useEffect в deps на получение userData делать запрос в ordersApi. Описал обработку ошибки через true / false\n\nВ конце были вопросы о том как можно по другому сделать:\n 1. Вынести каждый useEffect в отдельный хук\n 2. Написать в одном fetch запросе через then или await каждый из запросов в нужно порядке\n\nЧто если бы был throw new Error, как сделать страницу ErrorBoundary?"
      },
      {
        "timestamp": "2024-10-20 09:56:24",
        "content": "2024-10-20 09:56:24\n Artyom Sozykin -> 2071074234:\nКомпания: JFoRecruitment (Яндекс)\nВакансия https://hh.ru/vacancy/108013960?hhtmFrom=employer_vacancies\nЗП: 250к\nВопросы на первом собесе:\n1) Какие мета теги знаешь\n2) Для чего нужны метатеги\n3) Назови все стандартные хуки в React\nОстальные вопросы по платине\n\nВторой собес: \n1) Какие типы данных бывают\n2) Что какие еще есть коллекции, кроме map и set\n3) Какие методы запросов бывают\n4) По каким параметрам ограничивает CORS\n5) Задачка на event loop...",
        "full_content": "2024-10-20 09:56:24\n Artyom Sozykin -> 2071074234:\nКомпания: JFoRecruitment (Яндекс)\nВакансия https://hh.ru/vacancy/108013960?hhtmFrom=employer_vacancies\nЗП: 250к\nВопросы на первом собесе:\n1) Какие мета теги знаешь\n2) Для чего нужны метатеги\n3) Назови все стандартные хуки в React\nОстальные вопросы по платине\n\nВторой собес: \n1) Какие типы данных бывают\n2) Что какие еще есть коллекции, кроме map и set\n3) Какие методы запросов бывают\n4) По каким параметрам ограничивает CORS\n5) Задачка на event loop\n6) Задача на переписывание todo c классового компонента на функциональный \n\nОбратная связь 23.10 будет"
      },
      {
        "timestamp": "2024-10-19 18:52:30",
        "content": "2024-10-19 18:52:30\n memphis -> 2071074234:\n-компния IBS\n-вакансия: в лс написала hr\n-зп: от 200\n\n-Вопросы\n1) == vs ===\n2) true + 1 + \"909\" что будет?\n3) \"909\" + true + 1 что будет?\n4) var let const - чем отличаются друг от друга\n5) отличая function declaration от function arrow\n6) for in и for of что это и как работают?\n7) что знаешь про prototype?\n8) как добавить метод в прототип?\n-Лайв код\n не сохранился яндекс код а вручную долго все переписывать(, все есть на записи\n\n-Успех собеса: 🟢\n-Фидбэ...",
        "full_content": "2024-10-19 18:52:30\n memphis -> 2071074234:\n-компния IBS\n-вакансия: в лс написала hr\n-зп: от 200\n\n-Вопросы\n1) == vs ===\n2) true + 1 + \"909\" что будет?\n3) \"909\" + true + 1 что будет?\n4) var let const - чем отличаются друг от друга\n5) отличая function declaration от function arrow\n6) for in и for of что это и как работают?\n7) что знаешь про prototype?\n8) как добавить метод в прототип?\n-Лайв код\n не сохранился яндекс код а вручную долго все переписывать(, все есть на записи\n\n-Успех собеса: 🟢\n-Фидбэк от hr: позвали на созвон с руководителем\n\nзапись: https://youtu.be/PBtR9CuK6Xc"
      },
      {
        "timestamp": "2024-10-11 13:08:27",
        "content": "2024-10-11 13:08:27\n Михаил -> 2071074234:\nЯндекс (фАнтех) 2 секция (алгосы)\nвакансия - HR сама написала\nпо факту нужно было самостоятельно реализовать addEventListener и dispatchEvent",
        "full_content": "2024-10-11 13:08:27\n Михаил -> 2071074234:\nЯндекс (фАнтех) 2 секция (алгосы)\nвакансия - HR сама написала\nпо факту нужно было самостоятельно реализовать addEventListener и dispatchEvent"
      },
      {
        "timestamp": "2024-10-09 13:32:54",
        "content": "2024-10-09 13:32:54\n Timofei Syromiatnikov -> 2071074234:\n— Название: Яндекс (Multitrack, 1 этап JS задачи)\n— Вакансия: написала hr\n— Вопросов не было\n— Задачи (по всем задачам нужно рассуждать почему именно такой ответ, что ты думаешь, почему именно такое решение хочешь сделать. Обработать всевозможные ошибки, или хотябы обсудить потенциальные):\n\n1) Надо сделать функцию get, которая принимает в себя объект и строку. И отдает найденное значение. Строкой является путь ключей через точку, по котор...",
        "full_content": "2024-10-09 13:32:54\n Timofei Syromiatnikov -> 2071074234:\n— Название: Яндекс (Multitrack, 1 этап JS задачи)\n— Вакансия: написала hr\n— Вопросов не было\n— Задачи (по всем задачам нужно рассуждать почему именно такой ответ, что ты думаешь, почему именно такое решение хочешь сделать. Обработать всевозможные ошибки, или хотябы обсудить потенциальные):\n\n1) Надо сделать функцию get, которая принимает в себя объект и строку. И отдает найденное значение. Строкой является путь ключей через точку, по которым мы хотим дойти до значения в объекте.\nconst get = (obj, path) => {}\n\nconst obj = {\n  a: 'f',\n  b: {\n    k: {\n      m: '123'\n    }\n  },\n  c: {\n    d: '3'\n  },\n  e: ['111, '222', '333']\n}\n\nconsole.log(get(obj, 'a') // f\nconsole.log(get(obj, 'b.k.m') //'123'\nconsole.log(get(obj, 'c.d.c') // undefined\nconsole.log(get(obj, 'e.1') // '111'\n2) Что выведет, почему, и как пофиксить (чтобы -2 не выводился).\nvar i = 10;\nvar array = []\n\nwhile(i--) {\n  array.push(function() {\n    return i + i\n  })\n}\n\nconsole.log(array[0]()) // -2\nconsole.log(array[1]()) // -2\n3) У нас есть синхронная функция asyncAuth, которая принимает в себя колбек, и отдает ему 2 аргумента: 1 - потенциальная ошибка (если нет вернет undefined), 2 - актуальные данные, если ошибки нет.\n1 Условие:  напиши функцию auth, которая выполняет функцию asyncAuth, и возвращает Promise с актуальными данными или ошибкой.\n2 Условие: напиши функцию tryAuth(n), которая принимает 1 аргумент, являющимся числом попыток выполнения auth функции если она вернула ошибку при первом выполнении.\nfunction asyncAuth(callback) {...}"
      },
      {
        "timestamp": "2024-10-03 13:28:47",
        "content": "2024-10-03 13:28:47\n Михаил -> 2071074234:\nЯндекс (фАнтех) 1 секция (задачки с кодеварс)\nвакансия - HR сама написала\nзп 200к",
        "full_content": "2024-10-03 13:28:47\n Михаил -> 2071074234:\nЯндекс (фАнтех) 1 секция (задачки с кодеварс)\nвакансия - HR сама написала\nзп 200к"
      },
      {
        "timestamp": "2024-09-26 16:58:55",
        "content": "2024-09-26 16:58:55\n Dispersioned -> 2071074234:\nЯндекс маркет 2 этап (алгоритмы)\nЗП: >320net\nЗадачи: на фото, решения на записи\nУспех: успешно ✅\nФидбек: https://t.me/c/2071074234/489/67496",
        "full_content": "2024-09-26 16:58:55\n Dispersioned -> 2071074234:\nЯндекс маркет 2 этап (алгоритмы)\nЗП: >320net\nЗадачи: на фото, решения на записи\nУспех: успешно ✅\nФидбек: https://t.me/c/2071074234/489/67496"
      },
      {
        "timestamp": "2024-09-24 11:43:27",
        "content": "2024-09-24 11:43:27\n Dispersioned -> 2071074234:\nЯндекс маркет 1 этап (vanilla js)\nСсылка на вакансию: нет, по рефералке\nЗП: >320net\nЗадача: спроектировать реактивный атом. По мере выполнения задачи условия дополняются\nУсловие 1: на картинке\nУсловие 2: теперь атом должен принимать и функции-инициализаторы. Перерасчёт такого атома происходит при вызове\natom.update()\nУсловие 3. Функции могут быть асинхронными (aka Promise).\nУсловие 4. Функциональные или promise атомы получают в параметры функции-и...",
        "full_content": "2024-09-24 11:43:27\n Dispersioned -> 2071074234:\nЯндекс маркет 1 этап (vanilla js)\nСсылка на вакансию: нет, по рефералке\nЗП: >320net\nЗадача: спроектировать реактивный атом. По мере выполнения задачи условия дополняются\nУсловие 1: на картинке\nУсловие 2: теперь атом должен принимать и функции-инициализаторы. Перерасчёт такого атома происходит при вызове\natom.update()\nУсловие 3. Функции могут быть асинхронными (aka Promise).\nУсловие 4. Функциональные или promise атомы получают в параметры функции-инициализатора колбэк getter. Если мы вызываем внутри функции этот getter, то атом автоматически пересчитывается, без вызова\natom.update()\n\nПримечание: интервьювер опоздал минут на 10 и заботливо спиздил их у тайминга собеса)\nУспех: успешно, позвали на алгосы\nФидбек: https://t.me/c/2071074234/489/65809"
      },
      {
        "timestamp": "2024-09-24 04:05:46",
        "content": "2024-09-24 04:05:46\n Анжелика -> 2071074234:\n- Яндекс Маркет 2й тех этап Алгоритмы\n- 200-220\n- было 2 обязательные задачки( а дальше бы дали если нужен грейд выше)\nважно словами сначала рассказать как будешь делать, оценить сложность(каждое действие в задачке) и приступать. Алгоритм потребовался только в сортировке.\n- успех: ✅",
        "full_content": "2024-09-24 04:05:46\n Анжелика -> 2071074234:\n- Яндекс Маркет 2й тех этап Алгоритмы\n- 200-220\n- было 2 обязательные задачки( а дальше бы дали если нужен грейд выше)\nважно словами сначала рассказать как будешь делать, оценить сложность(каждое действие в задачке) и приступать. Алгоритм потребовался только в сортировке.\n- успех: ✅"
      },
      {
        "timestamp": "2024-09-19 12:12:36",
        "content": "2024-09-19 12:12:36\n Intetsu -> 2071074234:\n-Яндекс маркет 1ый тех этап\n-220\n-1 задачка\n- фидбек жду",
        "full_content": "2024-09-19 12:12:36\n Intetsu -> 2071074234:\n-Яндекс маркет 1ый тех этап\n-220\n-1 задачка\n- фидбек жду"
      },
      {
        "timestamp": "2024-09-14 16:04:39",
        "content": "2024-09-14 16:04:39\n Анжелика -> 2071074234:\n- Яндекс маркет 1ый тех этап\n- 200-220\n- была 1 задачка, менялись тесты и добавлялись условия. Сначала то что на скрине, потом добавить возможность передавать функцию, потом промис, последнюю не решила\n- успех ✅",
        "full_content": "2024-09-14 16:04:39\n Анжелика -> 2071074234:\n- Яндекс маркет 1ый тех этап\n- 200-220\n- была 1 задачка, менялись тесты и добавлялись условия. Сначала то что на скрине, потом добавить возможность передавать функцию, потом промис, последнюю не решила\n- успех ✅"
      },
      {
        "timestamp": "2024-09-10 14:43:09",
        "content": "2024-09-10 14:43:09\n Denis -> 2071074234:\nНазвание: Яндекс.такси\nВакансия: написала hr\nЗП: 300+\nВопросы:\nАлгоритмы only.\n\n1. Написать функцию join через rest параметры в аргументах\nfunction strjoin(separator, ...strings) {\n  let result = ''; // Инициализируем пустую строку\n\n  for (let i = 0; i < strings.length; i++) {\n    if (i > 0) {\n      result += separator; // Добавляем разделитель перед каждым элементом, начиная со второго\n    }\n    result += strings[i]; // Добавляем текущий элемент\n  }\n\n  ...",
        "full_content": "2024-09-10 14:43:09\n Denis -> 2071074234:\nНазвание: Яндекс.такси\nВакансия: написала hr\nЗП: 300+\nВопросы:\nАлгоритмы only.\n\n1. Написать функцию join через rest параметры в аргументах\nfunction strjoin(separator, ...strings) {\n  let result = ''; // Инициализируем пустую строку\n\n  for (let i = 0; i < strings.length; i++) {\n    if (i > 0) {\n      result += separator; // Добавляем разделитель перед каждым элементом, начиная со второго\n    }\n    result += strings[i]; // Добавляем текущий элемент\n  }\n\n  return result; // Возвращаем итоговую строку\n}\n\n2.  Написать функцию имитирующую задержку в мс. Почему она не факт что выполниться ровно через заданное время?\nfunction sleep(duration) {\n  // Возвращаем новый промис, который разрешается после задержки\n  return new Promise((resolve) => {\n    // setTimeout вызывает resolve после заданного количества миллисекунд (duration)\n    setTimeout(resolve, duration);\n  });\n}\n\nconst startTime = Date.now(); // Сохраняем текущее время в миллисекундах\n\nsleep(100) // Задаем задержку в 100 миллисекунд\n  .then(() => {\n    // Когда промис разрешится, вычисляем прошедшее время\n    console.log(Date.now() - startTime); // Выводим разницу времени, которая должна быть около 100 миллисекунд\n  });\n3. Написать функцию groupBy для массива\n// Реализуем метод groupBy для массива\nArray.prototype.groupBy = function(fn) {\n  return this.reduce((result, item) => {\n    // Вычисляем ключ с помощью переданной функции\n    const key = fn(item);\n    \n    // Если ключа еще нет в объекте, создаем массив для этого ключа\n    if (!result[key]) {\n      result[key] = [];\n    }\n    \n    // Добавляем элемент в соответствующую группу\n    result[key].push(item);\n    \n    return result;\n  }, {});\n};\n4.  Написать функцию, которая делает фетч 5 раз, потом кидает ошибку. Можно пользоваться только Promise api, сделать через рекурсию\nfunction fetchWithRetry(url, attempts) {\n  return new Promise((resolve, reject) => {\n    const attemptFetch = (n) => {\n      fetch(url)\n        .then((response) => {\n          if (!response.ok) {\n            // Если ответ не успешен, создаем ошибку\n            throw new Error(`HTTP error! Status: ${response.status}`);\n          }\n          return resolve(response); // Если успешен, возвращаем ответ\n        })\n        .catch((error) => {\n          if (n === 1) {\n            return reject(error); // Если попытки закончились, отклоняем Promise\n          }\n          console.log(`Attempt ${attempts - n + 1} failed. Retrying...`);\n          attemptFetch(n - 1); // Повторяем запрос с уменьшенным количеством попыток\n        });\n    };\n\n    attemptFetch(attempts); // Запускаем с первой попытки\n  });\n}\n\n// Пример использования:\nfetchWithRetry('https://api.example.com/data', 3)\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error('Request failed:', error));\n\n5. Написать функцию, которая очищает обьект или массив от falsy значений и возвращает новый (без мутации)\nfunction removeFalsyValues(obj) {\n  // Создаем новый объект, не мутируя исходный\n  const newObj = Array.isArray(obj) ? [] : {};\n  \n  // Проходим по всем ключам исходного объекта\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const value = obj[key];\n      \n      // Если значение — объект, рекурсивно очищаем его\n      if (typeof value === 'object' && value !== null) {\n        const cleanedValue = removeFalsyValues(value);\n        \n        // Если очищенный объект или массив не пустой, добавляем его в новый объект\n        if (Array.isArray(cleanedValue) ? cleanedValue.length > 0 : Object.keys(cleanedValue).length > 0) {\n          newObj[key] = cleanedValue;\n        }\n      } \n      // Если значение не является \"falsy\", добавляем его в новый объект\n      else if (value) {\n        newObj[key] = value;\n      }\n    }\n  }\n  \n  return newObj;\n}\n\n// Пример использования\nconst input = {\n  a: 1,\n  b: false,\n  c: {\n    d: 0,\n    e: {\n      f: '',\n      g: 2\n    },\n    h: undefined\n  },\n  i: null,\n  j: 'hello'\n};\n\nconst result = removeFalsyValues(input);\nconsole.log(result);\n// Вывод: { a: 1, c: { e: { g: 2 } }, j: 'hello' }"
      },
      {
        "timestamp": "2024-09-05 14:16:59",
        "content": "2024-09-05 14:16:59\n Бахтияр -> 2071074234:\n- Название: Яндекс\n- Вакансия: https://t.me/c/2071074234/616/58481\n- ЗП: 280К\n- Этап: 1\n- Задача:\nСоздать атом\n\n// Функция для создания атома состояния\nconst atom = (initialValue) => {\n  let state; // Переменная для хранения текущего состояния\n  let listeners = []; // Массив для хранения функций-слушателей\n\n  // Проверка, является ли начальное значение функцией\n  if (typeof initialValue === \"function\") {\n    state = initialValue(); // Вызываем функцию ...",
        "full_content": "2024-09-05 14:16:59\n Бахтияр -> 2071074234:\n- Название: Яндекс\n- Вакансия: https://t.me/c/2071074234/616/58481\n- ЗП: 280К\n- Этап: 1\n- Задача:\nСоздать атом\n\n// Функция для создания атома состояния\nconst atom = (initialValue) => {\n  let state; // Переменная для хранения текущего состояния\n  let listeners = []; // Массив для хранения функций-слушателей\n\n  // Проверка, является ли начальное значение функцией\n  if (typeof initialValue === \"function\") {\n    state = initialValue(); // Вызываем функцию для получения начального состояния\n    // Проверка на null\n    if (state === null) {\n      throw new Error(\"Возвращаемое значение не может быть null.\");\n    }\n  } else {\n    // Проверка на промис\n    if (initialValue instanceof Promise) {\n      throw new Error(\"it is func or promise\");\n    }\n    state = initialValue; // Присваиваем начальное значение\n  }\n\n  return {\n    // Метод для чтения текущего состояния\n    read() {\n      return state;\n    },\n    // Метод для обновления состояния\n    update() {\n      // Если начальное значение — функция, снова вычисляем состояние\n      if (typeof initialValue === \"function\") {\n        state = initialValue();\n        // Проверка на null\n        if (state === null) {\n          throw new Error(\"Возвращаемое значение не может быть null.\");\n        }\n      }\n      // Уведомляем всех подписчиков об изменении состояния\n      listeners.forEach(listener => listener(state));\n    },\n    // Метод для подписки на изменения состояния\n    subscribe(listener) {\n      listeners.push(listener); // Добавляем слушателя в массив\n      // Возвращаем функцию для отписки\n      return () => {\n        listeners = listeners.filter(l => l !== listener); // Удаляем слушателя\n      };\n    }\n  };\n};\n\n// Объект с постами\nconst POSTS = {\n  42: { id: 42, title: 'rerum perferendis error quia ut eveniet' },\n  43: { id: 43, title: 'tempore ut sint quis recusandae' },\n};\n\n// Создаем атом с начальным значением 42\nconst simpleAtom = atom(42);\n\n// Создаем атом, вычисляемый на основе результата функции\nconst titleAtom = atom(() => {\n  const simpleAtomValue = simpleAtom.read(); // Читаем текущее значение simpleAtom\n  const title = POSTS[simpleAtomValue]?.title; // Получаем заголовок поста по ID\n  // Проверка на null\n  if (!title) {\n    throw new Error(\"Возвращаемое значение не может быть null.\");\n  }\n  return title; // Возвращаем заголовок\n});\n\n// Выводим текущее значение заголовка\nconsole.log(titleAtom.read()); // Вывод: 'rerum perferendis error quia ut eveniet'\n\n// Обновляем значение simpleAtom на 43\nsimpleAtom.update(43);\n\n// Обновляем значение titleAtom на основе нового значения simpleAtom\ntitleAtom.update(); \n\n// Выводим обновленный заголовок\nconsole.log(titleAtom.read()); // Вывод: 'tempore ut sint quis recusandae'"
      },
      {
        "timestamp": "2024-09-05 12:40:14",
        "content": "2024-09-05 12:40:14\n аыеъа -> 2071074234:\n- Название: Linked Helper, финальный этап\n- ЗП: от 4000$+\n- Видео:  https://disk.yandex.ru/d/-gA5NjLIJ8qcZw",
        "full_content": "2024-09-05 12:40:14\n аыеъа -> 2071074234:\n- Название: Linked Helper, финальный этап\n- ЗП: от 4000$+\n- Видео:  https://disk.yandex.ru/d/-gA5NjLIJ8qcZw"
      },
      {
        "timestamp": "2024-08-10 13:00:20",
        "content": "2024-08-10 13:00:20\n Vladimir Latyshev -> 2071074234:\n- Яндекс\n- вакансия - сами нашли\n- ЗП - не обсуждали\nЗАДАЧИ:\n\nзадача 1\n\n// что выведется в консоль\n\nvar n = 1;\n\nfunction f(n) {\n    n = 3;\n}\nf(n);\n\nconsole.log(n); // ??\n\n//\n//\n\nvar obj = { a: 1 };\n\nfunction f1(o) {\n    o.a = 5;\n}\n\nf1(obj);\n\nconsole.log(obj); // ??\n\n//\n//\n\nvar obj = { a: 1 };\n\nfunction f2(o) {\n    o = { hello: 1 };\n}\n\nf2(obj);\n\nconsole.log(obj); // ??\n\n\nзадача 2\n\n/**\n * Необходимо написать асинхронную функцию,\n * которая буде...",
        "full_content": "2024-08-10 13:00:20\n Vladimir Latyshev -> 2071074234:\n- Яндекс\n- вакансия - сами нашли\n- ЗП - не обсуждали\nЗАДАЧИ:\n\nзадача 1\n\n// что выведется в консоль\n\nvar n = 1;\n\nfunction f(n) {\n    n = 3;\n}\nf(n);\n\nconsole.log(n); // ??\n\n//\n//\n\nvar obj = { a: 1 };\n\nfunction f1(o) {\n    o.a = 5;\n}\n\nf1(obj);\n\nconsole.log(obj); // ??\n\n//\n//\n\nvar obj = { a: 1 };\n\nfunction f2(o) {\n    o = { hello: 1 };\n}\n\nf2(obj);\n\nconsole.log(obj); // ??\n\n\nзадача 2\n\n/**\n * Необходимо написать асинхронную функцию,\n * которая будет \"спать\" заданное количество миллисекунд,\n * а потом успешно завершаться\n */\n\nfunction sleep(duration) {\n}\n\nconst startTime = Date.now();\n\nsleep(100)\n    .then(() => console.log(Date.now() - startTime));\n// Выведет примерно 100\n\n//\n//\n//\n//  РЕШЕНИЕ\n\nfunction sleep(duration) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n\nзадача 3\n\nimport asyncAuth from '.';\n\n/**\n * Функция `asyncAuth(callback)` принимает callback, в который может\n * быть передана ошибка (первым аргументом) и данные\n * с бэкенда (вторым аргументом).\n *\n * Вам нужно реализовать функцию `auth()`,\n * которая вызывает `asyncAuth()`, но возвращает Promise.\n *\n * @returns {Promise}\n */\nfunction auth() {\n    asyncAuth((error, data) => {});\n}\n\n//  решение\n\nfunction tryAuth(n) {\n  return new Promise((resolve, reject) => {\n    function attempt(remainingAttempts) {\n      auth()\n        .then(resolve)\n        .catch((error) => {\n          if (remainingAttempts === 0) {\n            reject(error);\n          } else {\n            attempt(remainingAttempts - 1);\n          }\n        });\n    }\n    \n    attempt(n);\n  });\n}\n\n\nзадача 4 - дополнение к предыдущей задаче\n\n/**\n * Функция `tryAuth()` использует `auth()` и, в случае ошибки,\n * совершает N дополнительных попыток.\n *\n * @returns {Promise}\n */\nfunction tryAuth(n) {\n}\n// решение\n\nfunction tryAuth(n) {\n  \n  let res;\n  let isError = true;\n  \n  for (let i = 0; i < n; i++) {\n  \n    res = await auth();\n    \n    res\n    .then((res) => { isError = false; })\n    .catch((error) => { isError = true; })\n    \n    if (!isError) return res;    \n  }\n  \n  return res; \n}\n\nзадача 5\n\n/**\n * Написать декоратор для функции, который ограничивает число вызовов.\n *\n * callLimit(fn, count[, callback]), принимает следующие аргументы:\n * fn - функция, которую декорируем;\n * limit - максимальное число вызовов;\n * callback - вызывается, когда совершен последний вызов. Опционально.\n * У вызываемой функции должен быть метод для перезагрузки счётчика в начальное положение.\n */\n\nfunction callLimit(fn, limit, callback) {\n    // Тут что-то написать\n    \n    let count = 0;\n    let result;\n    \n    const resFunc = function (...args) {\n      \n      if (count < limit) {\n        count++;\n        result = fn(...args);\n        \n        ( count === limit && !!callback && callback() )\n        \n        return result;      \n      } else {\n        return undefined;\n      }\n    }\n    \n    resFunc.reset = function () {\n      count = 0;\n    }\n    \n    return resFunc;\n    \n}\n\nfunction log(title, message) {\n    console.log(title + ': ' + message);\n}\n\nvar logLimited = callLimit(log, 3);\nlogLimited('title1', 'desc');\n// Console output:\n// title1: desc\n\nlogLimited('title2', 'desc');\n// Console output:\n// title2: desc\n\nlogLimited('title3', 'desc');\n// Console output:\n// title3: desc\n\nlogLimited('title4', 'desc'); // Этот не сработает\n// Console output:\n// undefined\n\nlogLimited.reset(); // Перезагрузили счётчик\n\nlogLimited('title5', 'desc');\n// Console output:\n// title5: desc\n\nlogLimited('title6', 'desc');\n// Console output:\n// title6: desc\n\nlogLimited('title7', 'desc');\n// Console output:\n// title7: desc\n\nvar logLimited2 = callLimit(log, 2, () => console.log('finish'));\nlogLimited2('foo', 'bar');\n// Console output:\n// foo: bar\n\nlogLimited2('foo2', 'bar');\n// Console output:\n// foo2: bar\n// finish"
      },
      {
        "timestamp": "2024-07-30 14:49:14",
        "content": "2024-07-30 14:49:14\n Сергей Туманцев -> 2071074234:\nЯндекс\nHR сама написала\n250-280к оклад\nпригласили на следующий этап (это был второй, первый - скрининг)",
        "full_content": "2024-07-30 14:49:14\n Сергей Туманцев -> 2071074234:\nЯндекс\nHR сама написала\n250-280к оклад\nпригласили на следующий этап (это был второй, первый - скрининг)"
      },
      {
        "timestamp": "2024-07-29 10:26:00",
        "content": "2024-07-29 10:26:00\n Евгений Лямин -> 2071074234:\n— Яндекс первый этап\n— не обсуждали\n— hr написал\nзадачи:\n1. из скрина задание. изначально получаем только примитивы насколько помню\n2. расширить если мы получаем на вход функцию \n3. расширить если мы получем промис",
        "full_content": "2024-07-29 10:26:00\n Евгений Лямин -> 2071074234:\n— Яндекс первый этап\n— не обсуждали\n— hr написал\nзадачи:\n1. из скрина задание. изначально получаем только примитивы насколько помню\n2. расширить если мы получаем на вход функцию \n3. расширить если мы получем промис"
      },
      {
        "timestamp": "2024-07-24 14:05:59",
        "content": "2024-07-24 14:05:59\n AM -> 2071074234:\nЯндекс [второй этап]\n\n— Планировалось 2 задачи, успел только одну\n\n/**\n * Банкомат.\n *\n * В банкомате есть купюры — 50, 100, 500, 1000, 5000 руб. Номиналы купюр только такие, они не меняются\n * и доступны в константе nominals.\n * Есть ограничение на количество каждой из купюр (аргумент limits), его нужно держать в актуальном\n * состоянии (мутировать).\n * Нужно вернуть купюры и их количество, которыми можно выдать запрашиваемую сумму, в виде \n * объекта в фо...",
        "full_content": "2024-07-24 14:05:59\n AM -> 2071074234:\nЯндекс [второй этап]\n\n— Планировалось 2 задачи, успел только одну\n\n/**\n * Банкомат.\n *\n * В банкомате есть купюры — 50, 100, 500, 1000, 5000 руб. Номиналы купюр только такие, они не меняются\n * и доступны в константе nominals.\n * Есть ограничение на количество каждой из купюр (аргумент limits), его нужно держать в актуальном\n * состоянии (мутировать).\n * Нужно вернуть купюры и их количество, которыми можно выдать запрашиваемую сумму, в виде \n * объекта в формате, аналогичном объекту лимитов.\n * При прочих равных возможностях выдать одну и ту же сумму разными купюрами приоритет отдаётся крупным.\n * Если выдать запрашиваемую сумму не получится в принципе (сумма не кратна минимальному номиналу) —\n * выбросить ошибку 'Incorrect value'.\n * Если в банкомате недостаточно нужных купюр — выбросить ошибку 'Not enough money'.\n*/\n\nconst nominals = [5000, 1000, 500, 100, 50];\n\nfunction atm(sum, limits, nominals) {\n    const minNominal = Math.min(...nominals);\n    let lim = {...limits}; \n\n    if(sum % minNominal !== 0) {\n        return 'Error';\n    }\n\n    const res = {};\n\n    for(let den of nominals) {\n        while(sum >= den && lim[den] > 0) {\n            sum -= den;\n            lim[den]--;\n            res[den] = (res[den] || 0) + 1;\n        }\n    }\n\n    if(sum !== 0) {\n        return 'Error: Not enough money';\n    }\n\n    Object.assign(limits, lim);\n    return res;\n}\n\nfunction check(sum, limits, expected) {\n    let res;\n    try {\n        res = atm(sum, limits, nominals);\n    } catch (e) {\n        res = e;\n    }\n    if (typeof expected === \"string\") {\n        console.assert(res.toString() === expected, `Expected error ${expected}, got ${res.toString()}`);\n    } else {\n        console.assert(JSON.stringify(res) === JSON.stringify(expected), `Expected result %o, got result %o`, expected, res);\n    }\n}\n\nfunction test() {\n    // пример: в банкомате 9200 следующими номиналами\n    const limits = { 5000: 0, 1000: 6, 500: 5, 100: 5, 50: 4 }\n\n    // Далее последовательные вызова функции atm с одним и тем же объектом limits\n    check(1250, limits, { 1000: 1, 100: 2, 50: 1 })    // \n    check(1000000, limits, 'Error: Not enough money') // 'Error: Not enough money'\n    check(400, limits, { 100: 3, 50: 2 })\n    console.log(\"Tests finished\");\n}\n\nconsole.clear();\ntest();"
      },
      {
        "timestamp": "2024-07-22 00:24:04",
        "content": "2024-07-22 00:24:04\n AM -> 2071074234:\n— Яндекс\n— HR сама написала\n— Озвученная мной ЗП: 230-300к\n— Результат: позвали на 2 этап\n— Сразу начали с задач\n\nconst ownGet = (obj, path) => {\n    let result = obj;\n    const keys = path.split(\".\");\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (result) {\n        result = result[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return result;\n  };\n\n  console.log(ownGet({ a: { b: { c: 777 } } }, \"a.b.c\"),...",
        "full_content": "2024-07-22 00:24:04\n AM -> 2071074234:\n— Яндекс\n— HR сама написала\n— Озвученная мной ЗП: 230-300к\n— Результат: позвали на 2 этап\n— Сразу начали с задач\n\nconst ownGet = (obj, path) => {\n    let result = obj;\n    const keys = path.split(\".\");\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (result) {\n        result = result[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return result;\n  };\n\n  console.log(ownGet({ a: { b: { c: 777 } } }, \"a.b.c\"), \"getter\");\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction callLimit(fn, limit, callback) {\n    let counter = 0;\n\n    function limited(...args) {\n        if (counter < limit) {\n            counter++;\n            const result = fn(...args);\n            \n            if (counter === limit && callback) {\n                callback();\n            }\n            \n            return result;\n        }\n    }\n\n    limited.reset = function() {\n        counter = 0;\n    };\n\n    return limited;\n}\n\nfunction auth() {\n    return new Promise((resolve, reject) => asyncAuth((error, data) => {\n        if(error){\n            reject(error);\n        }\n\n        resolve(data);\n    }));\n}\n\nasync function tryAuth(retriesLeft = 3) {\n  try {\n    return await auth();\n  } catch (err) {\n    if (retriesLeft <= 0) {\n      throw err;\n    }\n\n    return tryAuth(retriesLeft - 1);\n  }\n}\n\nconst compose = (...funcs) => (...args) => {\n    return funcs.reduceRight((acc, fn) => [fn(...acc)], args)[0];\n};\n\nfunction isMonotonic(numbers) {\n    if (numbers.length <= 1) return true;\n\n    let increasing = true;\n    let decreasing = true;\n\n    for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] > numbers[i - 1]) {\n            decreasing = false;\n        }\n        if (numbers[i] < numbers[i - 1]) {\n            increasing = false;\n        }\n    }\n\n    return increasing || decreasing;\n}"
      },
      {
        "timestamp": "2024-07-19 05:38:33",
        "content": "2024-07-19 05:38:33\n Tonidevs -> 2071074234:\nЯНДЕКС ГО\n— сами написали\n— ЗП до 300к\n\nВОПРОСОВ - по задачам какая будет сложность алгоритма и подобные\n\n\nfunction solution(connect, render) {\n    let messages = new Map();\n    let lastRenderedId = 0;\n\n    connect((msg) => {\n        messages.set(msg.id, msg);\n\n        while (messages.has(lastRenderedId + 1)) {\n            lastRenderedId++;\n            render(messages.get(lastRenderedId));\n            messages.delete(lastRenderedId); // Удаляем сообще...",
        "full_content": "2024-07-19 05:38:33\n Tonidevs -> 2071074234:\nЯНДЕКС ГО\n— сами написали\n— ЗП до 300к\n\nВОПРОСОВ - по задачам какая будет сложность алгоритма и подобные\n\n\nfunction solution(connect, render) {\n    let messages = new Map();\n    let lastRenderedId = 0;\n\n    connect((msg) => {\n        messages.set(msg.id, msg);\n\n        while (messages.has(lastRenderedId + 1)) {\n            lastRenderedId++;\n            render(messages.get(lastRenderedId));\n            messages.delete(lastRenderedId); // Удаляем сообщение после отображения\n        }\n\n        // Логирование или проверка на количество сообщений в Map, если необходимо\n        if (messages.size > 1000) {\n            console.warn(\"Более 1000 сообщений ожидают отображения\");\n        }\n    });\n}\n\n\nfunction printFiles(data) {\n    const stack = [{ node: data, depth: 0 }];\n    while (stack.length > 0) {\n        const { node, depth } = stack.pop();\n        const prefix = ' '.repeat(depth * 4); // Создаем отступ, каждый уровень вложенности увеличивает отступ на 4 пробела\n\n        console.log(`${prefix}${node.name}`);\n\n        if (node.children) {\n            for (let i = node.children.length - 1; i >= 0; i--) {\n                stack.push({ node: node.children[i], depth: depth + 1 });\n            }\n        }\n    }\n}\n\n// Тестирование функции с предоставленными данными\nconst data = {\n    name: 'folder',\n    children: [\n        { name: 'file1.txt' },\n        { name: 'file2.txt' },\n        {\n            name: 'images',\n            children: [\n                { name: 'image.png' },\n                {\n                    name: 'vacation',\n                    children: [\n                        { name: 'crocodile.png' },\n                        { name: 'penguin.png' }\n                    ]\n                }\n            ]\n        },\n        { name: 'shopping-list.pdf' }\n    ]\n};\n\nprintFiles(data);\n\n\n/**\n * throttle.\n *\n * Напишите функцию throttle(fn, delay, ctx) – «тормозилку», которая возвращает обёртку,\n * вызывающую fn не чаще, чем раз в delay миллисекунд.\n * В качестве контекста исполнения используется ctx.\n * Первый вызов fn всегда должен быть синхронным.\n * Если игнорируемый вызов оказался последним, то он должен выполниться.\n */\n\n// пример для delay === 100\n// . - вызовы throttledFn\n// ! - вызовы fn\n//................\n//!         !          !\n//0ms      100ms      200ms\n//.    .         .\n//!         !          !\n//0ms      100ms      200ms\n\nfunction throttle(fn, delay, ctx) {\n    let timeoutId;\n    let lastCallTime = 0;\n\n    return function(...args) {\n        const now = Date.now()\n        const remainigTime = delay - (now - lastCallTime);\n\n        if(remainigTime <= 0) {\n            fn.apply(ctx, args)\n            lastCallTime = now\n            timeoutId = null;\n        } if(timeoutId) {\n            clearTimeout(timeoutId)\n            timeoutId = null;\n        } else if(!timeoutId) {\n            timeoutId = setTimeout(() => {\n                fn.apply(ctx, args)\n                lastCallTime = Date.now()\n                timeoutId = null;\n            }, remainigTime)\n            // console.log(remainigTime)\n        }\n    }\n}\n\nfunction test() {\n    const start = Date.now();\n\n    function log(text) {\n        const msPassed = Date.now() - start;\n        console.log(`${msPassed}: ${this.name} logged ${text}`);\n    }\n\n    const throttled = throttle(log, 100, { name: 'me' });\n\n    setTimeout(() => throttled('m'), 0);\n    setTimeout(() => throttled('mo'), 22);\n    setTimeout(() => throttled('mos'), 33);\n    setTimeout(() => throttled('mosc'), 150);\n    setTimeout(() => throttled('moscow'), 400);\n    //   0ms: me logged m\n    // 100ms: me logged mos\n    // 200ms: me logged mosc\n    // 400ms: me logged moscow\n}\n\nconsole.clear()\ntest()"
      },
      {
        "timestamp": "2024-07-10 03:14:31",
        "content": "2024-07-10 03:14:31\n Tonidevs -> 2071074234:\nЯНДЕКС ГО 2 этап\n— сами написали\n— ЗП: 200-300 по результатам теха\n— комментарий: интервьюер крутой, результат плохой. успехом будет зависеть от скорости мысли и количества решенных задач\n\nВОПРОСЫ: нет, сразу задачи\n\nЗАДАЧИ: \n- что будет в консоли\nconst a = {\n  name: 'a',\n  foo: function () {\n    console.log(this.name);\n  }\n};\n\na.foo(); // 1 a\n\nconst bar = a.foo;\nbar(); // 2 undefined\n\nconst b = {\n  name: 'b'\n};\nb.foo = a.foo;\nb.foo(); // 3 b\n\nconst c...",
        "full_content": "2024-07-10 03:14:31\n Tonidevs -> 2071074234:\nЯНДЕКС ГО 2 этап\n— сами написали\n— ЗП: 200-300 по результатам теха\n— комментарий: интервьюер крутой, результат плохой. успехом будет зависеть от скорости мысли и количества решенных задач\n\nВОПРОСЫ: нет, сразу задачи\n\nЗАДАЧИ: \n- что будет в консоли\nconst a = {\n  name: 'a',\n  foo: function () {\n    console.log(this.name);\n  }\n};\n\na.foo(); // 1 a\n\nconst bar = a.foo;\nbar(); // 2 undefined\n\nconst b = {\n  name: 'b'\n};\nb.foo = a.foo;\nb.foo(); // 3 b\n\nconst c = {\n  name: 'c'\n};\n\nbar.call(c); // 4 c\na.foo.apply(b); // 5 b\na.foo.bind(b).call(c); // 6 b\na.foo.bind(b).bind(c)(); // 7 b\n\n\n- напиши каррирование,  моё не лучшее решение\nfunction sum(a, b, c) { // Функция суммирования трех чисел\n  return a + b + c;\n}\n\nfunction curry(fn) { // Функция каррирования\n  return function cur(...args) { // Возвращает новую функцию, принимающую аргументы\n    if (args.length >= fn.length) { // Если количество аргументов больше или равно количеству аргументов исходной функции\n      return fn(...args); // Вызываем исходную функцию с текущими аргументами\n    } else {\n      return (...newArgs) => cur(...args, ...newArgs); // Возвращаем новую функцию, принимающую оставшиеся аргументы\n    }\n  }\n}\n\nconsole.log(curry(sum)(1, 2, 3));    // 6\nconsole.log(curry(sum)(1, 2)(3));    // 6\nconsole.log(curry(sum)(1)(2)(3));    // 6\n\n\n- реши задачу\n/*\nВам дается массив серверов, которые начинают сбоить начиная с какого-то сервера.\nПроверка работоспособности сервера осуществляется асинхронно и возвращает `Promise<boolean>`.\nОдновременно проверять на работоспособность можно только один сервер.\n\nНеобходимо написать функцию `findServer`,\nкоторая на вход получит список серверов и функцию проверки,\nа вернет `Promise`, который зарезолвится адресом первого упавшего сервера.\n\nРешение должно вызывать функцию проверки минимально возможное количество раз.\n*/\n\nconst servers = ['srv-a', 'srv-b', 'srv-c', 'srv-d'];\nconst check = (name) => new Promise((res) => setTimeout(res, 100)).then(() => name === 'srv-a');\n\nconst findServer = async (servers, check) => {\n  for (const server of servers) {\n    if (await check(server)) {\n      return server; // Возвращает первый сервер, который прошел проверку\n    }\n  }\n};\n\nfindServer(servers, check).then(console.log); // Promise.resolve('srv-b')\n\n\n- реши задачу\n/*\nНеобходимо обработать запросы к внешнему API.\nДля отрисовки раздела помощи пользователю необходимо получить ряд данных по нему.\nПри этом часть данных является критичным, а часть дополнительной информацией (обозначено []).\nФормат ответа и ошибок на усмотрение кандидата.\nЕсли критичные данные не ответили (getAuth), функция должна прекратить работу (не нужно пытаться делать остальных запросов).\nКратко: Получить максимум информации о пользователе, все ошибки кроме ошибки запроса авторизации - игнорируем.\nФорматы ошибок/ответов на усмотрение кандидата.\n*/\n\nfunction getAuth() { // return Promise with token\n}\n\nfunction getUser(token) { // [return Promise with userId]\n}\n\nfunction getOrder(token, userId) { // [return Promise with order]\n}\n\nfunction getPromo(token) { // [return Promise with promo]\n}\n\nfunction getData() {\n  ...\n  // return {token, user, order, promo}\n}"
      },
      {
        "timestamp": "2024-07-04 07:34:18",
        "content": "2024-07-04 07:34:18\n Tonidevs -> 2071074234:\nЯНДЕКС ГО первый тех этап\n\n— вакансия: сами написали\n— зп: не обсуждал думаю 300-400\n— итог: ✅ позвали на след этап, несмотря на то что не ответил про специфичность\n\nВОПРОСЫ\n- назови HTTP методы, для чего используются и отличия\n- знакомо ли понятие идемпотентные методы\n- какие методы взаимодействия сервисов ты знаешь для постоянного соединения между собой (SSE, WebSocket, Pooling) какие есть проблемы\n\nЗАДАЧИ\n- спроектировать API, будут вытекающие вопр...",
        "full_content": "2024-07-04 07:34:18\n Tonidevs -> 2071074234:\nЯНДЕКС ГО первый тех этап\n\n— вакансия: сами написали\n— зп: не обсуждал думаю 300-400\n— итог: ✅ позвали на след этап, несмотря на то что не ответил про специфичность\n\nВОПРОСЫ\n- назови HTTP методы, для чего используются и отличия\n- знакомо ли понятие идемпотентные методы\n- какие методы взаимодействия сервисов ты знаешь для постоянного соединения между собой (SSE, WebSocket, Pooling) какие есть проблемы\n\nЗАДАЧИ\n- спроектировать API, будут вытекающие вопросы: про пагинацию, про query-params, про изменение данных и про удаление\nСпроектируйте API для корзины интернет магазина:\n1. получение списка айтемов из корзины,\n2. получение одного айтема,\n3. удаление айтема из корзины,\n4. обновление айтема из корзины.\n\nШаблон для ответа\n\nMETHOD /URL\nHeaders: Header1=value, Header2=value2, ...\nBody: {...}\nResponse: {...}\n\nПример:\n\nPOST /path/to/src\nBody: {}\nHeaders: A=\"b\"\nResponse: {}\n\n*/\n// write here...\n\n- задача про специфичность\n<div class=\"box block\"></div>\n\n<style>\n  .box {\n    width: 100px;\n    height: 100px;\n  }\n  \n  * {\n    background: black;\n  }\n  \n  .box {\n    background: yellow;\n  }\n  \n  .box.block {\n    background: green;\n  }\n  \n  .block {\n    background: red;\n  }\n  \n  div.block {\n    background: blue;\n  }\n</style>\n\n\n- какой будет порядок выполнения\nconsole.log('apple');\n\nsetTimeout(() => console.log('pear'), 0);\n\nPromise.resolve('melon').then(res => console.log(res));\n\nnew Promise((resolve, reject) => {\n  console.log('orange');\n  resolve('pineapple');\n}).then(res => console.log(res));\n\nconsole.log('lime');\n\n\n- решить задачу\n/* Функция проверяет, является ли первая строка подпоследовательностью второй\n(нечеткий поиск - fuzzysearch или approximate string matching).\n\nНужно реализовать функцию с использованием только одного прохода \nпо символам строки, без использования регулярных выражений.\n*/\nПример работы:\n\nfuzzysearch('car', 'cartwheel')      // true\nfuzzysearch('cwhl', 'cartwheel')     // true\nfuzzysearch('we', 'cartwheel')       // true\nfuzzysearch('cartwheel', 'cartwheel') // true\nfuzzysearch('cwheeel', 'cartwheel')  // false\nfuzzysearch('lw', 'cartwheel')       // false\n\nfunction fuzzysearch(needle, stack) {\n  // your code\n}"
      },
      {
        "timestamp": "2024-06-25 16:17:59",
        "content": "2024-06-25 16:17:59\n Mummadhan -> 2071074234:\n- Яндекс Про(1 этап)\n- Рекрутер написала\n- ЗП: 180к на руки\n- Задачи:\n1) Что выведет в консоль? Как починить?\n \n    setTimeout(() => {\n      console.log(i)\n    }, 10 )\n  }\n\n2) Что выведет в консоль?\n\n.then(x=>x+1)\n.then(x=> {throw x})\n.then(x=>console.log(x))\n.catch(err=>console.log(err))\n.then(x=>Promise.resolve(1))\n.catch(err=>console.log(err))\n.then(x=>console.log(x))\n\n3) Написать свой аналог Promise.allsetled\n\n4) Написать функцию, которая определ...",
        "full_content": "2024-06-25 16:17:59\n Mummadhan -> 2071074234:\n- Яндекс Про(1 этап)\n- Рекрутер написала\n- ЗП: 180к на руки\n- Задачи:\n1) Что выведет в консоль? Как починить?\n \n    setTimeout(() => {\n      console.log(i)\n    }, 10 )\n  }\n\n2) Что выведет в консоль?\n\n.then(x=>x+1)\n.then(x=> {throw x})\n.then(x=>console.log(x))\n.catch(err=>console.log(err))\n.then(x=>Promise.resolve(1))\n.catch(err=>console.log(err))\n.then(x=>console.log(x))\n\n3) Написать свой аналог Promise.allsetled\n\n4) Написать функцию, которая определяет, является ли переданная стоока палиндоомом\n(читается слева-направо и справа-налево одинаково).\nПримеры палиндромов:\n- казак\n- А роза упала на лапу Азора\n- Do geese see God?\n- Madam. I'm Adam\nОграничение по памяти О(1).\n\n  return char.toLocaleLowerCase() !==char.toLocaleUpperCase()\n}\nfunction isEqualChars(char1, char2){\n  return char1.toLowerCase() === char2.toLowerCase()\n}\n\nfunction isPalindrome(s){\n  let start = 0,\n  end = s.length - 1;\nwhile (start < end){\nlet startChar = s[start],\nendChar = s[end]\nif (!isWord(startChar)){\nstart++;\ncontinue;\n  \n}\nif(!isWord(endChar)){\nend--;\ncontinue;\n}\n\nif (!isEqualChars(startChar, endChar)){\n  return false;\n}\n\nstart++;\nend--;\n\n}\nreturn true\n}"
      },
      {
        "timestamp": "2024-06-17 08:34:18",
        "content": "2024-06-17 08:34:18\n Руслан -> 2071074234:\n13.06 Яндекс - 4й этап - общение с тимлидом конкретной команды\n— Ссылка на вакансию: Нr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ❓\nОбщались поверхностно по моему прошлому опыту, задачам, которыми горжусь. Потом перешли к обсуждению их проекта, процессов, команде.",
        "full_content": "2024-06-17 08:34:18\n Руслан -> 2071074234:\n13.06 Яндекс - 4й этап - общение с тимлидом конкретной команды\n— Ссылка на вакансию: Нr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ❓\nОбщались поверхностно по моему прошлому опыту, задачам, которыми горжусь. Потом перешли к обсуждению их проекта, процессов, команде."
      },
      {
        "timestamp": "2024-06-13 08:35:07",
        "content": "2024-06-13 08:35:07\n Руслан -> 2071074234:\n10.06 Яндекс - 3й этап - разбор опыта + технические, софт вопросы\n\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\n\nВопросы:\n1. про замену сборщика с webpack на vite - разбор с технической и софтовой стороны - как взаимомодействовал с командой, как пришли к идее замены сборщика\n2. про создание какого-либо модуля, проекта с нуля самостоятельно, где ты руководил процессо...",
        "full_content": "2024-06-13 08:35:07\n Руслан -> 2071074234:\n10.06 Яндекс - 3й этап - разбор опыта + технические, софт вопросы\n\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\n\nВопросы:\n1. про замену сборщика с webpack на vite - разбор с технической и софтовой стороны - как взаимомодействовал с командой, как пришли к идее замены сборщика\n2. про создание какого-либо модуля, проекта с нуля самостоятельно, где ты руководил процессом\n3. что делать если сайт медленно прогружается\n4. был ли опыт с ci/cd, кубером, опиши\n5. были ли со стороны конфликтные ситуации, где ты не был стороной конфликта, но поспособствовал его урегулированию \n6. про процессы во время релизов"
      },
      {
        "timestamp": "2024-06-11 10:19:10",
        "content": "2024-06-11 10:19:10\n SQwerty -> 2071074234:\nНазвание компании - Точка банк\nВакансия: https://tochka.com/hr/it/frontend/\nЗП: не обговаривалось\nЗадачи: https://code.yandex-team.ru/4420ce6e-db67-484e-bf4d-98f9e9c9717d\nЗапись: https://www.youtube.com/watch?v=42UZDI3Zryw\nУспех:❌\nФидбек: Рекомендации от ребят:\nthis, области видимости\nцепочки промисов\nметоды встроенных классов, fill, from\nитераторы, Array.from, spread\nКак работает useEffect со списком зависимостей\nuseRef для хранения переменных в функц...",
        "full_content": "2024-06-11 10:19:10\n SQwerty -> 2071074234:\nНазвание компании - Точка банк\nВакансия: https://tochka.com/hr/it/frontend/\nЗП: не обговаривалось\nЗадачи: https://code.yandex-team.ru/4420ce6e-db67-484e-bf4d-98f9e9c9717d\nЗапись: https://www.youtube.com/watch?v=42UZDI3Zryw\nУспех:❌\nФидбек: Рекомендации от ребят:\nthis, области видимости\nцепочки промисов\nметоды встроенных классов, fill, from\nитераторы, Array.from, spread\nКак работает useEffect со списком зависимостей\nuseRef для хранения переменных в функциональных компонентах\nповторить классовые компоненты"
      },
      {
        "timestamp": "2024-06-05 08:00:18",
        "content": "2024-06-05 08:00:18\n Руслан -> 2071074234:\n04.06 Яндекс - 2й технический этап - алгосы\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\nЗадачи:\n1.\nИз списка билетов составить маршрут следования\nconst tickets = [\n  {\n    from: 'London',\n    to: 'Moscow',\n  },\n  {\n    from: 'NY',\n    to: 'London',\n  },\n  {\n    from: 'Moscow',\n    to: 'Spb',\n  },\n];\n// console.log(getRoute(tickets)); => \n[\n{\n    from: 'NY',\n    to:...",
        "full_content": "2024-06-05 08:00:18\n Руслан -> 2071074234:\n04.06 Яндекс - 2й технический этап - алгосы\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\nЗадачи:\n1.\nИз списка билетов составить маршрут следования\nconst tickets = [\n  {\n    from: 'London',\n    to: 'Moscow',\n  },\n  {\n    from: 'NY',\n    to: 'London',\n  },\n  {\n    from: 'Moscow',\n    to: 'Spb',\n  },\n];\n// console.log(getRoute(tickets)); => \n[\n{\n    from: 'NY',\n    to: 'London',\n  },\n  {\n    from: 'London',\n    to: 'Moscow',\n  },\n  {\n    from: 'Moscow',\n    to: 'Spb',\n  },\n];\n// Функция getRoute принимает массив билетов и возвращает их в порядке следования по маршруту\nfunction getRoute(tickets = []) {\n  // Создаем карту билетов, где ключ - город отправления, а значение - массив билетов из этого города\n  const ticketMap = {};\n  const route = [];\n\n  // Создаем карту билетов\n  tickets.forEach((ticket) => {\n    // Если город отправления еще не добавлен в карту, создаем для него пустой массив\n    if (!ticketMap[ticket.from]) {\n      ticketMap[ticket.from] = [];\n    }\n    // Добавляем билет в массив билетов из этого города\n    ticketMap[ticket.from].push(ticket);\n  });\n\n  // Ищем город отправления (город, из которого нет рейсов)\n  let currentCity = null;\n  Object.keys(ticketMap).forEach((city) => {\n    // Если из этого города нет рейсов, это наш стартовый город\n    if (!tickets.some((ticket) => ticket.to === city)) {\n      currentCity = city;\n    }\n  });\n\n  // Строим маршрут\n  while (currentCity) {\n    // Берем первый билет из массива билетов из текущего города\n    const nextTicket = ticketMap[currentCity]?.shift();\n    // Добавляем билет в маршрут\n    route.push(nextTicket);\n    // Переходим к следующему городу\n    currentCity = nextTicket.to;\n  }\n\n  // Возвращаем готовый маршрут\n  return route;\n}\n\n2.\n// Функция типографа, которая будет выводить текст по одному символу с задержкой\nfunction typewriter(delay, outputChar) {\n  // Переменная для хранения текущего текста\n  let currentText = '';\n  // Индекс для хранения текущего символа\n  let index = 0;\n  // Переменная для хранения идентификатора таймаута\n  let timeoutId = null;\n\n  // Возвращаем функцию writeText, которая будет вызываться для вывода текста\n  return function writeText(text) {\n    // Добавляем новый текст к текущему тексту\n    currentText += text; вот это забыл кажись\n\n    // Функция для вывода следующего символа\n    function writeNextChar() {\n      // Если еще есть символы для вывода\n      if (index < currentText.length) {\n        // Выводим текущий символ с помощью функции outputChar\n        outputChar(currentText[index]);\n        \n        // Инкрементируем индекс, чтобы перейти к следующему символу\n        index++;\n        \n        // Запускаем таймер для вывода следующего символа через задержку\n        timeoutId = setTimeout(writeNextChar, delay);\n      } else {\n        // Если мы достигли конца текста, то обнуляем идентификатор таймаута\n        timeoutId = null;\n      }\n    }\n\n    // Если нет текущего таймаута, то запускаем процесс вывода текста\n    if (!timeoutId) {\n      writeNextChar();\n    }\n  };\n}"
      },
      {
        "timestamp": "2024-05-30 16:01:09",
        "content": "2024-05-30 16:01:09\n Влад -> 2071074234:\nЗП: Просил 180к\nСсылки на вакансию нет, нашли меня сами(по зп, просил 180к)\n\nНорд-клан, 1 этап(техническое интервью). Позвали на второй этап\n\nВопросы: что будет в консоли, пару задачек в яндекс code team, вопросы по опыту",
        "full_content": "2024-05-30 16:01:09\n Влад -> 2071074234:\nЗП: Просил 180к\nСсылки на вакансию нет, нашли меня сами(по зп, просил 180к)\n\nНорд-клан, 1 этап(техническое интервью). Позвали на второй этап\n\nВопросы: что будет в консоли, пару задачек в яндекс code team, вопросы по опыту"
      },
      {
        "timestamp": "2024-05-30 09:18:27",
        "content": "2024-05-30 09:18:27\n Руслан -> 2071074234:\n29.05 Яндекс - 1й технический этап\n\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\n— Задачи\n\n// Получить value по переданному пути(прим. a.b.c; a,b,d[0]), если пути в объекте нет, вернуть undefined\n// Решение\nfunction get(obj, path) {\n    const keys = path.split('.');\n    let current = obj;\n\n    for (let key of keys) {\n        if (current[key] === undefined) {\n       ...",
        "full_content": "2024-05-30 09:18:27\n Руслан -> 2071074234:\n29.05 Яндекс - 1й технический этап\n\n— Ссылка на вакансию: Hr сам написал\n— Важность собеседования: важно, хочу устроиться\n— Озвученная мной ЗП: 280 тыс\n— Успех собеса: ✅\n— Задачи\n\n// Получить value по переданному пути(прим. a.b.c; a,b,d[0]), если пути в объекте нет, вернуть undefined\n// Решение\nfunction get(obj, path) {\n    const keys = path.split('.');\n    let current = obj;\n\n    for (let key of keys) {\n        if (current[key] === undefined) {\n            return undefined;\n        }\n        current = current[key];\n    }\n\n    return current;\n}\n\n// Обеспечить нужный порядок вывода логов => A, B, C\nfunction foo(callback) {\n    setTimeout(function() {\n        callback('A');\n    }, Math.random() * 100);\n}\n\nfunction bar(callback) {\n    setTimeout(function() {\n        callback('B');\n    }, Math.random() * 100);\n}\n\nfunction baz(callback) {\n    setTimeout(function() {\n        callback('C');\n    }, Math.random() * 100);\n}\n// Решение (возможны ошибки)\n// Обертка для преобразования функций в промисы\nfunction promisify(fn) {\n    return new Promise(resolve => {\n        fn(result);\n    });\n}\n\nconst fooPromise = promisify(foo);\nconst barPromise = promisify(bar);\nconst bazPromise = promisify(baz);\n\nPromise.all([fooPromise, barPromise, bazPromise])\n    .then(results => {\n        results.forEach(item => console.log(item));\n    });\n\n\n// Определить, выставлены ли все числа в порядке возрастания или убывания (arr: number[]) => boolean\n// Решение\nfunction isMonotonic(numbers) {\n    if (numbers.length <= 1) return true;\n\n    let isIncreasing = true;\n    let isDecreasing = true;\n\n    for (let i = 1; i < numbers.length; i++) {\n        if (numbers[i] > numbers[i - 1]) {\n            isDecreasing = false;\n        }\n        if (numbers[i] < numbers[i - 1]) {\n            isIncreasing = false;\n        }\n    }\n\n    return isIncreasing || isDecreasing;\n}"
      },
      {
        "timestamp": "2024-05-24 15:57:30",
        "content": "2024-05-24 15:57:30\n Daniil Max -> 2071074234:\n— Название компании: Яндекс Multitrack [Первый Этап]\n— Ссылка на вакансию: hr сама написала\n— ЗП: 340~380К.\n— Задачи: лайвкодинг\n\n— Задачки:\nПервая задача:\n\nfunction _sum(a, b) {\n    return a + b;\n}\n\nfunction spy(f) {\n    function wrapper(...args) {\n        const result = f.apply(this, args);\n        wrapper.data.calls++;\n        wrapper.data.args.push(args);\n        wrapper.data.results.push(result);\n        return result;\n    }\n\n    wrapper.data =...",
        "full_content": "2024-05-24 15:57:30\n Daniil Max -> 2071074234:\n— Название компании: Яндекс Multitrack [Первый Этап]\n— Ссылка на вакансию: hr сама написала\n— ЗП: 340~380К.\n— Задачи: лайвкодинг\n\n— Задачки:\nПервая задача:\n\nfunction _sum(a, b) {\n    return a + b;\n}\n\nfunction spy(f) {\n    function wrapper(...args) {\n        const result = f.apply(this, args);\n        wrapper.data.calls++;\n        wrapper.data.args.push(args);\n        wrapper.data.results.push(result);\n        return result;\n    }\n\n    wrapper.data = {\n        calls: 0,\n        args: [],\n        results: []\n    };\n\n    return wrapper;\n}\n\n#################################\n\nВторая задача:\n\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  addEventListener(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n    return () => {\n      this.events[event] = this.events[event].filter(l => l !== listener);\n    };\n  }\n\n  dispatchEvent(event, ...args) {\n    if (!this.events[event]) return;\n    this.events[event].forEach(listener => listener(...args));\n  }\n}\n\n########################################\n\nТретья задача:\n\nclass EventEmitter {\n  constructor(queueType) {\n    this.events = {};\n   this.queueType = queueType;\n\n  }\n\n  addEventListener(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n    return () => {\n      this.events[event] = this.events[event].filter(l => l !== listener);\n    };\n\ndispatchEvent(event, payload) {\n    if (!this.events[event]) {\n      return;\n    }\n    \n    const dispatchFn = () => {\n      this.events[event].forEach(listener => listener(payload));\n    };\n\n    if (this.queueType === 'microTask') {\n      Promise.resolve().then(() => dispatchFn(payload));\n    } else if (this.queueType === 'macroTask') {\n      setTimeout(() => dispatchFn(payload), 0);\n    } else {\n      dispatchFn(paylaod);\n    }\n  }\n } \n\n\n########################################\n\nЧетвертая задача:\n\nclass EventEmitter {\n  constructor(queueType) {\n    this.events = {};\n   this.queueType = queueType;\n  }\n\n  addEventListener(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n    return () => {\n      this.events[event] = this.events[event].filter(l => l !== listener);\n    };\n\ndispatchEvent(event, payload) {\n    if (!this.events[event]) {\n      return;\n    }\n    \n    const dispatchFn = () => {\n      this.events[event].forEach(listener => listener(payload));\n    };\n\n    if (this.queueType === 'microTask') {\n      Promise.resolve().then(() => dispatchFn(payload));\n    } else if (this.queueType === 'macroTask') {\n      setTimeout(() => dispatchFn(payload), 0);\n    } else {\n      dispatchFn(paylaod);\n    }\n  }\n } \n\nonce(event, callback) => {\n    const  removeEventListener =  this.addEventListener(event, (payload) => {\nremoveEventListener ();\ncallback(payload);\n})\n}\n\n\n— Успех собеса: ✅️\n— Фитбек о собесе:\nДаниил, привет!\nВозвращаюсь с фидбеком.\nПо первой задаче были небольшие огрехи с контекстом вызова и стрелочной функцией, ты теоретически знал особенности работы, но в своем коде как раз не увидел проблемы, пришлось явно указать на ошибку. \nВ остальном задачка хорошо прошла если бы не эта ошибка, отлично было бы.\n\nПо второй задачке тоже начали отлично, но на последней доп. задаче с once методом будто уже устал и поплыл, пришлось выдавать прямо ключевые идеи и подсказывать с точностью до строки, что и как написать и где баг который был посажен в рамках этой доп. задачи.\n\nСекция пройдена, зову на 2 этап - базовые знания программирования (алгоритмы)"
      },
      {
        "timestamp": "2024-05-24 15:46:25",
        "content": "2024-05-24 15:46:25\n Daniil Max -> 2071074234:\n— Название компании: Яндекс Multitrack [Второй Этап]\n— Ссылка на вакансию: hr сама написала\n— ЗП: 340~380К.\n— Задачи: лайвкодинг\n\n— Задачки:\nПервая задача:\n\nfunction parallelLimit(urls, limit, callback) {\n    const results = [];\n    const cache = new Map();\n    let currentIndex = 0;\n    let activeCount = 0;\n\n    const next = () => {\n        if (currentIndex >= urls.length && activeCount === 0) {\n            callback(results);\n            return;\n   ...",
        "full_content": "2024-05-24 15:46:25\n Daniil Max -> 2071074234:\n— Название компании: Яндекс Multitrack [Второй Этап]\n— Ссылка на вакансию: hr сама написала\n— ЗП: 340~380К.\n— Задачи: лайвкодинг\n\n— Задачки:\nПервая задача:\n\nfunction parallelLimit(urls, limit, callback) {\n    const results = [];\n    const cache = new Map();\n    let currentIndex = 0;\n    let activeCount = 0;\n\n    const next = () => {\n        if (currentIndex >= urls.length && activeCount === 0) {\n            callback(results);\n            return;\n        }\n\n        while (activeCount < limit && currentIndex < urls.length) {\n            const url = urls[currentIndex];\n            const idx = currentIndex;\n            currentIndex++;\n\n            if (cache.has(url)) {\n                results[idx] = cache.get(url);\n                next();  // move to the next URL without increasing activeCount\n            } else {\n                activeCount++;\n                fetch(url)\n                    .then(res => res.text())  // assuming the response needs to be text, can be modified as needed\n                    .then(data => {\n                        results[idx] = data;\n                        cache.set(url, data);\n                    })\n                    .catch(err => {\n                        results[idx] = err;\n                    })\n                    .finally(() => {\n                        activeCount--;\n                        next();\n                    });\n            }\n        }\n    };\n\n    next();\n}\n\n\nparallelLimit([\"https://example.com\", \"https://example.com\"], 2, console.log);\n\n##############\nВторая задача\n\nfunction compress(list) {\n    if (list.length === 0) return '';\n    list.sort((a, b) => a - b);\n    \n    let result = [];\n    let start = list[0];\n    let end = list[0];\n    \n    for (let i = 1; i < list.length; i++) {\n        if (list[i] === end + 1) {\n            end = list[i];\n        } else {\n            if (start === end) {\n                result.push(`${start}`);\n            } else {\n                result.push(`${start}-${end}`);\n            }\n            start = list[i];\n            end = list[i];\n        }\n    }\n    \n    if (start === end) {\n        result.push(`${start}`);\n    } else {\n        result.push(`${start}-${end}`);\n    }\n    \n    return result.join(',');\n}\n\n— Успех собеса: ❌\n— Фитбек о собесе: \nДаниил, привет!\nПрости за долгое ожидание, вернулась сегодня с конференции из Новосиба.\nК сожалению секция не пройдена, двигаться дальше к финалу пока не можем.\n\nПо нашим правилам пересдать можно через 6 месяцев. \nОстаюсь на связи и буду рада возобновить диалог🙌"
      },
      {
        "timestamp": "2024-05-02 06:55:57",
        "content": "2024-05-02 06:55:57\n Artem -> 2071074234:\nНазвание компании - Яндекс Финтех [Первый этап]\nВакансия: Написал hr\nЗП: Просил от 200к\nЗапись: https://youtu.be/39YCnI2BCus\nУспех: ✅\nФидбек: Краткий фидбэк с нашей стороны: \nБыстро справился с задачами. Понравилось как думал и что в целом проявлял инициативу. \nТеория – отлично, практика – отлично\n\nМы рады двигаться дальше, поэтому давай согласуем след. секцию, с алгоритмами.",
        "full_content": "2024-05-02 06:55:57\n Artem -> 2071074234:\nНазвание компании - Яндекс Финтех [Первый этап]\nВакансия: Написал hr\nЗП: Просил от 200к\nЗапись: https://youtu.be/39YCnI2BCus\nУспех: ✅\nФидбек: Краткий фидбэк с нашей стороны: \nБыстро справился с задачами. Понравилось как думал и что в целом проявлял инициативу. \nТеория – отлично, практика – отлично\n\nМы рады двигаться дальше, поэтому давай согласуем след. секцию, с алгоритмами."
      },
      {
        "timestamp": "2024-04-08 12:11:35",
        "content": "2024-04-08 12:11:35\n 5429820319 -> 2071074234:\nНазвание компании: Яндекс (первый этап) \nСсылка на вакансию: hr сама написала\nЗП: говорил хочу 200 \nЗадачи: \n(1) Из строки \"a.b.c.d.e\" сделать {a:{b:c{d:{e:{}}}}} (долго решал)\n(2) Promise.race (не смог написать)\nУспех собеса: ❌ (фидбэк коротко - долго делал, мало успел)\nСобес был 5 апреля",
        "full_content": "2024-04-08 12:11:35\n 5429820319 -> 2071074234:\nНазвание компании: Яндекс (первый этап) \nСсылка на вакансию: hr сама написала\nЗП: говорил хочу 200 \nЗадачи: \n(1) Из строки \"a.b.c.d.e\" сделать {a:{b:c{d:{e:{}}}}} (долго решал)\n(2) Promise.race (не смог написать)\nУспех собеса: ❌ (фидбэк коротко - долго делал, мало успел)\nСобес был 5 апреля"
      },
      {
        "timestamp": "2024-02-22 10:07:08",
        "content": "2024-02-22 10:07:08\n Nikita -> 2071074234:\n— Название компании: Wiregate [1 этап - знакомство + техсобес]\n— Что было: теория(Git, bigO, Redux, общие вопросы)\n— Успех собеса, дали положительную обратную связь на интервью, жду следующий этап\n— Ссылка: https://disk.yandex.ru/i/9An5QeNiO-wpCw\n\nКомпания работает с таймтрекером, во время работы нужно сидеть в голосовом канале в дс, пойду на знакомство с командой если позовут для тренировки",
        "full_content": "2024-02-22 10:07:08\n Nikita -> 2071074234:\n— Название компании: Wiregate [1 этап - знакомство + техсобес]\n— Что было: теория(Git, bigO, Redux, общие вопросы)\n— Успех собеса, дали положительную обратную связь на интервью, жду следующий этап\n— Ссылка: https://disk.yandex.ru/i/9An5QeNiO-wpCw\n\nКомпания работает с таймтрекером, во время работы нужно сидеть в голосовом канале в дс, пойду на знакомство с командой если позовут для тренировки"
      },
      {
        "timestamp": "2024-02-05 14:27:48",
        "content": "2024-02-05 14:27:48\n m1-iwnl -> 2071074234:\nКомпания: KTS\nВакансия: https://hh.ru/vacancy/92355111\nЗадачи: https://code.yandex-team.ru/77861db1-99ed-4a95-9c15-23a87f147e49\nЗП: 180-250",
        "full_content": "2024-02-05 14:27:48\n m1-iwnl -> 2071074234:\nКомпания: KTS\nВакансия: https://hh.ru/vacancy/92355111\nЗадачи: https://code.yandex-team.ru/77861db1-99ed-4a95-9c15-23a87f147e49\nЗП: 180-250"
      },
      {
        "timestamp": "2024-01-17 15:03:26",
        "content": "2024-01-17 15:03:26\n m1-iwnl -> 2071074234:\n// С бекенда приходит массив такого вида:\nconst arr = [\n  { name: 'width', value: 10 }, \n  { name: 'height', value: 20 },\n  // ...\n];\n\n// Нужно получить объект такого вида:\n/*\n{\n  width: 10,\n  height: 20,\n  ...\n}\n*/\n\nfunction objFromArr(arr) {\n  if(!arr || !arr.length) return {}\n\n  const mapa = {}\n\n  arr.forEach(el => {\n      mapa[el.name] = el.value\n  })\n\n  return mapa;\n}\n\n\n\n// -----------------------------------\n\n/**\n * Нужно написать функцию get. На...",
        "full_content": "2024-01-17 15:03:26\n m1-iwnl -> 2071074234:\n// С бекенда приходит массив такого вида:\nconst arr = [\n  { name: 'width', value: 10 }, \n  { name: 'height', value: 20 },\n  // ...\n];\n\n// Нужно получить объект такого вида:\n/*\n{\n  width: 10,\n  height: 20,\n  ...\n}\n*/\n\nfunction objFromArr(arr) {\n  if(!arr || !arr.length) return {}\n\n  const mapa = {}\n\n  arr.forEach(el => {\n      mapa[el.name] = el.value\n  })\n\n  return mapa;\n}\n\n\n\n// -----------------------------------\n\n/**\n * Нужно написать функцию get. На вход функция принимает объект и путь до поля объекта. \n * Путь – это строка, разделенная точкой. Функция должна вернуть соответствующее поле объекта. \n * Запрашиваемого поля в объекте может не быть.\n */\n\nfunction get(obj, path) {\n    if (!obj) return undefined;\n    const keys = path.split(\".\")\n    let result = obj;\n\n    for(let i = 0; i < keys.length; i++){\n        const currKey = keys[i];\n        const curr = result?.[currKey];\n\n        if(curr === undefined) return undefined;\n        if(curr === null && i === keys.length - 1) return null;\n\n        result = result[currKey]\n    }\n\n    return result;\n}\n\nconst obj = { \n  a: { \n    b: { \n      c: 'd' \n    },\n    x: null,\n    e: null,\n  }\n};\n\nget(obj, 'a.b');   // { c : 'd' }\nget(obj, 'a.b.c'); // 'd'\nget(obj, 'a.e');   // null\nget(obj, 'a.x.e'); // undefined\n\n\n// --------------\n\n// Написать функцию, которая принимает массив чисел. Необходимо определить монотонный он или нет.\n// Примеры:\n// [1, 2, 3] - true\n// [6, 3, 2, 1] - true\n// [5, 5] - true\n// [1, 2, 5, 5, 5, 8, 9] - true\n// [1, 2, 5, 5, 5, 2, 1] - false\n// [1, 10, 6] - false\n// [5, 5, 5, 1] - true\n// [1] - true\n\nconst isMono = (arr) => {\n    let isGoingUp;\n    \n    for(let i = 0; i < arr.length - 1; i++){\n        const cur = arr[i]\n        const next = arr[i + 1];\n\n        if(curr === next) continue;\n\n       if(cur < next && isGoingUp === false) {\n            return false;\n        } else if(cur > next && isGoingUp) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n// У нас есть функция asyncAuth(callback) , которая принимает функцию-обработчик, которой можно передать ошибку (1-й аргумент) или необходимые данные (2-й аргумент).\n// Часть 1. Написать функцию auth , которая выполняет asyncAuth , но возвращает Promise .\n\nimport asyncAuth from '.';\n\n// /**\n//  * `asyncAuth()` function receives a callback into which\n//  * an error may be passed (argument 1) or\n//  * data from backend (argument 2).\n//  * \n//  * You need to implement an `auth()` function\n//  * which executes `asyncAuth()`, but returns Promise.\n//  * \n//  * @returns {Promise}\n//  */\n\nfunction auth() {\n    return new Promise((resolve, reject) => asyncAuth((error, data) => {\n        if(error){\n            reject(error);\n            return;\n        }\n\n        resolve(data);\n    }));\n}\n\n- Компания:  Яндекс-документы\n- ЗП: 280 - 350к\n- Задачи с лайвкодинга на 1 этапе"
      },
      {
        "timestamp": "2024-01-11 14:21:37",
        "content": "2024-01-11 14:21:37\n Daniil Max -> 2071074234:\n— Название компании: Yandex.Pay\n— Ссылка на вакансию: https://getmatch.ru/vacancies/15837?s=my_vacancies\nЗП: 320~350К.\n— Задачи: лайвкодинг\n\n1.\nconst deepCopy = obj => {\n        if (obj === null || typeof obj === 'object') {\n            return obj;\n        }\n\n        if (Array.isArray(obj)) {\n            return obj.map(deepCopy);\n        }\n\n        const copy = {};\n\n        for (const key in obj) {\n            copy[key] = deepCopy(obj[key]);\n       ...",
        "full_content": "2024-01-11 14:21:37\n Daniil Max -> 2071074234:\n— Название компании: Yandex.Pay\n— Ссылка на вакансию: https://getmatch.ru/vacancies/15837?s=my_vacancies\nЗП: 320~350К.\n— Задачи: лайвкодинг\n\n1.\nconst deepCopy = obj => {\n        if (obj === null || typeof obj === 'object') {\n            return obj;\n        }\n\n        if (Array.isArray(obj)) {\n            return obj.map(deepCopy);\n        }\n\n        const copy = {};\n\n        for (const key in obj) {\n            copy[key] = deepCopy(obj[key]);\n        }\n\n        return copy;\n    };\n\n2. \nfunction compressstring(input) {\n        let compressed = '';\n        let count = 1;\n\n        for (let i = 0; i < input.length; i++) {\n            if (input[i] === input[i + 1]) {\n                count++;\n            } else {\n                compressed += input[i] + (count > 1 ? count : '');\n\n                count = 1;\n            }\n        }\n\n        return compressed;\n}\n\n3. \nfunction canGetCount(n: number) {\n        let count = 0;\n\n        return function () {\n            count++;\n\n        if (count <= n) {\n            return 'yes';\n        } else return 'no';\n    }\n— Успех собеса: ⁉️\n— Фитбек о собесе ❓\n\n— Комментарий:\nАлгоритмы, которые чаще всего бывают в задачках:\n– сортировки (например, bubble sort или quicksort)\n– разворота одно/двусвязного списка\n– разворота строки\n– обхода дерева\n– на хэш таблицу\n– работы со строками \n– стэк, сортировки\n\nОценка сложности: https://habr.com/ru/post/188010/\n\nСсылки на задачи на leetcode\neasy: https://leetcode.com/explore/interview/card/top-interview-questions-easy/\nmedium: https://leetcode.com/explore/interview/card/top-interview-questions-medium/\n\n\nОбщая инфа про секции: https://yandex.ru/jobs/pages/dev_interview"
      }
    ]
}]
