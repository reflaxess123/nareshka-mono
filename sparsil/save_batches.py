#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
from mass_scraper import MassTelegramScraper

def save_batch_data(offset: int, messages_data: list):
    """Сохраняет данные batch'а и обновляет прогресс"""
    scraper = MassTelegramScraper()
    stats = scraper.get_completion_stats()
    
    # Находим номер batch'а
    batch_num = None
    all_offsets = scraper.generate_offset_list()
    
    for i, o in enumerate(all_offsets):
        if o == offset:
            batch_num = i + 1
            break
    
    if batch_num is None:
        print(f"Ошибка: offset {offset} не найден!")
        return
    
    # Сохраняем файл
    filename = scraper.create_batch_file(offset, batch_num)
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(messages_data, f, ensure_ascii=False, indent=2)
    
    # Обновляем прогресс
    scraper.mark_offset_completed(offset)
    
    print(f"✅ Batch {batch_num} сохранен: {filename}")
    print(f"   Offset: {offset}, Сообщений: {len(messages_data)}")
    
    # Показываем новую статистику
    new_stats = scraper.get_completion_stats()
    print(f"   Прогресс: {new_stats['completed_batches']}/{new_stats['total_batches']} ({new_stats['completion_percentage']:.1f}%)")

# Данные из последних MCP вызовов
batch_data = {
    155737: [
        {"who":"danimaxi54","when":"2025-07-08 16:22:57","text":"отсавили одногг фронта двух"},
        {"who":"danimaxi54","when":"2025-07-08 16:22:50","text":"на поддержке сидеть не хотелось"},
        {"who":"danimaxi54","when":"2025-07-08 16:22:42","text":"там проект мы построили на заказ\nдолго делали"},
        {"who":"danimaxi54","when":"2025-07-08 16:14:18","text":"https://meet.jit.si/MinuteSportsScareBeautifully"},
        {"who":"harmonyhusher","when":"2025-07-08 16:10:19","text":"https://meet.jit.si/SquareSpectraInflictGuiltily"},
        {"who":"mewut_py","when":"2025-07-08 16:06:20","text":"всем пока))"},
        {"who":"mewut_py","when":"2025-07-08 16:06:10","text":"я мисскликнула D:"},
        {"who":"mewut_py","when":"2025-07-08 16:06:01","text":"ой"},
        {"who":"Satera94","when":"2025-07-08 16:05:16","text":"ни видео ни звука"},
        {"who":"theibd56","when":"2025-07-08 16:05:03","text":"да"},
        {"who":"danimaxi54","when":"2025-07-08 16:04:48","text":"е мае ты тут?"},
        {"who":"mewut_py","when":"2025-07-08 16:04:47","text":"Когда preflight запрос не нужен:\n\nПростые запросы:Если запрос удовлетворяет определенным условиям, то браузер может пропустить preflight запрос и сразу отправить основной запрос.\n\n\nGET, HEAD, POST:Методы GET, HEAD и POST, если они не содержат кастомных заголовков и имеют определенные типы содержимого (application/x-www-form-urlencoded, multipart/form-data, или text/plain), не требуют предварительной проверки.\n\n\nGET, HEAD, POST с кастомными заголовками:Если используется GET, HEAD или POST, но добавляются кастомные заголовки, то preflight запрос будет инициирован.\n\n\nМетоды отличные от GET, HEAD, POST:Если используется любой другой метод (например, PUT, DELETE, PATCH), то preflight запрос будет инициирован.\n\n\nКастомные заголовки:Если в запросе присутствуют кастомные заголовки (заголовки, не являющиеся стандартными HTTP-заголовками), то preflight запрос будет инициирован."},
        {"who":"Skeptic","when":"2025-07-08 16:04:40","text":"Таким образом, preflight не будет отправлен , если браузер уверен, что запрос безопасен и не требует дополнительного согласования с сервером."},
        {"who":"Mankeym","when":"2025-07-08 16:04:33","text":"1. Простые (Simple) запросы\nЗапрос считается \"простым\" и не требует preflight, если выполняются все условия:\n\nМетод HTTP: GET, POST, HEAD.\n\nЗаголовки: Только \"безопасные\" (разрешённые по умолчанию):\n\nAccept\n\nAccept-Language\n\nContent-Language\n\nContent-Type (но только с определёнными значениями, см. ниже).\n\nContent-Type:\n\ntext/plain\n\nmultipart/form-data\n\napplication/x-www-form-urlencoded\n\nНет кастомных заголовков (например, X-Requested-With)."},
        {"who":"Skeptic","when":"2025-07-08 16:04:28","text":"CORS отключен (Same-Origin)"},
        {"who":"Skeptic","when":"2025-07-08 16:04:21","text":"Если запрос простой (simple request)\nТо есть удовлетворяет условиям:\nМетод: GET, POST или HEAD."},
        {"who":"mewut_py","when":"2025-07-08 16:04:15","text":"Preflight запрос (preflight request) не инициируется, когда запрос к стороннему ресурсу удовлетворяет следующим условиям: запрос выполняется методом GET, HEAD или POST, и при этом не устанавливаются кастомные заголовки, а также используется Content-Type, равный одному из application/x-www-form-urlencoded, multipart/form-data или text/plain. В этих случаях браузер сразу отправляет основной запрос без предварительной проверк"},
        {"who":"Mankeym","when":"2025-07-08 16:03:45","text":"В постмане?"},
        {"who":"danimaxi54","when":"2025-07-08 16:03:38","text":"ггул мит пробуй"},
        {"who":"danimaxi54","when":"2025-07-08 16:03:27","text":"один шаринг нам\nДругой браузер с ними общаешьшся"}
    ],
    155717: [
        {"who":"danimaxi54","when":"2025-07-08 16:03:27","text":"один шаринг нам\nДругой браузер с ними общаешьшся"},
        {"who":"mewut_py","when":"2025-07-08 16:03:14","text":"Если запрос не является простым, в случае cross-origin запроса (на другой домен), перед отправкой фактического запроса, делается preflight OPTIONS запрос с информацией о запросе: о его методе, дополнительных заголовках и тд. Сервер получает этот запрос и отправляет ответ, содержащий CORSзаголовки. Браузер получает этот ответ и проверяет, будет ли разрешен фактический запрос. preflight заранее чекает есть ли разрешение на доступ к домену, только после этого позволяет отправить основной запрос.\n\nСпособы пофиксить корс ошибку: \n- Написать бекендеру, чтобы добавил наш домен в список доступных источников, чтобы бэк мог обрабатывать запросы с нашего домена. И тогда в ответе на запрос будет приходить хедер AccessControl-Allow-Origin с нашим адресом \n- Можно отключить CORS-проверки в браузере \n- Отключить корсы с помощью расширения для браузера, но работает не всегда и не для всех запросов \n- Настроить прокси сервер, чтобы перенаправлял запросы"},
        {"who":"danimaxi54","when":"2025-07-08 16:03:13","text":"ты шаришь из двух разных браузеров?"},
        {"who":"danimaxi54","when":"2025-07-08 16:03:09","text":"игорь я тебя не слышу теперь тоже"},
        {"who":"Skeptic","when":"2025-07-08 16:02:56","text":"чтобы узнать какие методы можно использовать"},
        {"who":"danimaxi54","when":"2025-07-08 16:02:54","text":"давайте гугл мит попробуем"},
        {"who":"Skeptic","when":"2025-07-08 16:02:51","text":"перед CORS"},
        {"who":"Mankeym","when":"2025-07-08 16:02:49","text":"OPTIONS запрос, для проверки доступности по CORS"},
        {"who":"Skeptic","when":"2025-07-08 16:02:47","text":"options"},
        {"who":"danimaxi54","when":"2025-07-08 16:02:29","text":"в яндексе звук поставил?"},
        {"who":"Mankeym","when":"2025-07-08 16:00:56","text":"Этапы\nЗагрузка — браузер загружает файл с кодом веб-воркера.\n\nУстановка — сервис-воркер регистрируется в JavaScript-коде, браузер запускает установку в фоновом режиме. Если парсинг прошёл успешно, запускается событие install.\n\nАктивация — сервис-воркер становится готовым управлять клиентами, срабатывает событие activate. Однако это не означает, что страница, зарегистрировавшая сервис-воркер, будет управляться — по умолчанию сервис-воркер возьмёт управление на себя только при следующем переходе на эту страницу, в результате перезагрузки страницы или при повторном открытии веб-приложения.\n\nОбработка событий — сервис-воркер ожидает поступления событий fetch и message, которые возникают, когда страницы выполняют сетевые запросы или отправляют сообщения. При поступлении события сервис-воркер его обрабатывает.\n\nОстановка — система останавливает сервис-воркер для экономии ресурсов."},
        {"who":"mewut_py","when":"2025-07-08 16:00:08","text":"Жизненный цикл Web Worker:\n\n1. Загрузка:На этом этапе браузер загружает файл JavaScript, содержащий код Web Worker.\n\n\n2. Установка:Web Worker регистрируется в основном коде, и браузер инициирует процесс установки, загружая файл воркера в фоновом режиме.\n\n\n3. Активация:После установки, воркер может быть активирован, что позволяет ему обрабатывать сообщения и выполнять задачи."},
        {"who":"Skeptic","when":"2025-07-08 15:59:56","text":"Особенности Web Worker:\n- Не имеет доступа к DOM, `window` или `document`.    \n- Общение с основным потоком — через `postMessage`.    \n- Уничтожается после завершения задачи (если не используется `SharedWorker`)."},
        {"who":"Skeptic","when":"2025-07-08 15:59:49","text":"Web Worker - это отдельные потоки JS, которые работают параллельно с основным потоком JS и доступны только веб-приложению. Они используются для выполнения тяжелых задач, чтобы избежать блокировки цикла событий и страницы. Не могут манипулировать DOM. То есть они позволяют вынести какие-то тяжелые задачи в отдельный поток, чтобы избежать блокировки интерфейса."},
        {"who":"theibd56","when":"2025-07-08 15:59:29","text":"@danimaxi54"},
        {"who":"mewut_py","when":"2025-07-08 15:59:00","text":"понервничал, норм)"},
        {"who":"mewut_py","when":"2025-07-08 15:58:55","text":"дада"},
        {"who":"Skeptic","when":"2025-07-08 15:58:43","text":"наоборот"},
        {"who":"Skeptic","when":"2025-07-08 15:58:41","text":"не делай вид что ты проиграл"},
        {"who":"Skeptic","when":"2025-07-08 15:58:25","text":"тебе сказали же, что если ты дошел до конца то все норм"}
    ],
    155697: [
        {"who":"mewut_py","when":"2025-07-08 15:58:06","text":"молодец"},
        {"who":"theibd56","when":"2025-07-08 15:57:01","text":"зайдите звук тестанем"},
        {"who":"mewut_py","when":"2025-07-08 15:56:49","text":"### [[useLayoutEffect()]]\n\nСигнатура идентична useEffect, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри useLayoutEffect, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку."},
        {"who":"GestaRegum","when":"2025-07-08 15:56:29","text":"Хелп"},
        {"who":"Skeptic","when":"2025-07-08 15:55:38","text":"и он синхронный"},
        {"who":"Skeptic","when":"2025-07-08 15:55:25","text":"до стадии painting"},
        {"who":"Skeptic","when":"2025-07-08 15:54:59","text":"useLayoutEffect обладает таким же API, как и useEffect, с тем отличием, что он вызывается синхронно, после всех вычислений мутаций в DOM, то есть блокирует отрисовку браузера, в то время как useEffect вызывается асинхронно и не блокирует рендер. (срабатывает до отрисовки в браузере). \nСрабатывает когда компоненты уже находятся в virtual dom (можно прочитать/установить различные свойств), но еще не были отрисованы браузером. Вызывается до стадии painting."},
        {"who":"g322h","when":"2025-07-08 15:54:26","text":"?."},
        {"who":"Skeptic","when":"2025-07-08 15:54:19","text":"проверкой"},
        {"who":"a1eesc","when":"2025-07-08 15:54:04","text":"у нас map на null не отработвает"},
        {"who":"a1eesc","when":"2025-07-08 15:53:05","text":"const [posts, setPosts] = useState([]); ещё давай инициальизировать массивом"},
        {"who":"g322h","when":"2025-07-08 15:52:49","text":"ключи передай"},
        {"who":"a1eesc","when":"2025-07-08 15:46:54","text":"function Posts() {\n  const [posts, setPosts] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    POSTS.then((data) => {\n      setPosts(data);\n      setLoading(false);\n    });\n  }, []);\n\n  if (loading) {\n    return <div>Загрузка постов...</div>;\n  }\n\n  return (\n    <div>\n      {posts.map((post) => (\n        <div key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.description}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n\nexport default Posts;"},
        {"who":"a1eesc","when":"2025-07-08 15:46:12","text":"и уточни можно ли use попробовать заиспользовать"},
        {"who":"a1eesc","when":"2025-07-08 15:46:01","text":"уточни с ts писать?"},
        {"who":"theibd56","when":"2025-07-08 15:45:15","text":"16:00  Спортс тех\n\nтелемост - https://telemost.yandex.ru/j/16729736193391\nтопик - https://t.me/c/2071074234/151810"},
        {"who":"Skeptic","when":"2025-07-08 15:43:33","text":"\\**Новый API `use`**\n        - Позволяет использовать промисы и контекст внутри рендера, включая условные вызовы:"},
        {"who":"Skeptic","when":"2025-07-08 15:42:16","text":"React.useId() : Работает корректно на стороне сервера (SSR), обеспечивая уникальные ID без конфликтов.\ncrypto.randomUUID() : Не определен на стороне сервера в Node.js, поэтому его использование может привести к ошибкам при SSR."},
        {"who":"Skeptic","when":"2025-07-08 15:42:07","text":"crypto.randomUUID() : Генерирует случайный UUID, но не гарантирует уникальность в контексте React-компонента или SSR. Может привести к проблемам с повторным использованием ID."},
        {"who":"Skeptic","when":"2025-07-08 15:41:13","text":"useId в React нужен для генерации уникальных идентификаторов на клиенте и сервере (без использования Math.random() или сторонних библиотек), чтобы связывать элементы интерфейса, например, формы и метки, с гарантией уникальности."}
    ],
    155677: [
        {"who":"Skeptic","when":"2025-07-08 15:41:13","text":"useId в React нужен для генерации уникальных идентификаторов на клиенте и сервере (без использования Math.random() или сторонних библиотек), чтобы связывать элементы интерфейса, например, формы и метки, с гарантией уникальности."},
        {"who":"Skeptic","when":"2025-07-08 15:40:21","text":"- **useId** – генерирует уникальные ID (для `aria-*` атрибутов). Главное преимущество — безопасная гидратация при SSR, так как ID одинаковы на сервере и клиенте."},
        {"who":"mewut_py","when":"2025-07-08 15:39:55","text":"useSyncExternalStore — добавляет поддержку параллельного чтения для внешних хранилищ;"},
        {"who":"Skeptic","when":"2025-07-08 15:39:53","text":"**useSyncExternalStore** – подписка на внешние хранилища (Redux, Zustand). Обеспечивает консистентность данных при конкурентном рендеринге, предотвращая \"разрывы\" (tearing). В прикладной разработке используется редко — обычно внутри state-менеджеров."},
        {"who":"AntonDevFronti","when":"2025-07-08 15:38:05","text":"."},
        {"who":"a1eesc","when":"2025-07-08 15:36:50","text":"    promises.forEach((item, index) => {\n      if (item instanceof Promise) {\n        item\n          .then((value) => {\n            results[index] = value;\n            completedCount++;\n            if (completedCount === promises.length) {\n              resolve(results);\n            }\n          })\n          .catch(reject);\n      } else {\n        // Просто значение — обрабатываем сразу\n        results[index] = item;\n        completedCount++;\n        if (completedCount === promises.length) {\n          resolve(results);\n        }\n      }\n    });\n  });"},
        {"who":"GestaRegum","when":"2025-07-08 15:36:35","text":"Где"},
        {"who":"a1eesc","when":"2025-07-08 15:35:56","text":"возвращай)))"},
        {"who":"GestaRegum","when":"2025-07-08 15:35:51","text":"Хелп"},
        {"who":"a1eesc","when":"2025-07-08 15:35:31","text":"блин, он уже пишет"},
        {"who":"a1eesc","when":"2025-07-08 15:35:10","text":"удали, мой вариант 100% правильный"},
        {"who":"a1eesc","when":"2025-07-08 15:33:35","text":"если это уже промис, он просто возвращается; если это обычное значение — оно оборачивается в промис, который сразу резолвится с этим значением."},
        {"who":"a1eesc","when":"2025-07-08 15:33:17","text":"function customPromiseAll<T>(promises: (Promise<T> | T)[]): Promise<T[]> {\n  return new Promise((resolve, reject) => {\n    const results: T[] = [];\n    let completedCount = 0;\n\n    promises.forEach((promiseOrValue, index) => {\n      Promise.resolve(promiseOrValue) // мы должны сделать првоерку резолвом\n        .then((value) => {\n          results[index] = value;\n          completedCount++;\n\n          if (completedCount === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}"},
        {"who":"a1eesc","when":"2025-07-08 15:32:58","text":"ааа все понял"},
        {"who":"a1eesc","when":"2025-07-08 15:29:34","text":"function isPromise(obj: any): obj is Promise<any> {\n  return !!obj && (typeof obj.then === 'function');\n}"},
        {"who":"a1eesc","when":"2025-07-08 15:29:28","text":"скажи как будто тайпгуард напрашиваается проверки на промис"},
        {"who":"Skeptic","when":"2025-07-08 15:27:13","text":"он зачем то для customPromiseAllSettled сделал.. хотя его не просили"},
        {"who":"Skeptic","when":"2025-07-08 15:26:47","text":"да ИИ тупой зачем то написал я не проверил"},
        {"who":"a1eesc","when":"2025-07-08 15:25:48","text":"просто переписывай пример, в нем все верно"}
    ]
}

if __name__ == "__main__":
    print("Сохраняю batch'и...")
    for offset, messages in batch_data.items():
        save_batch_data(offset, messages) 