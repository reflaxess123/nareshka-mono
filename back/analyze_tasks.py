#!/usr/bin/env python3

import logging
import re
from collections import defaultdict
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine

from app.config import settings
from app.models import ContentBlock, ContentFile

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def analyze_tasks():
    """–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–¥–∞—á –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    
    # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    db_url = settings.database_url
    if db_url.startswith("postgres://"):
        db_url = db_url.replace("postgres://", "postgresql://", 1)
    
    engine = create_engine(db_url)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()
    
    try:
        logger.info("üîç –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û –ü–û–î–†–û–ë–ù–´–ô –ê–ù–ê–õ–ò–ó –ó–ê–î–ê–ß –í –ë–ê–ó–ï –î–ê–ù–ù–´–•...")
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –±–ª–æ–∫–∏ —Å –∫–æ–¥–æ–º
        blocks = db.query(ContentBlock).filter(
            ContentBlock.codeContent.isnot(None),
            ContentBlock.codeContent != ""
        ).all()
        
        logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ –±–ª–æ–∫–æ–≤ —Å –∫–æ–¥–æ–º: {len(blocks)}")
        
        # –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        languages = defaultdict(int)
        categories = defaultdict(int)
        js_tasks = []
        non_js_tasks = []
        problematic_cases = []
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –±–ª–æ–∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–¥—Ä–æ–±–Ω–æ
        for block in blocks:
            # –ë–∞–∑–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            lang = block.codeLanguage or "unknown"
            languages[lang] += 1
            
            if block.file:
                cat_key = f"{block.file.mainCategory} / {block.file.subCategory}"
                categories[cat_key] += 1
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º JS –∑–∞–¥–∞—á–∏
            is_js = is_javascript_task(block)
            if is_js:
                js_tasks.append(block)
            else:
                non_js_tasks.append(block)
            
            # –ì–õ–£–ë–û–ö–ò–ô –ê–ù–ê–õ–ò–ó –ü–†–û–ë–õ–ï–ú–ù–´–• –°–õ–£–ß–ê–ï–í
            if is_js:
                problems = analyze_code_complexity(block)
                if problems['total_score'] > 0:
                    problematic_cases.append((block, problems))
        
        # –í—ã–≤–æ–¥–∏–º –±–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        print_basic_stats(languages, categories, js_tasks, non_js_tasks)
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–º–µ—Ä—ã —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∑–∞–¥–∞—á
        analyze_task_examples(js_tasks, non_js_tasks)
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ê–ù–ê–õ–ò–ó –ü–†–û–ë–õ–ï–ú–ù–´–• –°–õ–£–ß–ê–ï–í
        analyze_problematic_cases(problematic_cases)
        
        # –ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –∫–æ–¥–∞
        analyze_code_patterns(js_tasks)
        
        # –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        test_generator_on_real_data(js_tasks[:10])
        
        logger.info(f"\n‚úÖ –ê–ù–ê–õ–ò–ó –ó–ê–í–ï–†–®–ï–ù. –ü—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤: {len(problematic_cases)}")
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ: {e}")
        import traceback
        traceback.print_exc()
    finally:
        db.close()

def analyze_code_complexity(block):
    """–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞"""
    code = block.codeContent
    problems = {
        'issues': [],
        'total_score': 0,
        'categories': defaultdict(int)
    }
    
    # 1. –°–¢–†–£–ö–¢–£–†–ù–ê–Ø –°–õ–û–ñ–ù–û–°–¢–¨
    class_count = len(re.findall(r'\bclass\s+\w+', code))
    function_count = len(re.findall(r'\bfunction\s+\w+', code))
    arrow_function_count = len(re.findall(r'=>', code))
    method_count = len(re.findall(r'^\s*\w+\s*\([^)]*\)\s*{', code, re.MULTILINE))
    
    if class_count > 1:
        problems['issues'].append(f"–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Å—ã ({class_count})")
        problems['total_score'] += class_count * 2
        problems['categories']['multiple_classes'] += class_count
    
    if function_count > 3:
        problems['issues'].append(f"–ú–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–π ({function_count})")
        problems['total_score'] += function_count
        problems['categories']['many_functions'] += function_count
    
    if method_count > 5:
        problems['issues'].append(f"–ú–Ω–æ–≥–æ –º–µ—Ç–æ–¥–æ–≤ ({method_count})")
        problems['total_score'] += method_count
        problems['categories']['many_methods'] += method_count
    
    # 2. –í–õ–û–ñ–ï–ù–ù–û–°–¢–¨ –ò –°–ö–û–ë–ö–ò
    brace_count = code.count('{')
    max_nesting = calculate_max_nesting(code)
    
    if brace_count > 15:
        problems['issues'].append(f"–í—ã—Å–æ–∫–∞—è –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å ({brace_count} —Å–∫–æ–±–æ–∫)")
        problems['total_score'] += 3
        problems['categories']['high_nesting'] += 1
    
    if max_nesting > 4:
        problems['issues'].append(f"–ì–ª—É–±–æ–∫–∞—è –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å ({max_nesting} —É—Ä–æ–≤–Ω–µ–π)")
        problems['total_score'] += max_nesting
        problems['categories']['deep_nesting'] += 1
    
    # 3. –ê–°–ò–ù–•–†–û–ù–ù–û–°–¢–¨ –ò –ü–†–û–ú–ò–°–´
    async_patterns = [
        r'\basync\s+function',
        r'\bawait\s+',
        r'\bPromise\.',
        r'\.then\(',
        r'\.catch\(',
        r'\.finally\('
    ]
    
    async_count = sum(len(re.findall(pattern, code)) for pattern in async_patterns)
    if async_count > 0:
        problems['issues'].append(f"–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –∫–æ–¥ ({async_count} –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤)")
        problems['total_score'] += async_count * 2
        problems['categories']['async_code'] += async_count
    
    # 4. –ú–û–î–£–õ–¨–ù–ê–Ø –°–ò–°–¢–ï–ú–ê
    module_patterns = [
        r'\bimport\s+',
        r'\bexport\s+',
        r'\brequire\(',
        r'\bmodule\.exports',
        r'\bexports\.'
    ]
    
    module_count = sum(len(re.findall(pattern, code)) for pattern in module_patterns)
    if module_count > 0:
        problems['issues'].append(f"–ú–æ–¥—É–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ ({module_count} –∏–º–ø–æ—Ä—Ç–æ–≤/—ç–∫—Å–ø–æ—Ä—Ç–æ–≤)")
        problems['total_score'] += module_count
        problems['categories']['modules'] += module_count
    
    # 5. –°–õ–û–ñ–ù–´–ï JS –ö–û–ù–¶–ï–ü–¶–ò–ò
    advanced_patterns = [
        (r'\bprototype\.', 'prototype'),
        (r'\bthis\.', 'this'),
        (r'\.bind\(', 'bind'),
        (r'\.call\(', 'call'),
        (r'\.apply\(', 'apply'),
        (r'\bconstructor\s*\(', 'constructor'),
        (r'\bsuper\(', 'super'),
        (r'\bextends\s+', 'extends'),
        (r'\bstatic\s+', 'static'),
        (r'\bget\s+\w+\s*\(', 'getter'),
        (r'\bset\s+\w+\s*\(', 'setter'),
        (r'\byield\s+', 'generator'),
        (r'\bfunction\*', 'generator'),
        (r'Symbol\.', 'symbols'),
        (r'Proxy\(', 'proxy'),
        (r'Reflect\.', 'reflect')
    ]
    
    advanced_features = []
    for pattern, name in advanced_patterns:
        count = len(re.findall(pattern, code))
        if count > 0:
            advanced_features.append(f"{name}({count})")
            problems['total_score'] += count * 2
            problems['categories']['advanced_js'] += count
    
    if advanced_features:
        problems['issues'].append(f"–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ JS –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏: {', '.join(advanced_features)}")
    
    # 6. –†–ï–ì–£–õ–Ø–†–ù–´–ï –í–´–†–ê–ñ–ï–ù–ò–Ø –ò –°–¢–†–û–ö–ò
    regex_count = len(re.findall(r'/[^/\n]+/[gimuy]*', code))
    template_literal_count = len(re.findall(r'`[^`]*`', code))
    
    if regex_count > 0:
        problems['issues'].append(f"–†–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è ({regex_count})")
        problems['total_score'] += regex_count * 2
        problems['categories']['regex'] += regex_count
    
    if template_literal_count > 2:
        problems['issues'].append(f"–®–∞–±–ª–æ–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ ({template_literal_count})")
        problems['total_score'] += template_literal_count
        problems['categories']['templates'] += template_literal_count
    
    # 7. –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö
    error_handling = [
        r'\btry\s*{',
        r'\bcatch\s*\(',
        r'\bfinally\s*{',
        r'\bthrow\s+',
        r'new\s+Error\('
    ]
    
    error_count = sum(len(re.findall(pattern, code)) for pattern in error_handling)
    if error_count > 0:
        problems['issues'].append(f"–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ ({error_count} –±–ª–æ–∫–æ–≤)")
        problems['total_score'] += error_count
        problems['categories']['error_handling'] += error_count
    
    # 8. –†–ê–ó–ú–ï–† –ò –°–õ–û–ñ–ù–û–°–¢–¨
    lines = code.split('\n')
    non_empty_lines = [line for line in lines if line.strip()]
    
    if len(non_empty_lines) > 50:
        problems['issues'].append(f"–î–ª–∏–Ω–Ω—ã–π –∫–æ–¥ ({len(non_empty_lines)} —Å—Ç—Ä–æ–∫)")
        problems['total_score'] += len(non_empty_lines) // 10
        problems['categories']['long_code'] += 1
    
    # 9. –°–ü–ï–¶–ò–§–ò–ß–ï–°–ö–ò–ï –ü–ê–¢–¢–ï–†–ù–´, –ö–û–¢–û–†–´–ï –°–õ–û–ñ–ù–û –ü–ê–†–°–ò–¢–¨
    tricky_patterns = [
        (r'{\s*\[.*\]:', 'computed_properties'),
        (r'\.\.\.', 'spread_operator'),
        (r'\?\?', 'nullish_coalescing'),
        (r'\?\.', 'optional_chaining'),
        (r'=>\s*{', 'arrow_functions_with_body'),
        (r'=>\s*\(', 'arrow_functions_with_parens'),
        (r'function\s*\*', 'generator_functions'),
        (r'\bclass\s+\w+\s+extends', 'class_inheritance'),
        (r'super\s*\(', 'super_calls'),
        (r'#\w+', 'private_fields')
    ]
    
    tricky_features = []
    for pattern, name in tricky_patterns:
        count = len(re.findall(pattern, code))
        if count > 0:
            tricky_features.append(f"{name}({count})")
            problems['total_score'] += count * 3  # –í—ã—Å–æ–∫–∏–π –≤–µ—Å –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
            problems['categories']['tricky_syntax'] += count
    
    if tricky_features:
        problems['issues'].append(f"–°–ª–æ–∂–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å: {', '.join(tricky_features)}")
    
    # 10. –ü–†–û–ë–õ–ï–ú–´ –ü–ê–†–°–ò–ù–ì–ê –ù–ê–®–ï–ì–û –ì–ï–ù–ï–†–ê–¢–û–†–ê
    parsing_issues = []
    
    # –í–ª–æ–∂–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Å—ã
    if re.search(r'class\s+\w+[^}]*class\s+\w+', code):
        parsing_issues.append("nested_classes")
        problems['total_score'] += 5
    
    # –ú–µ—Ç–æ–¥—ã —Å –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–º–∏ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞–º–∏
    complex_methods = re.findall(r'\w+\s*\([^)]{20,}\)\s*{', code)
    if complex_methods:
        parsing_issues.append(f"complex_method_signatures({len(complex_methods)})")
        problems['total_score'] += len(complex_methods) * 2
    
    # –§—É–Ω–∫—Ü–∏–∏ –≤–Ω—É—Ç—Ä–∏ –º–µ—Ç–æ–¥–æ–≤
    if re.search(r'{\s*[^}]*function\s+\w+', code):
        parsing_issues.append("nested_functions")
        problems['total_score'] += 3
    
    # –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤–Ω—É—Ç—Ä–∏ –∫–æ–¥–∞ (–º–æ–≥—É—Ç —Å–ª–æ–º–∞—Ç—å –ø–∞—Ä—Å–∏–Ω–≥)
    inline_comments = len(re.findall(r'//.*$', code, re.MULTILINE))
    block_comments = len(re.findall(r'/\*.*?\*/', code, re.DOTALL))
    
    if inline_comments > 10 or block_comments > 3:
        parsing_issues.append(f"many_comments({inline_comments + block_comments})")
        problems['total_score'] += 1
    
    if parsing_issues:
        problems['issues'].append(f"–ü—Ä–æ–±–ª–µ–º—ã –ø–∞—Ä—Å–∏–Ω–≥–∞: {', '.join(parsing_issues)}")
        problems['categories']['parsing_issues'] += len(parsing_issues)
    
    return problems

def calculate_max_nesting(code):
    """–í—ã—á–∏—Å–ª—è–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏"""
    max_depth = 0
    current_depth = 0
    
    for char in code:
        if char == '{':
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == '}':
            current_depth = max(0, current_depth - 1)
    
    return max_depth

def print_basic_stats(languages, categories, js_tasks, non_js_tasks):
    """–í—ã–≤–æ–¥–∏—Ç –±–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
    logger.info("\nüìà –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–û –Ø–ó–´–ö–ê–ú:")
    for lang, count in sorted(languages.items(), key=lambda x: x[1], reverse=True):
        logger.info(f"  {lang}: {count} –∑–∞–¥–∞—á")
    
    logger.info("\nüìà –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–û –ö–ê–¢–ï–ì–û–†–ò–Ø–ú:")
    for cat, count in sorted(categories.items(), key=lambda x: x[1], reverse=True):
        logger.info(f"  {cat}: {count} –∑–∞–¥–∞—á")
    
    logger.info(f"\nüéØ JavaScript –∑–∞–¥–∞—á: {len(js_tasks)}")
    logger.info(f"üéØ –ù–µ-JavaScript –∑–∞–¥–∞—á: {len(non_js_tasks)}")

def analyze_task_examples(js_tasks, non_js_tasks):
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–º–µ—Ä—ã –∑–∞–¥–∞—á"""
    logger.info("\nüî¨ –ü–†–ò–ú–ï–†–´ JAVASCRIPT –ó–ê–î–ê–ß:")
    for i, block in enumerate(js_tasks[:3]):
        logger.info(f"\n--- JS –ó–∞–¥–∞—á–∞ {i+1}: {block.blockTitle} ---")
        logger.info(f"ID: {block.id}")
        logger.info(f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {block.file.mainCategory} / {block.file.subCategory}")
        logger.info(f"–Ø–∑—ã–∫: {block.codeLanguage}")
        logger.info(f"–î–ª–∏–Ω–∞ –∫–æ–¥–∞: {len(block.codeContent)} —Å–∏–º–≤–æ–ª–æ–≤")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–æ–¥–∞
        code_lines = block.codeContent.split('\n')
        logger.info(f"–°—Ç—Ä–æ–∫ –∫–æ–¥–∞: {len(code_lines)}")
        logger.info("–ü–µ—Ä–≤—ã–µ 15 —Å—Ç—Ä–æ–∫:")
        for j, line in enumerate(code_lines[:15]):
            logger.info(f"  {j+1:2d}: {line}")
        if len(code_lines) > 15:
            logger.info("  ...")

def analyze_problematic_cases(problematic_cases):
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —Å–ª—É—á–∞–∏"""
    logger.info(f"\nüö® –ü–†–û–ë–õ–ï–ú–ù–´–ï –°–õ–£–ß–ê–ò ({len(problematic_cases)}):")
    
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
    problematic_cases.sort(key=lambda x: x[1]['total_score'], reverse=True)
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–∏–ø–∞–º –ø—Ä–æ–±–ª–µ–º
    problem_stats = defaultdict(int)
    for _, problems in problematic_cases:
        for category, count in problems['categories'].items():
            problem_stats[category] += count
    
    logger.info("\nüìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–†–û–ë–õ–ï–ú:")
    for problem_type, count in sorted(problem_stats.items(), key=lambda x: x[1], reverse=True):
        logger.info(f"  {problem_type}: {count} —Å–ª—É—á–∞–µ–≤")
    
    # –¢–æ–ø —Å–∞–º—ã—Ö —Å–ª–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
    logger.info("\nüî• –¢–û–ü-5 –°–ê–ú–´–• –°–õ–û–ñ–ù–´–• –°–õ–£–ß–ê–ï–í:")
    for i, (block, problems) in enumerate(problematic_cases[:5]):
        logger.info(f"\n--- –°–ª–æ–∂–Ω—ã–π —Å–ª—É—á–∞–π {i+1} (—Å–ª–æ–∂–Ω–æ—Å—Ç—å: {problems['total_score']}) ---")
        logger.info(f"ID: {block.id}")
        logger.info(f"–ó–∞–¥–∞—á–∞: {block.blockTitle}")
        logger.info(f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {block.file.mainCategory} / {block.file.subCategory}")
        logger.info(f"–ü—Ä–æ–±–ª–µ–º—ã: {'; '.join(problems['issues'])}")
        logger.info(f"–î–ª–∏–Ω–∞: {len(block.codeContent)} —Å–∏–º–≤–æ–ª–æ–≤")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —á–∞—Å—Ç–∏ –∫–æ–¥–∞
        logger.info("–ü—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ –∫–æ–¥–µ:")
        show_problematic_patterns(block.codeContent)

def show_problematic_patterns(code):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤ –∫–æ–¥–µ"""
    lines = code.split('\n')
    
    # –ò—â–µ–º —Å–ª–æ–∂–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
    for i, line in enumerate(lines):
        if any(pattern in line for pattern in ['class ', 'function ', '=>', 'async ', 'await ']):
            logger.info(f"  {i+1:2d}: {line.strip()}")

def analyze_code_patterns(js_tasks):
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∫–æ–¥–∞"""
    logger.info("\nüîç –ê–ù–ê–õ–ò–ó –ü–ê–¢–¢–ï–†–ù–û–í –ö–û–î–ê:")
    
    patterns = {
        'classes_with_inheritance': 0,
        'classes_with_static_methods': 0,
        'classes_with_getters_setters': 0,
        'arrow_functions': 0,
        'async_functions': 0,
        'generator_functions': 0,
        'destructuring': 0,
        'spread_operator': 0,
        'template_literals': 0,
        'modules': 0
    }
    
    for block in js_tasks:
        code = block.codeContent
        
        if re.search(r'class\s+\w+\s+extends', code):
            patterns['classes_with_inheritance'] += 1
        
        if re.search(r'static\s+\w+', code):
            patterns['classes_with_static_methods'] += 1
        
        if re.search(r'get\s+\w+\s*\(|set\s+\w+\s*\(', code):
            patterns['classes_with_getters_setters'] += 1
        
        if '=>' in code:
            patterns['arrow_functions'] += 1
        
        if 'async ' in code or 'await ' in code:
            patterns['async_functions'] += 1
        
        if 'function*' in code or 'yield ' in code:
            patterns['generator_functions'] += 1
        
        if re.search(r'{\s*\w+\s*}|{\s*\w+:', code):
            patterns['destructuring'] += 1
        
        if '...' in code:
            patterns['spread_operator'] += 1
        
        if '`' in code:
            patterns['template_literals'] += 1
        
        if 'import ' in code or 'export ' in code:
            patterns['modules'] += 1
    
    for pattern, count in patterns.items():
        if count > 0:
            logger.info(f"  {pattern}: {count} –∑–∞–¥–∞—á")

def test_generator_on_real_data(sample_tasks):
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç –Ω–∞—à –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
    logger.info(f"\nüß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ì–ï–ù–ï–†–ê–¢–û–†–ê –ù–ê {len(sample_tasks)} –†–ï–ê–õ–¨–ù–´–• –ó–ê–î–ê–ß–ê–•:")
    
    # –ò–º–∏—Ç–∏—Ä—É–µ–º —Ä–∞–±–æ—Ç—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ (–±–µ–∑ –∏–º–ø–æ—Ä—Ç–∞ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –∫–æ–¥–∞)
    for i, block in enumerate(sample_tasks):
        logger.info(f"\n--- –¢–µ—Å—Ç {i+1}: {block.blockTitle} ---")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫ –Ω–∞—à –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –æ–ø—Ä–µ–¥–µ–ª–∏—Ç —ç—Ç—É –∑–∞–¥–∞—á—É
        is_js = is_javascript_task(block)
        logger.info(f"–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –∫–∞–∫ JS: {is_js}")
        
        if is_js:
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º, —á—Ç–æ –º–æ–∂–µ—Ç –ø–æ–π—Ç–∏ –Ω–µ —Ç–∞–∫ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —à–∞–±–ª–æ–Ω–∞
            potential_issues = []
            code = block.codeContent
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
            if code.count('class') > 1:
                potential_issues.append("–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Å—ã")
            
            if re.search(r'class[^{]*{[^}]*class', code):
                potential_issues.append("–í–ª–æ–∂–µ–Ω–Ω—ã–µ –∫–ª–∞—Å—Å—ã")
            
            if code.count('{') != code.count('}'):
                potential_issues.append("–ù–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–∫–æ–±–∫–∏")
            
            if re.search(r'//.*{|}', code):
                potential_issues.append("–°–∫–æ–±–∫–∏ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è—Ö")
            
            if '/*' in code and '*/' in code:
                potential_issues.append("–ë–ª–æ—á–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏")
            
            if potential_issues:
                logger.info(f"‚ö†Ô∏è  –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã: {', '.join(potential_issues)}")
            else:
                logger.info("‚úÖ –î–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")

def is_javascript_task(block):
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∑–∞–¥–∞—á–∞ JavaScript –∑–∞–¥–∞—á–µ–π (–∫–æ–ø–∏—è –ª–æ–≥–∏–∫–∏ —Å —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞)"""
    JS_CATEGORIES = ['JS –¢–ï–û–†–ò–Ø', 'REACT', 'NODE.JS', 'TYPESCRIPT', 'JS']
    JS_LANGUAGES = ['javascript', 'typescript', 'js', 'ts']
    
    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–∑—ã–∫ –∫–æ–¥–∞
    if block.codeLanguage:
        lang = block.codeLanguage.lower()
        if lang in JS_LANGUAGES:
            return True
    
    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ñ–∞–π–ª–∞
    if block.file:
        main_cat = block.file.mainCategory.upper() if block.file.mainCategory else ""
        sub_cat = block.file.subCategory.upper() if block.file.subCategory else ""
        
        if any(cat in main_cat or cat in sub_cat for cat in JS_CATEGORIES):
            return True
    
    # 3. –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –∫–æ–¥–∞
    if block.codeContent:
        js_patterns = [
            r'class\s+\w+',
            r'function\s+\w+\s*\(',
            r'const\s+\w+\s*=',
            r'let\s+\w+\s*=',
            r'=>\s*{',
            r'console\.log',
            r'require\(',
            r'import\s+.*from',
            r'export\s+(default|const|function|class)'
        ]
        return any(re.search(pattern, block.codeContent) for pattern in js_patterns)
    
    return False

if __name__ == "__main__":
    analyze_tasks() 