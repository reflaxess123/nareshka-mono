{
  "task_analyses": [
    {
      "id": "cmbhuxs160001hxt8uz4eqqjd",
      "title": "1. sum",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите функцию sum, которая принимает массив чисел, в том числе содержащий вложенные массивы, и возвращает сумму всех чисел в массиве. Для решения задачи используйте рекурсию для обработки вложенных массивов.\\n",
      "code_content": "function sum(arr) {  \n    return arr.reduce((total, item) => {  \n        if (Array.isArray(item)) {  \n            return total + sum(item); // рекурсивно суммируем вложенные массивы  \n        }  \n        return total + item; // добавляем число к общей сумме  \n    }, 0);  \n}\n  \n// Пример использования  \nconsole.log(sum([1, 1, 1, [2, 1], [1, [1, [1], 3]]])); // Вернет 12",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "functions",
        "conditionals",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "sum",
        "item",
        "reduce",
        "total",
        "array",
        "isarray",
        "arr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs2l0002hxt8dctlk266",
      "title": "2. findMinMax",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая принимает массив чисел и возвращает объект, содержащий минимальное и максимальное значение из этого массива.\\nИнициализируйте переменные min и max первым элементом массива.Пройдите по массиву начиная со второго элемента и сравните каждый элемент с текущими значениями min и max.Если текущий элемент меньше min, обновите значение min.Если текущий элемент больше max, обновите значение max.Верните объект с ключами min и max, содержащими найденные значения...",
      "code_content": "function (arr) {\n    let min = arr[0];\n    let max = arr[0];\n\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    return { min, max };\n}",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops"
      ],
      "js_features_used": [],
      "keywords": [
        "max",
        "min",
        "arr",
        "findminmax"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 47,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs3r0003hxt832dkijfk",
      "title": "3. removeEvenIndexedElements",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию removeEvenIndexedElements, которая принимает массив и удаляет из него элементы, находящиеся на чётных индексах. Итоговый массив должен содержать только элементы, расположенные на нечётных позициях (индексация начинается с нуля).\\nОбходите массив в обратном порядке, чтобы избежать проблем с изменением индексов при удалении элементов.Для каждого элемента проверяйте, является ли его индекс чётным.Если индекс чётный, удаляйте элемент из массива с помощью метода s...",
      "code_content": "const removeEvenIndexedElements = (arr) => {  \n    for (let i = arr.length - 1; i >= 0; i--) {  \n        if (i % 2 === 0) {  \n            arr.splice(i, 1);  \n        }  \n    }    \n    return arr;  \n};  \n  \nconst data = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"];  \n  \nconsole.log(removeEvenIndexedElements(data)); // [\"B\", \"D\", \"F\", \"H\", \"J\"]",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "splice",
        "arr",
        "data",
        "removeevenindexedelements"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.68,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs4l0004hxt8hdong1mr",
      "title": "4. Concatenation of Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая принимает массив чисел и возвращает новый массив, являющийся конкатенацией исходного массива с самим собой. Задача предлагает несколько способов решения:\\nС использованием метода concat.С использованием оператора распространения (spread).С использованием метода push с двумя проходами по исходному массиву.С использованием цикла for, при котором массив создается с заранее определённой длиной.\\nПример:Для входного массива [1, 2, 1] результат должен быть...",
      "code_content": "// concat  \nfunction getConcatenation(nums) {  \n    return nums.concat(nums);  \n}  \n  \n// spread  \nfunction getConcatenation1(nums) {  \n    return [...nums, ...nums];  \n}  \n  \n// push  \nfunction getConcatenation2(nums) {  \n    const ans = [];  \n    nums.forEach(num => ans.push(num));  // Первый проход  \n    nums.forEach(num => ans.push(num));  // Второй проход  \n    return ans;  \n}  \n  \n// for  \nfunction getConcatenation3(nums) {  \n    const len = nums.length;  \n    const ans = new Array(2 * len);  \n  \n    for (let i = 0; i < len; i++) {  \n        ans[i] = nums[i];  \n        ans[i + len] = nums[i];  \n    }  \n  \n    return ans;  \n}  \n  \nconsole.log(getConcatenation([1, 2, 1]));",
      "code_language": "js",
      "code_lines": 26,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средний код (26 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_forEach"
      ],
      "keywords": [
        "spread",
        "concat",
        "getconcatenation",
        "num",
        "ans",
        "len",
        "concatenation",
        "array",
        "foreach",
        "nums"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 56,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 3,
      "pedagogical_type": "example",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs5g0005hxt8x2y5feb2",
      "title": "5. Contains Duplicate",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая определяет, содержит ли массив дубликаты. Решение должно вернуть true, если в массиве встречается хотя бы один повторяющийся элемент, и false в противном случае. Для этого предложены несколько подходов:\\nС использованием объекта Map и итерации с for...of:Если элемент уже есть в Map, возвращается true.Иначе элемент добавляется в Map.С использованием обычного объекта для хранения элементов:Если элемент уже присутствует в объекте, возвращается true.Если...",
      "code_content": "// map + for of  \nconst containsDuplicate = nums => {  \n    const map = new Map();  \n  \n    for (let num of nums) {  \n        if (map.has(num)) return true;  \n        map.set(num, 1);  \n    }  \n    return false;  \n};  \n  \n// obj + for of  \nconst containsDuplicate2 = nums => {  \n    let obj = {};  \n    for (let num of nums) {  \n        if (obj[num]) return true;  \n        obj[num] = true;  \n    }  \n    return false;  \n};  \n  \n// set one-liner  \nconst containsDuplicate1 = nums => new Set(nums).size !== nums.length;  \n  \nlet nums = [1,2,3,4,2]  \n  \n// console.log(containsDuplicate2(nums))",
      "code_language": "js",
      "code_lines": 22,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (22 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "num",
        "obj",
        "size",
        "map",
        "contains",
        "nums",
        "containsduplicate",
        "set",
        "has",
        "duplicate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 66,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 4,
      "pedagogical_type": "exercise",
      "text_complexity": 0.88,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs6c0006hxt8x2p6v3wk",
      "title": "6. Chunk Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая делит массив на подмассивы (чанки) заданного размера. Если элементы массива не могут быть равномерно распределены по чанкам, последний чанк может содержать меньше элементов, чем задано. Задача должна быть решена двумя способами:\\nС использованием цикла for:Проходите по массиву с шагом, равным размеру чанка.Используйте метод slice для создания подмассива и добавляйте его в результирующий массив.С использованием метода reduce:Итерируйте по массиву, доб...",
      "code_content": "// for  \nconst chunk = (arr, size) => {  \n    const result = [];  \n    for (let i = 0; i < arr.length; i += size) {  \n        result.push(arr.slice(i, i + size));  \n    }  \n    return result;  \n};  \n  \n// reduce  \nconst chunk2 = (arr, size) => {  \n    return arr.reduce((chunkedArray, element) => {  \n        const lastChunk = chunkedArray[chunkedArray.length - 1];  \n        if (!lastChunk || lastChunk.length === size) {  \n            chunkedArray.push([element]);  \n        } else {  \n            lastChunk.push(element);  \n        }  \n        return chunkedArray;  \n    }, []);  \n};  \n  \nconst arr = [1, 2, 3, 4, 5, 6, 7];  \nconst size = 1;  \n  \nconsole.log(chunk(arr, size));  \nconsole.log(chunk2(arr, size));",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "lastchunk",
        "slice",
        "reduce",
        "size",
        "array",
        "chunkedarray",
        "element",
        "result",
        "arr",
        "chunk"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 67,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.8,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs790007hxt8g1jizp82",
      "title": "7. getRandom",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая создает массив длины n, состоящий из уникальных случайных чисел. Для этого необходимо:\\nНаписать функцию getRand, генерирующую случайное число с одним знаком после запятой.Использовать объект Set для хранения уникальных значений.Добавлять в Set новые случайные числа до тех пор, пока его размер не станет равен n.Преобразовать Set в массив и вернуть его.Вывести результат работы функции для проверки.\\n",
      "code_content": "// создать массив длины n, состоящий из уникальных случайных элементов  \nconst getRand = () => Math.random().toFixed(1);  \n  \nfunction getUniqRandN(n) {  \n    const uniqueNumbers = new Set();  \n  \n    while (uniqueNumbers.size < n) {  \n        uniqueNumbers.add(getRand());  \n    }  \n  \n    return Array.from(uniqueNumbers);  \n}  \n  \nconsole.log(getUniqRandN(5));",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "getrandom",
        "random",
        "size",
        "array",
        "getuniqrandn",
        "math",
        "tofixed",
        "set",
        "add",
        "from",
        "getrand",
        "uniquenumbers"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 0.58,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs840008hxt8a0rxzu9x",
      "title": "8. maxElementIndex",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию findMaxIndex, которая принимает массив чисел и возвращает индекс максимального элемента. Если массив пуст, функция должна вернуть -1. Для реализации:\\nЕсли массив пуст, сразу верните -1.Инициализируйте переменные для хранения максимального значения и его индекса, используя первый элемент массива.Пройдите по массиву начиная со второго элемента:Если текущий элемент больше текущего максимума, обновите значение максимума и запомните его индекс.Верните индекс макс...",
      "code_content": "function findMaxIndex(arr) {  \n    // Если массив пуст, возвращаем -1  \n    if (arr.length === 0) return -1;  \n  \n    // Инициализация переменных для хранения максимального значения и его индекса  \n    let maxIndex = 0;  \n    let maxValue = arr[0];  \n  \n    // Проход по массиву, начиная со второго элемента  \n    for (let i = 1; i < arr.length; i++) {  \n        if (arr[i] > maxValue) {  \n            maxValue = arr[i];  \n            maxIndex = i;  \n        }  \n    }  \n    // Возврат индекса максимального элемента  \n    return maxIndex;  \n}  \n  \nconst array1 = [1, 3, 7, 2, 5];  \nconst array2 = [10, 20, 30, 40, 50];  \nconst emptyArray = [];  \n  \nconsole.log(findMaxIndex(array1)); // 2, так как 7 — максимальный элемент  \nconsole.log(findMaxIndex(array2)); // 4, так как 50 — максимальный элемент  \nconsole.log(findMaxIndex(emptyArray)); // -1, так как массив пуст",
      "code_language": "js",
      "code_lines": 22,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (22 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "searching",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "emptyarray",
        "findmaxindex",
        "maxvalue",
        "arr",
        "maxelementindex",
        "maxindex"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 55,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 7,
      "pedagogical_type": "exercise",
      "text_complexity": 0.6,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs8z0009hxt8fsu4q7ua",
      "title": "9. between",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию between, которая принимает два числа: min и max, и возвращает другую функцию. Возвращаемая функция принимает значение и проверяет, находится ли оно строго между min и max (то есть больше min и меньше max). Это позволяет использовать функцию between в качестве фильтра для массивов, чтобы выбрать значения, удовлетворяющие заданному диапазону.\\n",
      "code_content": "function between(min, max) {\n    return function (value) {\n        return value > min && value < max;\n    };\n}\n\nconst arr = [1, 2, 3, 4, 5, 6];\n\n// Используем between(3, 6) как фильтр\nconst range = arr.filter(between(3, 6));\n\nconsole.log(range); // [4, 5]",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "array_filter"
      ],
      "keywords": [
        "max",
        "range",
        "filter",
        "value",
        "between",
        "arr",
        "min"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 38,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.52,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxs9s000ahxt88qwbi2pw",
      "title": "10. remove duplicates",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, в котором могут встречаться дубликаты (объекты с одинаковыми значениями). Необходимо удалить повторяющиеся объекты, сохранив только первый экземпляр каждого уникального объекта. При этом можно использовать сериализацию объекта в строку (например, через JSON.stringify) для сравнения.\\n",
      "code_content": "const arr = [{ a: 1 }, { b: 2 }, { a: 1 }, { d: 4 }];  \n  \n// Преобразуем каждый объект в строку и создаем Map, чтобы сохранить только уникальные объекты  \nconst uniqueArr = Array.from(  \n    new Map(arr.map(item => [JSON.stringify(item), item])).values()  \n);  \n  \nconsole.log(uniqueArr); // [{ a: 1 }, { b: 2 }, { d: 4 }]",
      "code_language": "js",
      "code_lines": 6,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_map"
      ],
      "keywords": [
        "duplicates",
        "values",
        "item",
        "stringify",
        "array",
        "map",
        "json",
        "remove",
        "arr",
        "from",
        "uniquearr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 9,
      "pedagogical_type": "example",
      "text_complexity": 0.37,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy10w0065hxt811552rzr",
      "title": "HeavyFunc (ленивая инициализация)",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "2. IT-One"
      ],
      "text_content": "",
      "code_content": "const heavyFunc = (count) => count;\nconst LazyInit = ({ count }) => {\n  const [state, setState] = useState(() => heavyFunc(count));\n  return <button onClick={() => setState((prev) => prev + 1)}>{state}</button>;\n};",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "events"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring"
      ],
      "keywords": [
        "button",
        "usestate",
        "count",
        "prev",
        "heavyfunc",
        "onclick",
        "lazyinit",
        "state",
        "setstate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 18,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 15,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsal000bhxt8dfksgob4",
      "title": "11. findUnique",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите несколько функций, которые принимают массив чисел и возвращают новый массив, содержащий только уникальные элементы (элементы, встречающиеся ровно один раз). Решение должно быть реализовано различными способами:\\nС использованием Map:Создаем карту для подсчета вхождений каждого элемента.Фильтруем исходный массив, оставляя только элементы, встречающиеся один раз.Добавление метода в прототип Array:Аналогичное решение, но реализованное как метод для массива.С использование...",
      "code_content": "const arr = [10, 5, 10, 0, 10, 6, 6, 7, 2, 9, 9];  \n  \n// 1. С использованием Map  \nconst findUniqueMap = (array) => {  \n    const countMap = new Map();  \n  \n    array.forEach(item => {  \n        countMap.set(item, (countMap.get(item) || 0) + 1);  \n    });  \n  \n    return array.filter(item => countMap.get(item) === 1);  \n};  \n  \nconsole.log(findUniqueMap(arr));  \n  \n// 2. Добавление метода в прототип Array  \nArray.prototype.findUniqueMap = function() {  \n    const countMap = new Map();  \n  \n    this.forEach(item => {  \n        countMap.set(item, (countMap.get(item) || 0) + 1);  \n    });  \n  \n    return this.filter(item => countMap.get(item) === 1);  \n};  \n  \nconsole.log(arr.findUniqueMap());  \n  \n// 3. С использованием filter + indexOf  \nconst findUniqueFilter = (array) => {  \n    return array.filter(item => array.indexOf(item) === array.lastIndexOf(item));  \n};  \n  \nconsole.log(findUniqueFilter(arr));  \n  \n// 4. С использованием reduce  \nconst findUniqueReduce = (array) => {  \n    const frequencyMap = array.reduce((acc, item) => {  \n        acc[item] = (acc[item] || 0) + 1;  \n        return acc;  \n    }, {});  \n  \n    return array.filter(item => frequencyMap[item] === 1);  \n};  \n  \nconsole.log(findUniqueReduce(arr));  \n  \n// 5. С использованием forEach  \nconst findUniqueForEach = (array) => {  \n    const unique = new Set();  \n    const duplicates = new Set();  \n  \n    array.forEach(item => {  \n        if (unique.has(item)) {  \n            duplicates.add(item);  \n            unique.delete(item);  \n        } else if (!duplicates.has(item)) {  \n            unique.add(item);  \n        }  \n    });  \n  \n    return array.filter(item => unique.has(item));  \n};  \n  \nconsole.log(findUniqueForEach(arr));",
      "code_language": "js",
      "code_lines": 48,
      "complexity_score": 5.0,
      "difficulty_factors": [
        "Средний код (48 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)",
        "Средние концепции (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "searching",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter",
        "array_reduce",
        "array_forEach"
      ],
      "keywords": [
        "add",
        "get",
        "set",
        "finduniqueforeach",
        "indexof",
        "duplicates",
        "acc",
        "filter",
        "prototype",
        "unique",
        "lastindexof",
        "finduniquefilter",
        "array",
        "map",
        "foreach",
        "finduniquereduce",
        "arr",
        "delete",
        "frequencymap",
        "item",
        "finduniquemap",
        "reduce",
        "has",
        "findunique",
        "countmap"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 108,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 10,
      "pedagogical_type": "exercise",
      "text_complexity": 1.5,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsbg000chxt8q5heziq4",
      "title": "12. getOccurCount",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите функцию, которая принимает массив и возвращает объект, где ключами являются элементы массива, а значениями — количество раз, которое эти элементы встречаются. Для решения задачи можно использовать метод reduce, который итерируется по массиву и накапливает результат в виде объекта.\\n",
      "code_content": "function getOccurCount(arr) {  \n    return arr.reduce((acc, item) => {  \n        acc[item] = (acc[item] || 0) + 1;  \n        return acc;  \n    }, {});  \n}  \n  \nconsole.log(getOccurCount([\"a\", \"b\", \"c\", \"b\", \"b\", \"a\"]));  \n// { a: 2, b: 3, c: 1 }",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "item",
        "acc",
        "reduce",
        "arr",
        "getoccurcount"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 0.4,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsca000dhxt8m5yyv4gm",
      "title": "13. mergeUnique",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая объединяет два отсортированных массива чисел, возвращая новый массив, содержащий только уникальные элементы из обоих массивов, также отсортированные по возрастанию. Задачу можно решить двумя способами:\\nС использованием Set:Объедините два массива с помощью оператора расширения, затем создайте Set для удаления дубликатов и преобразуйте его обратно в массив. После этого отсортируйте массив.С использованием двух указателей:Используйте два указателя для ...",
      "code_content": "// Решение 1: С использованием Set  \nfunction mergeUniqueWithSet(arr1, arr2) {  \n    return [...new Set([...arr1, ...arr2])].sort((a, b) => a - b);  \n}  \n  \n// Решение 2: С использованием двух указателей  \nfunction mergeUniqueWithPointers(arr1, arr2) {  \n    const result = [];  \n    let i = 0;  \n    let j = 0;  \n  \n    while (i < arr1.length && j < arr2.length) {  \n        if (arr1[i] === arr2[j]) {  \n            if (result[result.length - 1] !== arr1[i]) {  \n                result.push(arr1[i]);  \n            }  \n            i++;  \n            j++;  \n        } else if (arr1[i] < arr2[j]) {  \n            if (result[result.length - 1] !== arr1[i]) {  \n                result.push(arr1[i]);  \n            }  \n            i++;  \n        } else {  \n            if (result[result.length - 1] !== arr2[j]) {  \n                result.push(arr2[j]);  \n            }  \n            j++;  \n        }  \n    }  \n  \n    while (i < arr1.length) {  \n        if (result[result.length - 1] !== arr1[i]) {  \n            result.push(arr1[i]);  \n        }  \n        i++;  \n    }  \n          \n    while (j < arr2.length) {  \n        if (result[result.length - 1] !== arr2[j]) {  \n            result.push(arr2[j]);  \n        }  \n        j++;  \n    }  \n  \n    return result;  \n}  \n  \nconst array1 = [1, 3, 4, 6];  \nconst array2 = [1, 3, 7, 9];  \n  \nconsole.log(\"Using Set:\", mergeUniqueWithSet(array1, array2));        // [1, 3, 4, 6, 7, 9]  \nconsole.log(\"Using Pointers:\", mergeUniqueWithPointers(array1, array2)); // [1, 3, 4, 6, 7, 9]",
      "code_language": "js",
      "code_lines": 46,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (46 строк)",
        "Средняя вложенность (4)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "mergeuniquewithpointers",
        "result",
        "mergeunique",
        "set",
        "mergeuniquewithset",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 88,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 12,
      "pedagogical_type": "exercise",
      "text_complexity": 0.69,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsd4000ehxt8nq3amqoc",
      "title": "14. mergeSortedArrays",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите функцию, которая принимает два отсортированных массива чисел и объединяет их в один отсортированный массив. Решение можно реализовать двумя способами:\\nОбъединить два массива, а затем отсортировать полученный массив.Использовать два указателя для одновременного обхода обоих массивов и последовательного добавления элементов в результирующий массив, что позволяет объединить массивы за линейное время.\\n",
      "code_content": "const mergeSortedArrays = (arr1, arr2) =>  \n    [...arr1, ...arr2].sort((a, b) => a - b);  \n  \nconsole.log(mergeSortedArrays([1, 3, 5], [2, 4, 6])); // Ожидаемый результат: [1, 2, 3, 4, 5, 6]  \n  \n  \nconst mergeSortedArrays2 = (arr1, arr2) => {  \n    const result = [];  \n    let i = 0, j = 0;  \n  \n    while (i < arr1.length && j < arr2.length) {  \n        if (arr1[i] < arr2[j]) {  \n            result.push(arr1[i++]);  \n        } else {  \n            result.push(arr2[j++]);  \n        }  \n    }  \n    // Добавляем оставшиеся элементы из arr1 или arr2  \n    return result.concat(arr1.slice(i)).concat(arr2.slice(j));  \n};  \n  \n// Пример использования:  \nconsole.log(mergeSortedArrays2([1, 3, 5], [2, 4, 6])); // Ожидаемый результат: [1, 2, 3, 4, 5, 6]",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "concat",
        "slice",
        "mergesortedarrays",
        "result",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 54,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 13,
      "pedagogical_type": "exercise",
      "text_complexity": 0.49,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxse0000fhxt8nb582gbd",
      "title": "15. Sort Array By Parity",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел nums. Необходимо отсортировать массив так, чтобы все чётные числа оказались в начале массива, а нечётные — в конце. При этом порядок чисел внутри групп не имеет значения. Решение реализовано с использованием двух указателей (in-place):\\nИнициализируйте два указателя: left для начала массива и right для конца.Перемещайте указатель left вправо до тех пор, пока не встретите нечётное число.Перемещайте указатель right влево до тех пор, пока не встретите чётное число...",
      "code_content": "function sortArrayByParity(nums) {  \n    let left = 0;  \n    let right = nums.length - 1;  \n  \n    while (left < right) {  \n        // Сдвигаем левый указатель вправо, пока он не найдет четное число  \n        while (left < right && nums[left] % 2 === 0) {  \n            left++;  \n        }  \n        // Сдвигаем правый указатель влево, пока он не найдет нечетное число  \n        while (left < right && nums[right] % 2 !== 0) {  \n            right--;  \n        }  \n        // Меняем местами найденные нечетное и четное числа  \n        if (left < right) {  \n            [nums[left], nums[right]] = [nums[right], nums[left]];  \n            left++;  \n            right--;  \n        }  \n    }    \n    return nums;  \n}  \n  \nconsole.log(sortArrayByParity([3, 1, 2, 4])); // [4, 2, 3, 1]  \nconsole.log(sortArrayByParity([1, 2, 3, 4]));  // [4, 2, 3, 1]  \nconsole.log(sortArrayByParity([2, 4, 6, 8]));  // [2, 4, 6, 8]  \nconsole.log(sortArrayByParity([1, 3, 5, 7]));  // [1, 3, 5, 7]",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "sorting",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "parity",
        "place",
        "sortarraybyparity",
        "array",
        "right",
        "nums",
        "left",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 79,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 14,
      "pedagogical_type": "practice",
      "text_complexity": 0.87,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxseu000ghxt8opsb2bi3",
      "title": "16. calculateAverageWeightOfLemons",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, представляющих фрукты с их типом и весом. Необходимо написать функцию, которая вычисляет средний вес для заданного типа фрукта. В данном примере рассчитывается средний вес для \"lemon\".\\n",
      "code_content": "const array = [  \n    { fruit: 'lemon', weight: 10 },  \n    { fruit: 'apple', weight: 10 },  \n    { fruit: 'lemon', weight: 10 },  \n    { fruit: 'lemon', weight: 40 },  \n];  \n  \nconst calculateAverageWeightOfLemons = (fruitsArray, fruitName) => {  \n    const filteredFruits = fruitsArray.filter(item => item.fruit === fruitName);  \n    const totalWeight = filteredFruits.reduce((acc, current) => acc + current.weight, 0);  \n    return totalWeight / filteredFruits.length;  \n};  \n  \nconst averageWeight = calculateAverageWeightOfLemons(array, 'lemon');  \nconsole.log(averageWeight); // Вывод: 20\n",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter",
        "array_reduce"
      ],
      "keywords": [
        "weight",
        "item",
        "averageweight",
        "totalweight",
        "fruit",
        "filter",
        "reduce",
        "acc",
        "array",
        "filteredfruits",
        "fruitname",
        "current",
        "calculateaverageweightoflemons",
        "fruitsarray"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 15,
      "pedagogical_type": "example",
      "text_complexity": 0.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsfo000hhxt8oipcq3ea",
      "title": "17. findMaxIn2DArray",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите функцию findMaxIn2DArray, которая принимает двумерный массив чисел и находит максимальный элемент вместе с его позицией. Функция должна возвращать объект с двумя свойствами:\\nel — максимальный найденный элемент.index — массив из двух чисел, представляющих индексы максимального элемента в двумерном массиве (первый индекс — номер подмассива, второй — позиция элемента в подмассиве).\\n",
      "code_content": "function findMaxIn2DArray(arr) {  \n    let maxElement = -Infinity;  \n    let maxIndex = [-1, -1];  \n  \n    for (let i = 0; i < arr.length; i++) {  \n        const subArray = arr[i];  \n        for (let j = 0; j < subArray.length; j++) {  \n            if (subArray[j] > maxElement) {  \n                maxElement = subArray[j];  \n                maxIndex = [i, j];  \n            }  \n        }  \n    }  \n    return { el: maxElement, index: maxIndex };  \n}  \n  \nconst array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];  \n  \nconsole.log(findMaxIn2DArray(array)); // { el: 9, index: [2, 2] }",
      "code_language": "js",
      "code_lines": 16,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "searching",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "index",
        "infinity",
        "array",
        "nel",
        "arr",
        "maxelement",
        "subarray",
        "maxindex"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 44,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 16,
      "pedagogical_type": "exercise",
      "text_complexity": 0.51,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsgj000ihxt81mj8tdm1",
      "title": "18. getLastDecisions",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Даны два массива объектов, представляющих решения, где каждый объект имеет поля id и result. Массивы отсортированы по возрастанию id. Необходимо объединить два массива, выбирая последние (наибольшие id) решения так, чтобы итоговый массив содержал k самых последних решений. Решение должно осуществляться с использованием двух указателей, которые двигаются с конца каждого массива, после чего результат разворачивается для получения правильного порядка.\\n",
      "code_content": "const getDecisions1 = [  \n    { id: 1, result: 'approved' },  \n    { id: 3, result: 'waiting' },  \n    { id: 15, result: 'approved' },  \n    { id: 20, result: 'approved' },  \n    { id: 26, result: 'waiting' },  \n    { id: 30, result: 'approved' },  \n];  \n  \nconst getDecisions2 = [  \n    { id: 2, result: 'approved' },  \n    { id: 4, result: 'waiting' },  \n    { id: 14, result: 'approved' },  \n    { id: 16, result: 'waiting' },  \n    { id: 23, result: 'waiting' },  \n    { id: 31, result: 'approved' },  \n    { id: 32, result: 'approved' },  \n];  \n  \nconst getLastDecisions = (decisions1, decisions2, k) => {  \n    let merged = [];  \n    let i = decisions1.length - 1;  \n    let j = decisions2.length - 1;  \n  \n    while ((i >= 0 || j >= 0) && merged.length < k) {  \n        const id1 = i >= 0 ? decisions1[i].id : -Infinity;  \n        const id2 = j >= 0 ? decisions2[j].id : -Infinity;  \n  \n        if (id1 > id2) {  \n            merged.push(decisions1[i]);  \n            i--;  \n        } else {  \n            merged.push(decisions2[j]);  \n            j--;  \n        }  \n    }  \n    return merged.reverse();  \n};  \n  \nconsole.log(getLastDecisions(getDecisions1, getDecisions2, 6));  \n  \n// Ожидаемый вывод =>   \n// [  \n//     { id: 20, result: 'approved' },  \n//     { id: 23, result: 'waiting' },  \n//     { id: 26, result: 'waiting' },  \n//     { id: 30, result: 'approved' },  \n//     { id: 31, result: 'approved' },  \n//     { id: 32, result: 'approved' }  \n// ]",
      "code_language": "js",
      "code_lines": 44,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (44 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "getlastdecisions",
        "infinity",
        "merged",
        "reverse",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 82,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 17,
      "pedagogical_type": "practice",
      "text_complexity": 0.59,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxshd000jhxt86edflvmv",
      "title": "19. intersectArrays",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Даны два массива. Необходимо найти их пересечение, то есть элементы, присутствующие в обоих массивах. Результирующий массив должен содержать уникальные элементы (без повторений). Решение может быть реализовано с использованием структуры данных Set для эффективной проверки вхождения элементов.\\n",
      "code_content": "function intersectArrays(array1, array2) {  \n    const set = new Set(array1); // Уникальные элементы из первого массива  \n    return [...new Set(array2.filter(item => set.has(item)))]; // Уникальные пересечения  \n}  \n  \nconst array1 = [1, 2, 2, 1];  \nconst array2 = [2, 2];  \n  \nconst result = intersectArrays(array1, array2);  \n  \nconsole.log(result); // [2]",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_filter"
      ],
      "keywords": [
        "item",
        "filter",
        "intersectarrays",
        "result",
        "has",
        "set"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 18,
      "pedagogical_type": "practice",
      "text_complexity": 0.37,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsi8000khxt8miwsvf7a",
      "title": "20. groupById",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию groupById, которая принимает массив объектов, где каждый объект имеет свойство id. Функция должна вернуть объект, где ключами являются значения свойства id, а значениями — соответствующие объекты из массива.\\n",
      "code_content": "const arrayOfObjects = [  \n    { id: 0, name: 'first' },  \n    { id: 1, name: 'second' },  \n    { id: 2, name: 'third' },  \n];  \n  \nfunction groupById(array) {  \n    return array.reduce((acc, obj) => {  \n        acc[obj.id] = obj;  \n        return acc;  \n    }, {});  \n}  \n  \n// Пример использования  \nconst result = groupById(arrayOfObjects);  \nconsole.log(result);  \n  \n// Ожидаемый вывод:  \n// {  \n//     0: { id: 0, name: 'first' },  \n//     1: { id: 1, name: 'second' },  \n//     2: { id: 2, name: 'third' }  \n// }",
      "code_language": "js",
      "code_lines": 20,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "name",
        "acc",
        "obj",
        "reduce",
        "array",
        "arrayofobjects",
        "result",
        "groupbyid"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 37,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 19,
      "pedagogical_type": "exercise",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxydy004uhxt8pp8z6lbv",
      "title": "16. fuzzysearch",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Поиск подстроки в строке (Fuzzy Search)\nНапишите функцию, которая проверяет, содержатся ли все символы одной строки в другой в том же порядке.\\n",
      "code_content": "\nfunction fuzzysearch(needle, stack) {  \n    let i = 0;  \n    for (let char of stack) {  \n        if (char === needle[i]) {  \n            i++;  \n        }  \n        if (i === needle.length) {  \n            return true;  \n        }  \n    }    return false;  \n}  \n  \n  \n  \nfuzzysearch('car', 'cartwheel')      // true  \n  \nfuzzysearch('cwhl', 'cartwheel')     // true  \n  \nfuzzysearch('we', 'cartwheel')       // true  \n  \nfuzzysearch('cartwheel', 'cartwheel') // true  \n  \nfuzzysearch('cwheeel', 'cartwheel')  // false  \n  \nfuzzysearch('lw', 'cartwheel')       // false\n",
      "code_language": "js",
      "code_lines": 17,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "searching",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "fuzzysearch",
        "needle",
        "search",
        "fuzzy",
        "stack",
        "char"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 15,
      "pedagogical_type": "exercise",
      "text_complexity": 0.22,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsj2000lhxt8spvqq9qi",
      "title": "21. Max Consecutive Ones",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив nums, состоящий из нулей и единиц. Необходимо определить максимальное количество подряд идущих единиц в массиве. Для решения задачи реализуйте функцию, которая будет проходить по массиву и подсчитывать текущую последовательность единиц, обновляя максимум при необходимости. Если встречается 0, текущая последовательность сбрасывается.\\n",
      "code_content": "// iterations  \nconst findMaxConsecutiveOnes = nums => {  \n    let max = 0;  \n    let current = 0;  \n  \n    for (let i = 0; i < nums.length; i++) {  \n        if (nums[i] === 1) {  \n            current++;  \n            if (current > max) {  \n                max = current;  \n            }  \n        } else {  \n            current = 0;  \n        }  \n    }  \n    return max;  \n};  \n  \nconst nums1 = [1,1,0,1,1,1];  \n  \nconsole.log(findMaxConsecutiveOnes(nums1));",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "arrow_functions",
        "searching",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "max",
        "findmaxconsecutiveones",
        "consecutive",
        "ones",
        "nums",
        "current"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 44,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 20,
      "pedagogical_type": "exercise",
      "text_complexity": 0.43,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsju000mhxt8e9xlo12g",
      "title": "22. Two Sum",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел nums и целевое значение target. Необходимо найти два числа из массива, сумма которых равна target, и вернуть их индексы. Решение задачи можно реализовать с использованием следующих подходов:\\nИспользование объекта Map:Создайте объект Map для хранения значений массива и их индексов.Итерируйте по массиву, вычисляя разницу между target и текущим числом.Если разница уже присутствует в Map, то найденная пара удовлетворяет условию задачи.Если нет, добавьте текущее чи...",
      "code_content": "// map  \nconst twoSum = (nums, target) => {  \n    const map = new Map();  \n  \n    for (let i = 0; i < nums.length; i++) {  \n        const diff = target - nums[i];  \n        if (map.has(diff)) {  \n            return [map.get(diff), i];  \n        }  \n        map.set(nums[i], i);  \n    }  \n  \n    return [];  \n};  \n  \n// object  \nconst twoSum2 = (nums, target) => {  \n    const numToIndexMap = {};  \n  \n    for (let i = 0; i < nums.length; i++) {  \n        const diff = target - nums[i];  \n        if (diff in numToIndexMap) {  \n            return [numToIndexMap[diff], i];  \n        }  \n        numToIndexMap[nums[i]] = i;  \n    }  \n  \n    return null;  \n};  \n  \nconst nums = [2, 7, 11, 15];  \nconst target = 9;  \n  \nconst result = twoSum(nums, target);  \n  \nconsole.log(result);",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "sum",
        "twosum",
        "two",
        "target",
        "map",
        "result",
        "nums",
        "has",
        "get",
        "set",
        "numtoindexmap",
        "diff"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 78,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 21,
      "pedagogical_type": "exercise",
      "text_complexity": 0.95,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsko000nhxt8peqhyvt5",
      "title": "23. Majority Element",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел, в котором гарантированно существует элемент, встречающийся более чем половину раз. Необходимо найти этот \"мажоритарный\" элемент. Задачу можно решить различными способами:\\nАлгоритм Бойера-Мура:Используйте переменную candidate для хранения кандидата и счетчик count.Проходите по массиву: если count равен 0, выбирайте текущий элемент как нового кандидата. Если текущий элемент равен кандидату, увеличивайте count, иначе уменьшайте его.Использование Map:Считайте вхо...",
      "code_content": "// бойер мур  \nconst majorityElement = nums => {  \n    let candidate, count = 0;  \n  \n    for (const num of nums) {  \n        if (count === 0) candidate = num;  \n        count += (num === candidate) ? 1 : -1;  \n    }  \n    return candidate;  \n};  \n  \nconst nums1 = [3, 2, 3];  \nconsole.log(majorityElement(nums1));  \n  \n// map  \nconst majorityElement2 = nums => {  \n    const counts = new Map();  \n  \n    for (const num of nums) {  \n        counts.set(num, (counts.get(num) || 0) + 1);  \n        if (counts.get(num) > nums.length / 2) return num;  \n    }  \n};  \n  \nconst nums3 = [1, 1, 1, 2, 3, 1, 1, 4, 1];  \nconsole.log(majorityElement2(nums3));  \n  \n// one-liner sorting  \nconst majorityElement3 = nums => (nums.sort((a, b) => a - b))[Math.floor(nums.length / 2)];  \n  \nconst nums4 = [5, 4, 4, 4, 5, 4, 4, 4];  \nconsole.log(majorityElement3(nums4));  \n  \n// рекурсивное деление (divide and conqueror)  \nconst majorityElementRec = (nums, start, end) => {  \n    if (start === end) return nums[start];  \n  \n    const mid = Math.floor((end - start) / 2) + start;  \n    const left = majorityElementRec(nums, start, mid);  \n    const right = majorityElementRec(nums, mid + 1, end);  \n  \n    if (left === right) return left;  \n  \n    const leftCount = nums.slice(start, end + 1).filter(num => num === left).length;  \n    const rightCount = nums.slice(start, end + 1).filter(num => num === right).length;  \n  \n    return leftCount > rightCount ? left : right;  \n};  \n  \nconst majorityElement4 = nums => majorityElementRec(nums, 0, nums.length - 1);  \n  \nconst nums6 = [7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5];  \nconsole.log(majorityElement4(nums6));",
      "code_language": "js",
      "code_lines": 39,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (39 строк)",
        "Средние концепции (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter"
      ],
      "keywords": [
        "conquer",
        "majorityelementrec",
        "start",
        "right",
        "majority",
        "majorityelement",
        "counts",
        "get",
        "leftcount",
        "set",
        "mid",
        "num",
        "slice",
        "filter",
        "nums",
        "rightcount",
        "left",
        "end",
        "floor",
        "count",
        "map",
        "sort",
        "candidate",
        "divide",
        "and",
        "element",
        "math"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 103,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 22,
      "pedagogical_type": "practice",
      "text_complexity": 1.61,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxslk000ohxt85z73ewby",
      "title": "24. Best Time to Buy and Sell Stock",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив цен на акции, где каждый элемент представляет цену акции в определённый день. Необходимо определить максимальную прибыль, которую можно получить, купив акцию в один день и продав в более поздний день. Если получение прибыли невозможно, функция должна вернуть 0. Решение задачи реализовано с использованием двух указателей:\\nОдин указатель (left) используется для определения дня покупки.Второй указатель (right) используется для определения дня продажи.Проход по массиву ...",
      "code_content": "const maxProfit = (prices) => {  \n    let left = 0; // День покупки  \n    let right = 1; // День продажи  \n    let max_profit = 0;  \n    while (right < prices.length) {  \n        if (prices[left] < prices[right]) {  \n            let profit = prices[right] - prices[left]; // Текущая прибыль  \n            max_profit = Math.max(max_profit, profit);  \n        } else {  \n            left = right;  \n        }  \n        right++;  \n    }  \n    return max_profit;  \n};",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "max",
        "maxprofit",
        "profit",
        "prices",
        "time",
        "and",
        "buy",
        "stock",
        "right",
        "best",
        "math",
        "left",
        "sell"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 62,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 23,
      "pedagogical_type": "practice",
      "text_complexity": 0.96,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsmb000phxt8itoanhpn",
      "title": "25. Intersection of Two Arrays II",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Даны два массива чисел. Необходимо найти их пересечение, при этом каждый элемент в результирующем массиве должен встречаться столько раз, сколько он встречается в обоих исходных массивах. Для решения задачи можно использовать несколько подходов:\\nMap:Создать карту для подсчета вхождений элементов первого массива.Проитерироваться по второму массиву и, если элемент присутствует в карте (и его количество больше нуля), добавить его в результат и уменьшить счетчик.Reduce:С помощью м...",
      "code_content": "// map  \nfunction intersect(nums1, nums2) {  \n    const map = new Map();  \n    const result = [];  \n  \n    for (let num of nums1) {  \n        map.set(num, (map.get(num) || 0) + 1);  \n    }  \n  \n    for (let num of nums2) {  \n        if (map.get(num) > 0) {  \n            result.push(num);  \n            map.set(num, map.get(num) - 1);  \n        }  \n    }  \n    return result;  \n}  \n  \nconst nums1 = [1, 2, 2, 1];  \nconst nums2 = [2, 2];  \nconsole.log(intersect(nums1, nums2));  \n  \n// reduce  \nfunction intersectWithReduce(nums1, nums2) {  \n    const counts = nums1.reduce((acc, num) => {  \n        acc[num] = (acc[num] || 0) + 1;  \n        return acc;  \n    }, {});  \n  \n    return nums2.filter(num => {  \n        if (counts[num] > 0) {  \n            counts[num]--;  \n            return true;  \n        }  \n        return false;  \n    });  \n}  \n  \nconst nums3 = [4, 9, 5];  \nconst nums4 = [9, 4, 9, 8, 4];  \nconsole.log(intersectWithReduce(nums3, nums4));  \n  \n// if sorted, two pointers  \nfunction intersectSorted(nums1, nums2) {  \n    nums1.sort((a, b) => a - b);  \n    nums2.sort((a, b) => a - b);  \n    const result = [];  \n  \n    let i = 0;  \n    let j = 0;  \n  \n    while (i < nums1.length && j < nums2.length) {  \n        if (nums1[i] === nums2[j]) {  \n            result.push(nums1[i]);  \n            i++;  \n            j++;  \n        } else if (nums1[i] < nums2[j]) {  \n            i++;  \n        } else {  \n            j++;  \n        }  \n    }  \n    return result;  \n}  \n  \nconst nums5 = [4, 5, 9];  \nconst nums6 = [9, 9, 8, 4];  \nconsole.log(intersectSorted(nums5, nums6));",
      "code_language": "js",
      "code_lines": 58,
      "complexity_score": 6.5,
      "difficulty_factors": [
        "Длинный код (58 строк)",
        "Средняя вложенность (3)",
        "Средние концепции (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter",
        "array_reduce"
      ],
      "keywords": [
        "nmap",
        "num",
        "intersectsorted",
        "acc",
        "intersectwithreduce",
        "reduce",
        "filter",
        "two",
        "map",
        "result",
        "intersect",
        "intersection",
        "set",
        "get",
        "counts",
        "arrays",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 120,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 24,
      "pedagogical_type": "practice",
      "text_complexity": 0.91,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsn3000qhxt8if58l0g2",
      "title": "26. groupByCity",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Обработайте массив объектов, представляющих людей с их именами и городами, и распределите их по группам на основе города. Ожидаемый результат должен представлять собой объект, где ключами являются названия городов, а значениями — либо строка (если в городе один человек), либо массив имен (если в городе несколько человек). В данном примере:\\nРеализуйте несколько вариантов решения, используя методы reduce, forEach, цикл for...of, Map и метод find.\\n",
      "code_content": "{\n    'Moscow': [ 'Alex', 'Ivan' ],\n    'New York': 'Joe',\n    'Berlin': 'Johan'\n}",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "loops",
        "destructuring",
        "spread_operator",
        "searching",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "find",
        "reduce",
        "map",
        "foreach",
        "groupbycity"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 40,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 25,
      "pedagogical_type": "example",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsns000rhxt83t1y6ycl",
      "title": "27. groupByCountry",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, каждый из которых содержит информацию о пользователе (id, age, name, country, registered). Необходимо преобразовать этот массив в объект, где ключами будут названия стран, а значениями — вложенные объекты. Внутренний объект должен иметь в качестве ключей id пользователей, а значениями — оставшиеся свойства (без id и country). Это можно реализовать несколькими способами, например, с использованием методов reduce, forEach или Map.\\n",
      "code_content": "const data = [  \n    { id: 1, age: 20, name: \"Иван\", country: \"Russia\", registered: true },  \n    { id: 2, age: 30, name: \"Дима\", country: \"Russia\", registered: false },  \n    { id: 3, age: 20, name: \"Леха\", country: \"Russia\", registered: true },  \n    { id: 4, age: 20, name: \"Дима\", country: \"Usa\", registered: true },  \n    { id: 5, age: 20, name: \"Леха\", country: \"Russia\", registered: false },  \n    { id: 6, age: 30, name: \"Дима\", country: \"Russia\", registered: true },  \n    { id: 7, age: 20, name: \"Дима\", country: \"Usa\", registered: false },  \n    { id: 8, age: 20, name: \"Дима\", country: \"Usa\", registered: false },  \n];  \n  \n// reduce  \nfunction transformDataReduce(data) {  \n    return data.reduce((acc, item) => {  \n        const { id, country, ...rest } = item;  \n  \n        if (!acc[country]) {  \n            acc[country] = {};  \n        }  \n  \n        acc[country][id] = rest;  \n        return acc;  \n    }, {});  \n}  \n  \nconst resultReduce = transformDataReduce(data);  \nconsole.log(resultReduce);  \n  \n// forEach  \nfunction transformDataForEach(data) {  \n    const result = {};  \n  \n    data.forEach(item => {  \n        const { id, country, ...rest } = item;  \n  \n        if (!result[country]) {  \n            result[country] = {};  \n        }  \n  \n        result[country][id] = rest;  \n    });  \n  \n    return result;  \n}  \n  \nconst resultForEach = transformDataForEach(data);  \nconsole.log(resultForEach);  \n  \n// map  \nfunction transformDataMap(data) {  \n    const countryMap = new Map();  \n  \n    data.forEach(item => {  \n        const { id, country, ...rest } = item;  \n  \n        if (!countryMap.has(country)) {  \n            countryMap.set(country, new Map());  \n        }  \n  \n        countryMap.get(country).set(id, rest);  \n    });  \n  \n    const result = {};  \n    countryMap.forEach((countryData, country) => {  \n        result[country] = Object.fromEntries(countryData);  \n    });  \n  \n    return result;  \n}  \n  \nconst resultMap = transformDataMap(data);  \nconsole.log(resultMap);",
      "code_language": "js",
      "code_lines": 55,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Длинный код (55 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "error_handling",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "object_destructuring",
        "array_reduce",
        "array_forEach"
      ],
      "keywords": [
        "registered",
        "transformdataforeach",
        "set",
        "get",
        "countrymap",
        "acc",
        "resultreduce",
        "age",
        "object",
        "foreach",
        "map",
        "transformdatareduce",
        "fromentries",
        "rest",
        "resultforeach",
        "item",
        "name",
        "reduce",
        "countrydata",
        "resultmap",
        "data",
        "transformdatamap",
        "groupbycountry",
        "result",
        "has",
        "country"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 88,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 26,
      "pedagogical_type": "example",
      "text_complexity": 0.63,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsp2000shxt8nyk551gp",
      "title": "28. findDuplicate",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив строк. Необходимо найти все элементы, которые встречаются более одного раза, и вернуть их в виде массива без дубликатов. Решение задачи предлагается реализовать двумя способами:\\nС использованием объектов Set для отслеживания уже встреченных элементов и для хранения найденных дубликатов.С использованием комбинации методов filter и indexOf для поиска повторяющихся элементов, а затем удаления повторений с помощью Set.\\n",
      "code_content": "const arr = ['1', '2', '3', '1', '4', '8', '2', '3'];  \nlet result = [];  \n  \n// 1. Using Set  \nconst findDuplicate = (arr) => {  \n    const seen = new Set();  \n    const duplicates = new Set();  \n  \n    for (let item of arr) {  \n        if (seen.has(item)) {  \n            duplicates.add(item);  \n        }  \n        seen.add(item);  \n    }  \n    return Array.from(duplicates);  \n};  \n  \nresult = findDuplicate(arr);  \nconsole.log(\"Set method:\", result);  \n  \n// 2. Using filter + indexOf one-liner  \nconst findDuplicate2 = arr => [...new Set(arr)].filter((item, index) => arr.indexOf(item) !== index);  \nconsole.log(\"Filter + indexOf method:\", findDuplicate2(arr));",
      "code_language": "js",
      "code_lines": 19,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "searching",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_filter"
      ],
      "keywords": [
        "indexof",
        "duplicates",
        "item",
        "filter",
        "array",
        "findduplicate",
        "result",
        "arr",
        "set",
        "has",
        "from",
        "add",
        "seen",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 52,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 27,
      "pedagogical_type": "practice",
      "text_complexity": 0.57,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxspr000thxt8s9q02p1e",
      "title": "29. getDuplicate",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив, который может содержать вложенные массивы, состоящий из чисел. Необходимо написать функцию, которая сначала «разворачивает» вложенные массивы в один плоский массив, затем подсчитывает, сколько раз встречается каждый элемент, и возвращает объект, где ключами являются элементы, а значениями — их количество в исходном массиве.\\n",
      "code_content": "function getDuplicates(arr) {  \n    const flatArray = flattenArray(arr);  \n    const countMap = {};  \n  \n    flatArray.forEach(num => {  \n        countMap[num] = (countMap[num] || 0) + 1;  \n    });  \n  \n    return countMap;  \n}  \n  \nfunction flattenArray(arr) {  \n    return arr.reduce((acc, val) => {  \n        return acc.concat(Array.isArray(val) ? flattenArray(val) : val);  \n    }, []);  \n}  \n  \nconst arr = [1, 1, 4, 5, [1, 6, 4, [9, 8, 3]], 3, 2, [8]];  \n  \nconsole.log(getDuplicates(arr)); // { 1: 3, 4: 2, 5: 1, 6: 1, 9: 1, 8: 2, 3: 2, 2: 1 }",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce",
        "array_forEach"
      ],
      "keywords": [
        "num",
        "concat",
        "acc",
        "getduplicate",
        "reduce",
        "val",
        "array",
        "foreach",
        "isarray",
        "getduplicates",
        "flattenarray",
        "arr",
        "flatarray",
        "countmap"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 28,
      "pedagogical_type": "practice",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsqi000uhxt8o4zdjzfq",
      "title": "30. getMostRepeatedItem",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан вложенный массив, который может содержать числа и строки. Необходимо написать функцию, которая:\\nРекурсивно \"расплющивает\" массив.Подсчитывает, сколько раз каждый элемент встречается в массиве.Находит элемент с наибольшим количеством вхождений.Возвращает результат в виде объекта, где ключ — это наиболее часто встречающийся элемент, а значение — количество его вхождений.\\n",
      "code_content": "const nestedArray = [2, 'A', 2, ['A', 4, ['A', 6, ['A', 8]]]];  \n  \nconst getMostRepeatedItem = (arr) => {  \n    // Функция для рекурсивного расплющивания массива  \n    const flattenArray = (array) =>  \n        array.reduce(  \n            (acc, val) => acc.concat(Array.isArray(val) ? flattenArray(val) : val),  \n            []  \n        );  \n  \n    // Расплющиваем массив  \n    const flatArr = flattenArray(arr);  \n  \n    // Подсчитываем количество вхождений каждого элемента  \n    const countMap = flatArr.reduce((acc, item) => {  \n        acc[item] = (acc[item] || 0) + 1;  \n        return acc;  \n    }, {});  \n  \n    // Ищем элемент с наибольшим количеством вхождений  \n    const mostRepeated = Object.keys(countMap).reduce((a, b) =>  \n        countMap[a] > countMap[b] ? a : b  \n    );  \n  \n    // Возвращаем результат в виде объекта  \n    return { [mostRepeated]: countMap[mostRepeated] };  \n};  \n  \nconsole.log(getMostRepeatedItem(nestedArray)); // { A: 4 }",
      "code_language": "js",
      "code_lines": 23,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (23 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "keys",
        "item",
        "concat",
        "acc",
        "reduce",
        "getmostrepeateditem",
        "nestedarray",
        "array",
        "val",
        "isarray",
        "flattenarray",
        "arr",
        "mostrepeated",
        "countmap",
        "object",
        "flatarr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 50,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 29,
      "pedagogical_type": "practice",
      "text_complexity": 0.46,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsr6000vhxt8o7lusubh",
      "title": "31. getMostRepeatedItem",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию, которая принимает вложенный массив (массив, содержащий вложенные массивы) и возвращает объект, в котором ключ — элемент, встречающийся чаще всего, а значение — количество его вхождений. Для решения задачи необходимо:\\nРекурсивно \"расплющить\" вложенный массив.Подсчитать частоту каждого элемента.Найти элемент с наибольшей частотой.Вернуть результат в виде объекта.\\n",
      "code_content": "const nestedArray = [2, 'A', 2, ['A', 4, ['A', 6, ['A', 8]]]];  \n  \nconst getMostRepeatedItem = (arr) => {  \n    // Рекурсивная функция для расплющивания массива  \n    const flattenArray = (array) =>  \n        array.reduce((acc, val) =>  \n            acc.concat(Array.isArray(val) ? flattenArray(val) : val), []);  \n  \n    // Расплющенный массив  \n    const flatArr = flattenArray(arr);  \n  \n    // Подсчет вхождений каждого элемента  \n    const countMap = flatArr.reduce((acc, item) => {  \n        acc[item] = (acc[item] || 0) + 1;  \n        return acc;  \n    }, {});  \n  \n    // Поиск элемента с максимальным количеством вхождений  \n    const mostRepeated = Object.keys(countMap).reduce((a, b) =>  \n        countMap[a] > countMap[b] ? a : b  \n    );  \n  \n    // Возвращаем результат в виде объекта  \n    return { [mostRepeated]: countMap[mostRepeated] };  \n};  \n  \nconsole.log(getMostRepeatedItem(nestedArray)); // { A: 4 }",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (21 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "keys",
        "item",
        "concat",
        "acc",
        "reduce",
        "getmostrepeateditem",
        "nestedarray",
        "array",
        "val",
        "isarray",
        "flattenarray",
        "arr",
        "mostrepeated",
        "countmap",
        "object",
        "flatarr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 30,
      "pedagogical_type": "exercise",
      "text_complexity": 0.46,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsrt000whxt8mzlqm6m7",
      "title": "32. Move Zeroes leetcode",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел, в котором необходимо переместить все нулевые элементы в конец, сохраняя порядок ненулевых элементов. Задача должна быть решена без создания дополнительного массива (in place) и с использованием альтернативных подходов.\\nРеализуйте несколько вариантов решения:\\nДва указателя (in place):Используйте два указателя: один для текущего элемента, другой для позиции последнего ненулевого элемента.Обменивайте ненулевые элементы с элементами, находящимися в позиции после...",
      "code_content": "// два указателя (in place)  \nfunction moveZeroesInPlace(nums) {  \n    let lastNonZero = 0;  \n    for (let i = 0; i < nums.length; i++) {  \n        if (nums[i] !== 0) {  \n            [nums[lastNonZero], nums[i]] = [nums[i], nums[lastNonZero]];  \n            lastNonZero++;  \n        }  \n    }  \n}  \n  \nconst nums1 = [0, 1, 0, 3, 12];  \nmoveZeroesInPlace(nums1);  \nconsole.log(nums1);  // [1, 3, 12, 0, 0]\n  \n// две проверки (in place)  \nfunction moveZeroesTwoPass(nums) {  \n    let count = 0;  \n    for (let i = 0; i < nums.length; i++) {  \n        if (nums[i] !== 0) {  \n            nums[count] = nums[i];  \n            count++;  \n        }  \n    }  \n    for (let i = count; i < nums.length; i++) {  \n        nums[i] = 0;  \n    }  \n}  \n  \nconst nums2 = [0, 1, 0, 3, 12];  \nmoveZeroesTwoPass(nums2);  \nconsole.log(nums2);  // [1, 3, 12, 0, 0]\n  \n// push (новый массив)  \nfunction moveZeroesNewArray(nums) {  \n    const result = [];  \n    // First pass: Add all non-zero elements to the result array  \n    for (const num of nums) {  \n        if (num !== 0) {  \n            result.push(num);  \n        }  \n    }  \n    // Add zeros to the end of the result array  \n    while (result.length < nums.length) {  \n        result.push(0);  \n    }  \n    return result;  \n}  \n  \nconst nums3 = [0, 1, 0, 3, 12];  \nconst newArrayResult = moveZeroesNewArray(nums3);  \nconsole.log(newArrayResult);  // [1, 3, 12, 0, 0]\n  \n// фильтрация-конкатенация (новый массив)  \nfunction moveZeroesWithFilter(nums) {  \n    const nonZeroes = nums.filter(num => num !== 0);  \n    const zeroCount = nums.length - nonZeroes.length;  \n    return nonZeroes.concat(Array(zeroCount).fill(0));  \n}  \n  \nconst nums4 = [0, 1, 0, 3, 12];  \nconst filterResult = moveZeroesWithFilter(nums4);  \nconsole.log(filterResult);  // [1, 3, 12, 0, 0]",
      "code_language": "js",
      "code_lines": 56,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Длинный код (56 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter"
      ],
      "keywords": [
        "concat",
        "zerocount",
        "fill",
        "movezeroeswithfilter",
        "nonzeroes",
        "num",
        "filter",
        "zeroes",
        "filterresult",
        "newarrayresult",
        "lastnonzero",
        "nums",
        "array",
        "count",
        "move",
        "leetcode",
        "place",
        "movezeroesnewarray",
        "movezeroesinplace",
        "movezeroestwopass",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 114,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 31,
      "pedagogical_type": "exercise",
      "text_complexity": 1.16,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxssj000xhxt8wvbzx32d",
      "title": "33. Group Anagrams",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив строк. Необходимо сгруппировать строки, которые являются анаграммами друг друга, и вернуть их группировку в виде массива массивов. Решение можно реализовать различными способами:\\nСортировка по ключу:Отсортируйте символы в каждой строке, чтобы получить ключ.Используйте объект для группировки строк по этому отсортированному ключу.Количество символов как ключ:Подсчитайте количество каждого символа в строке (предполагается, что строки состоят из строчных букв английског...",
      "code_content": "// сортировка по ключу  \nfunction groupAnagramsSort(strs) {  \n    const anagrams = {};  \n  \n    for (const str of strs) {  \n        const sortedStr = str.split('').sort().join('');  \n        if (!anagrams[sortedStr]) {  \n            anagrams[sortedStr] = [];  \n        }  \n        anagrams[sortedStr].push(str);  \n    }  \n  \n    return Object.values(anagrams);  \n}  \n  \nconsole.log(groupAnagramsSort([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]));  \n  \n  \n// колво символов как ключ  \nfunction groupAnagramsCount(strs) {  \n    const anagrams = {};  \n  \n    for (const str of strs) {  \n        const count = new Array(26).fill(0);  \n        for (const char of str) {  \n            count[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;  \n        }  \n        const key = count.join('#');  \n        if (!anagrams[key]) {  \n            anagrams[key] = [];  \n        }  \n        anagrams[key].push(str);  \n    }  \n  \n    return Object.values(anagrams);  \n}  \n  \nconsole.log(groupAnagramsCount([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]));  \n  \n  \n// map  \nfunction groupAnagramsMap(strs) {  \n    const anagrams = new Map();  \n  \n    for (const str of strs) {  \n        const count = new Array(26).fill(0);  \n        for (const char of str) {  \n            count[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;  \n        }  \n        const key = count.toString();  \n        if (!anagrams.has(key)) {  \n            anagrams.set(key, []);  \n        }  \n        anagrams.get(key).push(str);  \n    }  \n  \n    return Array.from(anagrams.values());  \n}  \n  \nconsole.log(groupAnagramsMap([\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]));",
      "code_language": "js",
      "code_lines": 47,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (47 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "destructuring",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "anagrams",
        "groupanagramsmap",
        "fill",
        "set",
        "get",
        "join",
        "tostring",
        "object",
        "charcodeat",
        "values",
        "key",
        "strs",
        "count",
        "array",
        "map",
        "str",
        "char",
        "split",
        "sort",
        "sortedstr",
        "groupanagramssort",
        "group",
        "has",
        "from",
        "groupanagramscount"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 94,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 32,
      "pedagogical_type": "example",
      "text_complexity": 0.8,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsta000yhxt8ilfyq0h2",
      "title": "34. rangeExtraction",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая принимает отсортированный массив чисел (включая отрицательные) и преобразует его в строковое представление, где последовательные числа, составляющие диапазон из трёх и более элементов, сворачиваются в формат \"start-end\". Если последовательность короче, числа выводятся отдельно, разделённые запятыми.\\nАлгоритм решения:\\nИнициализируйте переменные для отслеживания начала (rangeStart) и конца (rangeEnd) текущего диапазона.Проходите по массиву и, если те...",
      "code_content": "function rangeExtraction(list) {  \n    const result = [];  \n    let rangeStart = list[0];  \n    let rangeEnd = list[0];  \n  \n    for (let i = 1; i <= list.length; i++) {  \n        const current = list[i];  \n        if (current === rangeEnd + 1) {  \n            rangeEnd = current;  \n        } else {  \n            if (rangeEnd - rangeStart >= 2) {  \n                result.push(`${rangeStart}-${rangeEnd}`);  \n            } else {  \n                for (let j = rangeStart; j <= rangeEnd; j++) {  \n                    result.push(j.toString());  \n                }  \n            }  \n            rangeStart = current;  \n            rangeEnd = current;  \n        }  \n    }  \n    return result.join(',');  \n}  \n  \nconst range = [-10, -9, -8, -7, -3, -2, -1, 0, 1, 3, 4, 5, 14, 15, 17, 18, 19, 20];  \nconsole.log(rangeExtraction(range));",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "template_literals"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "range",
        "list",
        "rangeend",
        "tostring",
        "result",
        "rangeextraction",
        "current",
        "rangestart",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 79,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 33,
      "pedagogical_type": "exercise",
      "text_complexity": 1.52,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsu1000zhxt811rhkmjp",
      "title": "35. Kth Largest Element in an Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел nums и целое число k. Необходимо найти k-й по величине элемент в массиве.Обратите внимание, что k-й по величине элемент означает k-й элемент в отсортированном по убыванию массиве, то есть наибольший элемент имеет позицию 1.\\nРеализуйте решение задачи двумя подходами:\\nСортировка:Отсортируйте массив по убыванию и верните элемент с индексом k - 1.Quickselect:Используйте алгоритм Quickselect, который в среднем работает за O(n), для нахождения k-го по величине элем...",
      "code_content": "// Подход 1: Сортировка\nfunction findKthLargestSort(nums, k) {\n    nums.sort((a, b) => b - a); // сортировка по убыванию\n    return nums[k - 1];\n}\n\n// Пример использования:\nconst nums1 = [3, 2, 1, 5, 6, 4];\nconst k1 = 2;\nconsole.log(findKthLargestSort(nums1, k1)); // Ожидаемый вывод: 5\n\n\n// Подход 2: Quickselect\nfunction findKthLargest(nums, k) {\n    const pos = nums.length - k; // k-й по величине элемент является (n-k)-ым по величине, если массив отсортирован по возрастанию\n    return quickselect(nums, 0, nums.length - 1, pos);\n}\n\nfunction quickselect(nums, left, right, pos) {\n    if (left === right) return nums[left];\n    \n    const pivotIndex = partition(nums, left, right);\n    \n    if (pivotIndex === pos) {\n        return nums[pivotIndex];\n    } else if (pivotIndex < pos) {\n        return quickselect(nums, pivotIndex + 1, right, pos);\n    } else {\n        return quickselect(nums, left, pivotIndex - 1, pos);\n    }\n}\n\nfunction partition(nums, left, right) {\n    const pivot = nums[right];\n    let storeIndex = left;\n    for (let i = left; i < right; i++) {\n        if (nums[i] < pivot) { // ищем элементы меньше опорного\n            [nums[i], nums[storeIndex]] = [nums[storeIndex], nums[i]];\n            storeIndex++;\n        }\n    }\n    [nums[storeIndex], nums[right]] = [nums[right], nums[storeIndex]];\n    return storeIndex;\n}\n\n// Пример использования:\nconst nums2 = [3, 2, 1, 5, 6, 4];\nconst k2 = 2;\nconsole.log(findKthLargest(nums2, k2)); // Ожидаемый вывод: 5",
      "code_language": "js",
      "code_lines": 41,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (41 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "arrow_functions",
        "sorting",
        "searching",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "partition",
        "kth",
        "pos",
        "pivot",
        "findkthlargest",
        "element",
        "array",
        "quickselect",
        "right",
        "pivotindex",
        "nums",
        "storeindex",
        "findkthlargestsort",
        "left",
        "largest",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 90,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 34,
      "pedagogical_type": "exercise",
      "text_complexity": 1.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsut0010hxt8nls1xgze",
      "title": "36. Top K Frequent Elements",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел nums и число k. Необходимо найти k наиболее часто встречающихся элементов в массиве. Решение задачи реализовано с использованием метода \"bucket sort\" (корзин), где:\\nСначала создается карта частот, где ключ — элемент массива, а значение — количество его вхождений.Затем создается массив \"корзин\", где индекс соответствует частоте, а в каждой корзине хранятся элементы с данной частотой.Начиная с самой высокой корзины, собираются элементы до тех пор, пока не будет ...",
      "code_content": "function topKFrequent(nums, k) {  \n    // Шаг 1: Создаем карту частоты  \n    const frequencyMap = {};  \n    for (let num of nums) {  \n        frequencyMap[num] = (frequencyMap[num] || 0) + 1;  \n    }  \n  \n    // Шаг 2: Создаем массив \"корзин\" для частот  \n    const buckets = Array(nums.length + 1).fill().map(() => []);  \n  \n    // Шаг 3: Заполняем корзины, где индекс — это частота  \n    for (let num in frequencyMap) {  \n        const freq = frequencyMap[num];  \n        buckets[freq].push(Number(num));  \n    }  \n  \n    // Шаг 4: Собираем k самых частых элементов, начиная с корзины самой высокой частоты  \n    const result = [];  \n    for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {  \n        if (buckets[i].length > 0) {  \n            result.push(...buckets[i]);  \n        }  \n    }  \n    // Возвращаем только первые k элементов, чтобы точно получить результат нужной длины  \n    return result.slice(0, k);  \n}  \n  \n// Примеры использования  \nconsole.log(topKFrequent([1,1,1,2,2,3], 2)); // Ожидаемый результат: [1, 2]  \nconsole.log(topKFrequent([1], 1));           // Ожидаемый результат: [1]",
      "code_language": "js",
      "code_lines": 26,
      "complexity_score": 5.0,
      "difficulty_factors": [
        "Средний код (26 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_map"
      ],
      "keywords": [
        "frequencymap",
        "num",
        "slice",
        "number",
        "freq",
        "array",
        "topkfrequent",
        "fill",
        "map",
        "result",
        "top",
        "nums",
        "frequent",
        "buckets",
        "elements"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 78,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 35,
      "pedagogical_type": "practice",
      "text_complexity": 0.72,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsvn0011hxt8r0b9i3vj",
      "title": "37. findDeepestMinElement",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан вложенный массив чисел, который может содержать элементы и другие вложенные массивы. Необходимо найти элемент с минимальным значением, который находится на самой глубокой вложенности, и вернуть пару: [максимальная глубина, минимальный элемент на этой глубине]. Если на самой глубокой глубине встречается несколько элементов, выбирается минимальный из них.\\nАлгоритм решения:\\nИспользуем рекурсивный обход массива с параметром текущей глубины.Для каждого не массивного элемента о...",
      "code_content": "const arr2 = [1, [[20, 1, [101]], 2], [[-2], [[102, 100]]]];  \n  \nfunction findDeepestMinElement(array) {  \n    let minElement = Infinity;  \n    let maxDepth = -1;  \n  \n    function traverse(arr, currentDepth) {  \n        arr.forEach(item => {  \n            if (Array.isArray(item)) {  \n                // Рекурсивный вызов для вложенных массивов, увеличивая глубину  \n                traverse(item, currentDepth + 1);  \n            } else {  \n                // Если текущая глубина больше максимальной, обновляем maxDepth и minElement  \n                if (currentDepth > maxDepth) {  \n                    maxDepth = currentDepth;  \n                    minElement = item;  \n                } else if (currentDepth === maxDepth && item < minElement) {  \n                    // Если глубина равна максимальной, выбираем минимальное значение  \n                    minElement = item;  \n                }  \n            }  \n        });  \n    }  \n  \n    // Запускаем рекурсивный обход с начальной глубиной 0  \n    traverse(array, 0);  \n  \n    return [maxDepth, minElement];  \n}  \n  \nconsole.log(findDeepestMinElement(arr2)); // Ожидаемый результат: [3, 100]",
      "code_language": "js",
      "code_lines": 26,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (26 строк)",
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "searching",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "item",
        "infinity",
        "array",
        "traverse",
        "minelement",
        "foreach",
        "isarray",
        "maxdepth",
        "arr",
        "finddeepestminelement",
        "currentdepth"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 76,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 36,
      "pedagogical_type": "practice",
      "text_complexity": 1.36,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxswg0012hxt8n4yrpbib",
      "title": "38. getMatchedNumbers",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию getMatchedNumbers, которая принимает два отсортированных массива чисел и возвращает объект с двумя свойствами:\\nmatched: массив чисел, которые присутствуют в обоих массивах (уникальные значения).different: массив чисел, которые встречаются только в одном из массивов (также уникальные).\\nРешение должно использовать два указателя для одновременного обхода обоих массивов и затем добавлять оставшиеся элементы.\\n",
      "code_content": "function getMatchedNumbers(arr1, arr2) {  \n    const matched = new Set();  \n    const different = new Set();  \n    let i = 0;  \n    let j = 0;  \n  \n    while (i < arr1.length && j < arr2.length) {  \n        if (arr1[i] === arr2[j]) {  \n            // Добавляем в matched, если элемент совпадает  \n            matched.add(arr1[i]);  \n            i++;  \n            j++;  \n        } else if (arr1[i] < arr2[j]) {  \n            // Добавляем уникальные элементы из arr1 в different  \n            different.add(arr1[i]);  \n            i++;  \n        } else {  \n            // Добавляем уникальные элементы из arr2 в different  \n            different.add(arr2[j]);  \n            j++;  \n        }  \n    }  \n  \n    // Добавляем оставшиеся элементы из arr1 и arr2 в different  \n    while (i < arr1.length) {  \n        different.add(arr1[i]);  \n        i++;  \n    }  \n  \n    while (j < arr2.length) {  \n        different.add(arr2[j]);  \n        j++;  \n    }  \n  \n    // Преобразуем Set в массив для результата  \n    return { matched: Array.from(matched), different: Array.from(different) };  \n}  \n  \n// Пример использования  \nconsole.log(getMatchedNumbers([1, 3, 3, 5], [3, 5, 5, 6]));  \n// Ожидаемый результат: { matched: [3, 5], different: [1, 6] }",
      "code_language": "js",
      "code_lines": 36,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (36 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "array",
        "getmatchednumbers",
        "add",
        "set",
        "from",
        "nmatched",
        "matched",
        "different"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 59,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 37,
      "pedagogical_type": "exercise",
      "text_complexity": 0.5,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy11s0066hxt8hwryorh4",
      "title": "Subcomponent рендерится только при чётных числах",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "2. IT-One"
      ],
      "text_content": "",
      "code_content": "const SubElement = memo(({ count, clicker }) => {\n  return <button onClick={clicker}>{count}</button>;\n}, (prev, next) => next.count % 2 !== 0);",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "events"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "button",
        "next",
        "subelement",
        "count",
        "prev",
        "subcomponent",
        "onclick",
        "clicker",
        "memo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 17,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 16,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsx70013hxt8zwbvqw1r",
      "title": "39. Flatten Deeply Nested Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан вложенный массив, который может содержать элементы на произвольном уровне вложенности. Необходимо написать функцию, которая рекурсивно \"расплющивает\" массив, возвращая новый массив, содержащий все элементы в одном уровне.\\n",
      "code_content": "function flattenDeep(arr) {\n    return arr.reduce((acc, item) => {\n        if (Array.isArray(item)) {\n            acc.push(...flattenDeep(item));\n        } else {\n            acc.push(item);\n        }\n        return acc;\n    }, []);\n}\n\n// Пример использования:\nconst nestedArray = [1, [2, [3, [4]], 5], 6];\nconsole.log(flattenDeep(nestedArray)); // Ожидаемый результат: [1, 2, 3, 4, 5, 6]",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_reduce"
      ],
      "keywords": [
        "deeply",
        "item",
        "flattendeep",
        "acc",
        "reduce",
        "nestedarray",
        "array",
        "isarray",
        "flatten",
        "arr",
        "nested"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 35,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 38,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsxz0014hxt85lc589ao",
      "title": "40. Flatten Deeply Nested Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан вложенный массив, который может содержать элементы на произвольном уровне вложенности. Необходимо \"расплющить\" массив до указанной глубины (по умолчанию 1) двумя способами:\\nИтерационноРекурсивно\\nНиже приведены два решения:\\nRecursive approach:\\nIteration approach:\\n",
      "code_content": "function flatRecursive(arr, depth = 1) {\n  const result = [];\n\n  function flatten(currentArray, currentDepth) {\n    for (let item of currentArray) {\n      if (Array.isArray(item) && currentDepth < depth) {\n        flatten(item, currentDepth + 1);\n      } else {\n        result.push(item);\n      }\n    }\n  }\n\n  flatten(arr, 0);\n  return result;\n}",
      "code_language": "js",
      "code_lines": 14,
      "complexity_score": 5.5,
      "difficulty_factors": [
        "Средняя вложенность (4)",
        "Сложные концепции (1)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "recursion"
      ],
      "js_features_used": [],
      "keywords": [
        "deeply",
        "currentarray",
        "item",
        "nrecursive",
        "array",
        "approach",
        "flatrecursive",
        "flatten",
        "result",
        "niteration",
        "arr",
        "isarray",
        "currentdepth",
        "nested",
        "depth"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 48,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 39,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxsyq0015hxt8o5vrnxnv",
      "title": "41. sortedSquares",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан отсортированный по неубыванию массив целых чисел, который может содержать отрицательные значения. Необходимо вернуть новый массив, в котором каждый элемент является квадратом соответствующего элемента исходного массива, при этом новый массив должен быть отсортирован по неубыванию. Решение должно работать за O(n) времени, используя два указателя.\\n",
      "code_content": "function sortedSquares(arr) {  \n    let left = 0;  \n    let right = arr.length - 1;  \n    const result = new Array(arr.length);  \n    let index = arr.length - 1;  \n  \n    while (left <= right) {  \n        const leftSquare = arr[left] ** 2;  \n        const rightSquare = arr[right] ** 2;  \n  \n        if (leftSquare > rightSquare) {  \n            result[index] = leftSquare;  \n            left++;  \n        } else {  \n            result[index] = rightSquare;  \n            right--;  \n        }  \n        index--;  \n    }  \n  \n    return result;  \n}  \n  \nconst array = [-9, -2, 0, 2, 3];  \nconsole.log(sortedSquares(array)); // Ожидаемый результат: [0, 4, 4, 9, 81]",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "sorting",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "sortedsquares",
        "array",
        "leftsquare",
        "right",
        "result",
        "arr",
        "rightsquare",
        "left",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 56,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 40,
      "pedagogical_type": "practice",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxszi0016hxt815baeecs",
      "title": "42. sortEvensOnly",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию sortEvensOnly, которая принимает массив чисел. Функция должна отсортировать только чётные числа, сохраняя их исходные позиции в массиве, а остальные числа оставить без изменений.\\nАлгоритм решения:\\nПройдите по массиву и соберите все чётные числа вместе с их индексами.Отсортируйте массив чётных чисел по возрастанию.Поместите отсортированные чётные числа обратно в исходный массив на те же позиции.Верните модифицированный массив.\\n",
      "code_content": "function sortEvensOnly(arr = []) {\n  // 1. Находим чётные элементы и их индексы\n  let evenIndexes = [];\n  let evens = [];\n  arr.forEach((num, idx) => {\n    if (num % 2 === 0) {\n      evenIndexes.push(idx);\n      evens.push(num);\n    }\n  });\n\n  // 2. Сортируем массив с чётными числами по возрастанию\n  evens.sort((a, b) => a - b);\n\n  // 3. Возвращаем чётные числа на исходные индексы в отсортированном порядке\n  evenIndexes.forEach((index, i) => {\n    arr[index] = evens[i];\n  });\n\n  return arr;\n}\n\n// Пример использования:\nconsole.log(sortEvensOnly([4, 1, 0, 5, 2, 3])); // Ожидаемый результат: [0, 1, 2, 5, 4, 3]\nconsole.log(sortEvensOnly([3, 6, 8, 4, 1]));    // Ожидаемый результат: [3, 4, 6, 8, 1]",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "num",
        "sortevensonly",
        "idx",
        "evenindexes",
        "evens",
        "foreach",
        "arr",
        "sort",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 64,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 41,
      "pedagogical_type": "exercise",
      "text_complexity": 1.06,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt0a0017hxt89ph9ttca",
      "title": "43. sortOddOnly",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию sortOddIndices, которая принимает массив чисел и сортирует элементы, расположенные на нечетных индексах, по возрастанию, при этом элементы на четных индексах остаются без изменений.\\nАлгоритм решения:\\nИзвлеките все элементы с нечетных индексов и отсортируйте их по возрастанию.Пройдитесь по исходному массиву и замените элементы на нечетных позициях отсортированными значениями.Верните полученный массив.\\n",
      "code_content": "function sortOddIndices(arr) {  \n    // 1. Извлекаем элементы с нечетных индексов и сортируем их  \n    const oddIndexedElements = arr  \n        .filter((_, index) => index % 2 !== 0)  \n        .sort((a, b) => a - b);  \n  \n    // 2. Вставляем отсортированные элементы обратно на нечетные индексы  \n    let oddIndex = 0;  \n    return arr.map((element, index) => {  \n        if (index % 2 !== 0) {  \n            return oddIndexedElements[oddIndex++];  \n        }  \n        return element;  \n    });  \n}  \n  \n// Пример использования:  \nconst array = [4, 3, 1, 2, 4, 7, 2, 3];  \nconsole.log(sortOddIndices(array)); // Ожидаемый результат: [4, 1, 3, 2, 4, 3, 2, 7]",
      "code_language": "js",
      "code_lines": 17,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Средние концепции (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_map",
        "array_filter"
      ],
      "keywords": [
        "sortoddindices",
        "filter",
        "element",
        "array",
        "map",
        "sortoddonly",
        "arr",
        "oddindexedelements",
        "sort",
        "oddindex",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 58,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 42,
      "pedagogical_type": "exercise",
      "text_complexity": 1.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt120018hxt8ty4t80oh",
      "title": "44. Group By",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Добавьте метод groupBy в прототип массива, который принимает функцию-предикат fn и группирует элементы массива по ключам, возвращаемым этой функцией. Результат должен быть объектом, где каждое свойство — это ключ, а значение — массив элементов, для которых функция вернула этот ключ.\\n",
      "code_content": "Array.prototype.groupBy = function(fn) {  \n    return this.reduce((acc, item) => {  \n        const key = fn(item);  \n        if (!acc[key]) {  \n            acc[key] = [];  \n        }  \n        acc[key].push(item);  \n        return acc;  \n    }, {});  \n};  \n  \n// Пример 1  \nconst array1 = [  \n    {\"id\": \"1\"},  \n    {\"id\": \"1\"},  \n    {\"id\": \"2\"}  \n];  \nconst fn1 = function(item) {  \n    return item.id;  \n};  \nconsole.log(array1.groupBy(fn1));  \n// Ожидаемый результат: { \"1\": [{\"id\": \"1\"}, {\"id\": \"1\"}], \"2\": [{\"id\": \"2\"}] }  \n  \n// Пример 2  \nconst array2 = [  \n    [1, 2, 3],  \n    [1, 3, 5],  \n    [1, 5, 9]  \n];  \nconst fn2 = function(list) {  \n    return String(list[0]);  \n};  \nconsole.log(array2.groupBy(fn2));  \n// Ожидаемый результат: { \"1\": [[1, 2, 3], [1, 3, 5], [1, 5, 9]] }  \n  \n// Пример 3  \nconst array3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];  \nconst fn3 = function(n) {  \n    return String(n > 5);  \n};  \nconsole.log(array3.groupBy(fn3));  \n// Ожидаемый результат: { \"true\": [6, 7, 8, 9, 10], \"false\": [1, 2, 3, 4, 5] }",
      "code_language": "js",
      "code_lines": 39,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (39 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "objects",
        "strings",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "item",
        "key",
        "acc",
        "list",
        "reduce",
        "prototype",
        "array",
        "groupby",
        "string",
        "group"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 67,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 43,
      "pedagogical_type": "practice",
      "text_complexity": 0.91,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt1t0019hxt8yjb87kml",
      "title": "44.1. createKeyValueObject",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию createKeyValueObject, которая принимает массив объектов, где каждый объект имеет поля name и value. Функция должна вернуть объект, в котором ключи — это значения свойства name, а значения — это соответствующие свойства value.\\n",
      "code_content": "function createKeyValueObject(arr) {  \n    return arr.reduce((acc, item) => {  \n        acc[item.name] = item.value;  \n        return acc;  \n    }, {});  \n}  \n  \n// Пример использования  \nconst data = [  \n    { name: 'width', value: 10 },  \n    { name: 'height', value: 20 },  \n    { name: 'test', value: 30 }  \n];  \n  \nconsole.log(createKeyValueObject(data)); // {width: 10, height: 20, test: 30}",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "item",
        "name",
        "acc",
        "reduce",
        "value",
        "data",
        "arr",
        "createkeyvalueobject"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 44,
      "pedagogical_type": "exercise",
      "text_complexity": 0.35,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt2j001ahxt8q3u4owni",
      "title": "45. splitPlayersBySquad",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию splitPlayersBySquad, которая принимает массив игроков и объект myPlayer. Функция должна разделить игроков на две группы:\\nИгроки, которые состоят в той же команде, что и myPlayer, или у которых значение squad равно null (группа \"sameOrNoSquad\").Игроки, у которых значение squad отличается от myPlayer.squad (группа \"otherSquad\").\\nФункция возвращает массив, где первый элемент — это группа других команд, а второй элемент — группа с теми, кто в той же команде или б...",
      "code_content": "function splitPlayersBySquad(players, myPlayer) {  \n    const otherSquad = [];  \n    const sameOrNoSquad = [];  \n  \n    players.forEach(player => {  \n        if (player.squad === myPlayer.squad || player.squad === null) {  \n            sameOrNoSquad.push(player);  \n        } else {  \n            otherSquad.push(player);  \n        }  \n    });  \n  \n    return [otherSquad, sameOrNoSquad];  \n}  \n  \nconst myPlayer = { id: 1, squad: 1 };  \n  \nconst players = [  \n    { id: 2, squad: 1 },  \n    { id: 3, squad: 1 },  \n    { id: 4, squad: null },  \n    { id: 5, squad: 2 },  \n    { id: 6, squad: 1 },  \n    { id: 7, squad: 2 }  \n];  \n  \nconsole.log(splitPlayersBySquad(players, myPlayer));  \n  \n// Ожидаемый результат:  \n// [  \n//   [{ id: 5, squad: 2 }, { id: 7, squad: 2 }],  \n//   [{ id: 2, squad: 1 }, { id: 3, squad: 1 }, { id: 4, squad: null }, { id: 6, squad: 1 }]  \n// ]",
      "code_language": "js",
      "code_lines": 27,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (27 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "squad",
        "othersquad",
        "myplayer",
        "sameornosquad",
        "foreach",
        "player",
        "splitplayersbysquad",
        "players"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 64,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 45,
      "pedagogical_type": "exercise",
      "text_complexity": 0.7,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt3c001bhxt80d4ppktd",
      "title": "46. getTopCitiesByPopulation",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, содержащих информацию о городах, включая страну, название города и население. Необходимо сгруппировать города по странам и для каждой страны выбрать топ-3 города по населению. Если для страны доступно менее 3 городов, возвращаются все имеющиеся города.\\n",
      "code_content": "function getTopCitiesByPopulation(data) {  \n    // Группировка городов по странам  \n    const groupedByCountry = data.reduce((acc, item) => {  \n        if (!acc[item.country]) {  \n            acc[item.country] = [];  \n        }  \n        acc[item.country].push(item);  \n        return acc;  \n    }, {});  \n  \n    // Получение топ-3 городов по населению для каждой страны  \n    const topCitiesByCountry = {};  \n  \n    for (const country in groupedByCountry) {  \n        topCitiesByCountry[country] = groupedByCountry[country]  \n            .sort((a, b) => b.population - a.population)  \n            .slice(0, 3);  \n    }  \n  \n    return topCitiesByCountry;  \n}  \n  \n// Пример данных  \nconst citiesData = [  \n    { country: 'USA', city: 'New York', population: 8419600 },  \n    { country: 'USA', city: 'Los Angeles', population: 3980400 },  \n    { country: 'USA', city: 'Chicago', population: 2716000 },  \n    { country: 'USA', city: 'Houston', population: 2328000 },  \n    { country: 'USA', city: 'Phoenix', population: 1690000 },  \n    { country: 'Canada', city: 'Toronto', population: 2930000 },  \n    { country: 'Canada', city: 'Montreal', population: 1760000 },  \n    { country: 'Japan', city: 'Tokyo', population: 13929286 },  \n    { country: 'Japan', city: 'Yokohama', population: 3726167 },  \n    { country: 'Japan', city: 'Osaka', population: 2698046 },  \n    { country: 'Japan', city: 'Nagoya', population: 2295638 },  \n    { country: 'Japan', city: 'Sapporo', population: 1952356 },  \n];  \n  \n// Пример использования функции  \nconst result = getTopCitiesByPopulation(citiesData);  \n  \nconsole.log(result);  \n  \n// Ожидаемый вывод:  \n// {  \n//     USA: [  \n//         { country: 'USA', city: 'New York', population: 8419600 },  \n//         { country: 'USA', city: 'Los Angeles', population: 3980400 },  \n//         { country: 'USA', city: 'Chicago', population: 2716000 }  \n//     ],  \n//     Canada: [  \n//         { country: 'Canada', city: 'Toronto', population: 2930000 },  \n//         { country: 'Canada', city: 'Montreal', population: 1760000 }  \n//     ],  \n//     Japan: [  \n//         { country: 'Japan', city: 'Tokyo', population: 13929286 },  \n//         { country: 'Japan', city: 'Yokohama', population: 3726167 },  \n//         { country: 'Japan', city: 'Osaka', population: 2698046 }  \n//     ]  \n// }",
      "code_language": "js",
      "code_lines": 53,
      "complexity_score": 5.5,
      "difficulty_factors": [
        "Длинный код (53 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "sorting",
        "error_handling",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "population",
        "item",
        "acc",
        "groupedbycountry",
        "reduce",
        "gettopcitiesbypopulation",
        "slice",
        "data",
        "topcitiesbycountry",
        "result",
        "city",
        "citiesdata",
        "country",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 84,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 46,
      "pedagogical_type": "practice",
      "text_complexity": 0.39,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt72001ghxt8pr2hu15q",
      "title": "51. myFlat",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию myFlat, которая принимает вложенную структуру данных, состоящую из массивов, объектов и строк, и возвращает \"сплющенный\" массив строк, где каждая строка представляет путь к конечной строке, объединяя ключи объектов и элементы массивов с разделителем \"/\". Функция должна обходить все уровни вложенности и корректно формировать пути для строковых значений.\\n",
      "code_content": "function myFlat(arr) {  \n    const result = [];  \n  \n    function traverse(node, path) {  \n        if (Array.isArray(node)) {  \n            for (let item of node) {  \n                traverse(item, path);  \n            }  \n        } else if (typeof node === 'object' && node !== null) {  \n            for (let key in node) {  \n                traverse(node[key], path ? `${path}/${key}` : key);  \n            }  \n        } else if (typeof node === 'string') {  \n            result.push(path ? `${path}/${node}` : node);  \n        }  \n    }  \n    traverse(arr, '');  \n    return result;  \n}",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "template_literals"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "item",
        "key",
        "path",
        "myflat",
        "array",
        "traverse",
        "node",
        "result",
        "isarray",
        "arr",
        "typeof"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 48,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 51,
      "pedagogical_type": "exercise",
      "text_complexity": 0.5,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt43001chxt8c5ef7t0l",
      "title": "47. groupByAge",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Напишите функцию groupByAge, которая принимает массив объектов, где каждый объект содержит информацию о человеке (например, имя и возраст). Функция должна сгруппировать объекты по возрасту, возвращая объект, в котором ключи — это значения возраста, а значения — массивы объектов с данным возрастом.\\n",
      "code_content": "function groupByAge(arr) {  \n    return arr.reduce((acc, item) => {  \n        // Если ключ (возраст) не существует, инициализируем его как пустой массив  \n        if (!acc[item.age]) {  \n            acc[item.age] = [];  \n        }  \n        // Добавляем текущий элемент в массив по ключу (возрасту)  \n        acc[item.age].push(item);  \n        return acc;  \n    }, {});  \n}  \n  \n// Пример использования  \nconst persons = [  \n    { name: 'Alex', age: 20 },  \n    { name: 'Lena', age: 25 },  \n    { name: 'Pavel', age: 20 }  \n];  \n  \nconsole.log(groupByAge(persons));  \n  \n// Ожидаемый результат:  \n// {  \n//     20: [{ name: 'Alex', age: 20 }, { name: 'Pavel', age: 20 }],  \n//     25: [{ name: 'Lena', age: 25 }]  \n// }",
      "code_language": "js",
      "code_lines": 23,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (23 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "persons",
        "item",
        "name",
        "acc",
        "reduce",
        "groupbyage",
        "arr",
        "age"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 50,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 47,
      "pedagogical_type": "example",
      "text_complexity": 0.42,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt4z001dhxt8l9ljgo5u",
      "title": "48. groupByType (+ modification)",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:\\nНапишите функцию groupByType, которая принимает массив объектов и возвращает объект, где ключи – это значения свойства type, а значения – массив объектов с этим типом.Напишите функцию countAndWeightByType, которая принимает тот же массив объектов, но возвращает объект, где ключи – значения свойства type, а значения – объект вида { count: количество объектов с данным типом, weight: суммарный вес этих объектов }.\\n",
      "code_content": "// Часть 1: Группировка по типу, значение - массив объектов\nfunction groupByType(arr) {  \n    return arr.reduce((acc, obj) => {  \n        const key = obj.type;  \n        // Инициализируем пустым массивом, если ключ еще не существует  \n        if (!acc[key]) {  \n            acc[key] = [];  \n        }  \n        // Добавляем текущий объект в массив для этого типа  \n        acc[key].push(obj);  \n        return acc;  \n    }, {});  \n}  \n  \nconst arr = [  \n    { type: \"banana\", weight: 32 },  \n    { type: \"apple\", weight: 24 },  \n    { type: \"kiwi\", weight: 55 },  \n    { type: \"banana\", weight: 44 },  \n    { type: \"orange\", weight: 5 }  \n];  \n  \nconsole.log(groupByType(arr));  \n  \n// Ожидаемый вывод =>  \n// {  \n//     \"banana\": [{ type: \"banana\", weight: 32 }, { type: \"banana\", weight: 44 }],  \n//     \"apple\": [{ type: \"apple\", weight: 24 }],  \n//     \"kiwi\": [{ type: \"kiwi\", weight: 55 }],  \n//     \"orange\": [{ type: \"orange\", weight: 5 }]  \n// }  \n  \n// Часть 2: Группировка с подсчетом количества и суммарного веса  \nfunction countAndWeightByType(arr) {  \n    return arr.reduce((acc, obj) => {  \n        const key = obj.type;  \n        // Инициализация объекта с count и weight, если ключ еще не существует  \n        if (!acc[key]) {  \n            acc[key] = { count: 0, weight: 0 };  \n        }  \n        // Увеличиваем count и суммируем вес для текущего типа  \n        acc[key].count += 1;  \n        acc[key].weight += obj.weight;  \n        return acc;  \n    }, {});  \n}  \n  \nconsole.log(countAndWeightByType(arr));  \n  \n// Ожидаемый вывод =>  \n// {  \n//     \"banana\": { count: 2, weight: 76 },  \n//     \"apple\": { count: 1, weight: 24 },  \n//     \"kiwi\": { count: 1, weight: 55 },  \n//     \"orange\": { count: 1, weight: 5 }  \n// }",
      "code_language": "js",
      "code_lines": 50,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (50 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "weight",
        "key",
        "acc",
        "obj",
        "reduce",
        "modification",
        "count",
        "groupbytype",
        "type",
        "arr",
        "countandweightbytype"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 75,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 48,
      "pedagogical_type": "exercise",
      "text_complexity": 0.61,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt5p001ehxt8koihztlr",
      "title": "49. groupByDate",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дана коллекция операций, каждая операция содержит дату и сумму. Необходимо:\\nОтсортировать операции по дате в порядке возрастания.Сгруппировать операции по году.Преобразовать дату каждой операции в формат \"MM-DD\" и сохранить в сгруппированном объекте, где ключ – это год, а значение – массив дат в формате \"MM-DD\".\\n",
      "code_content": "function groupByDate(operations) {  \n    // Сортируем операции по дате в порядке возрастания  \n    operations.sort((a, b) => new Date(a.date) - new Date(b.date));  \n  \n    // Группируем по году и преобразуем даты в формат MM-DD  \n    return operations.reduce((acc, operation) => {  \n        const [year, month, day] = operation.date.split(\"-\");  \n  \n        // Если года еще нет в объекте, добавляем его как пустой массив  \n        if (!acc[year]) {  \n            acc[year] = [];  \n        }  \n  \n        // Добавляем дату в формате MM-DD  \n        acc[year].push(`${month}-${day}`);  \n        return acc;  \n    }, {});  \n}  \n  \n// Пример использования  \nconst operations = [  \n    { \"date\": \"2017-07-31\", \"amount\": \"5422\" },  \n    { \"date\": \"2017-06-30\", \"amount\": \"5220\" },  \n    { \"date\": \"2017-05-31\", \"amount\": \"5365\" },  \n    { \"date\": \"2017-08-31\", \"amount\": \"5451\" },  \n    { \"date\": \"2017-09-30\", \"amount\": \"5303\" },  \n    { \"date\": \"2018-03-31\", \"amount\": \"5654\" },  \n    { \"date\": \"2017-10-31\", \"amount\": \"5509\" },  \n    { \"date\": \"2017-12-31\", \"amount\": \"5567\" },  \n    { \"date\": \"2018-01-31\", \"amount\": \"5597\" },  \n    { \"date\": \"2017-11-30\", \"amount\": \"5359\" },  \n    { \"date\": \"2018-02-28\", \"amount\": \"5082\" },  \n    { \"date\": \"2018-04-14\", \"amount\": \"2567\" }  \n];  \n  \nconsole.log(groupByDate(operations));  \n  \n// Ожидаемый вывод =>   \n// {  \n//     \"2017\": [  \n//         \"05-31\",  \n//         \"06-30\",  \n//         \"07-31\",  \n//         \"08-31\",  \n//         \"09-30\",  \n//         \"10-31\",  \n//         \"11-30\",  \n//         \"12-31\"  \n//     ],  \n//     \"2018\": [  \n//         \"01-31\",  \n//         \"02-28\",  \n//         \"03-31\",  \n//         \"04-14\"  \n//     ]  \n// }",
      "code_language": "js",
      "code_lines": 50,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (50 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "objects",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "template_literals",
        "array_destructuring",
        "array_reduce"
      ],
      "keywords": [
        "acc",
        "date",
        "operation",
        "reduce",
        "groupbydate",
        "operations",
        "day",
        "year",
        "split",
        "month",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 79,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 49,
      "pedagogical_type": "practice",
      "text_complexity": 0.44,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt6f001fhxt8golwlbem",
      "title": "50. sortByDate",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, где каждый объект содержит дату в формате 'DD.MM.YYYY'. Необходимо отсортировать массив по датам в порядке возрастания. Для этого можно преобразовать строки дат так, чтобы год, месяц и день шли в правильном порядке (например, YYYYMMDD), и затем выполнить сравнение.\\n",
      "code_content": "let arr = [  \n    { date: '10.01.2017' },  \n    { date: '01.12.2002' },  \n    { date: '11.02.2021' },  \n    { date: '05.11.2016' },  \n];  \n  \nfunction sortByDate(array) {  \n    return array.sort((a, b) => {  \n        // Преобразуем дату в формат YYYYMMDD  \n        const dateA = a.date.split('.').reverse().join('');  \n        const dateB = b.date.split('.').reverse().join('');  \n        // Сравниваем преобразованные строки  \n        return dateA.localeCompare(dateB);  \n    });  \n}  \n  \nconst sortedArr = sortByDate(arr);  \nconsole.log(sortedArr);  \n  \n// Ожидаемый вывод:  \n// [  \n//     { date: '01.12.2002' },  \n//     { date: '05.11.2016' },  \n//     { date: '10.01.2017' },  \n//     { date: '11.02.2021' }  \n// ]",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "strings",
        "arrow_functions",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "reverse",
        "sortbydate",
        "date",
        "yyyymmdd",
        "array",
        "datea",
        "sortedarr",
        "dateb",
        "arr",
        "localecompare",
        "sort",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 55,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 50,
      "pedagogical_type": "example",
      "text_complexity": 0.42,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuiu0027hxt8b2ukzqum",
      "title": "1. sum(1)(2)(3)",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализуйте каррированную функцию, которая принимает три числа через цепочку вызовов вида sum(1)(2)(3) и возвращает их сумму. Пример использования показывает, как с помощью вложенных функций можно последовательно передавать аргументы, а затем вычислять результат.\\n",
      "code_content": "function curry(a) {  \n    return (b) => {  \n        return (c) => {  \n            const result = a + b + c;  \n            console.log(result);  \n            return result;  \n        }  \n    }  \n}  \n  \ncurry(1)(2)(3);\n\n\n##### sum(1)(2)(3)(4)...(n)()",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "sum",
        "curry",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 36,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "example",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt7p001hhxt8zl086kkd",
      "title": "52. Battleships in a Board",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дана игровая доска, представленная двумерным массивом, где 'X' обозначает часть корабля, а '.' — пустую клетку. Корабли расположены по горизонтали или вертикали и не соприкасаются друг с другом. Необходимо посчитать количество кораблей на доске. Решение должно быть выполнено за один проход по доске без использования дополнительной памяти для хранения информации о посещённых клетках.\\n",
      "code_content": "function countBattleships(board) {\n  let count = 0;\n  const rows = board.length;\n  if (rows === 0) return 0;\n  const cols = board[0].length;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (board[i][j] === 'X') {\n        // Если сверху или слева есть 'X', значит, этот корабль уже посчитан\n        if (i > 0 && board[i - 1][j] === 'X') continue;\n        if (j > 0 && board[i][j - 1] === 'X') continue;\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n\n// Тест:\nconst board = [\n  ['X', '.', '.', 'X'],\n  ['.', '.', '.', 'X'],\n  ['.', '.', '.', 'X'],\n];\nconsole.log(countBattleships(board)); // 2\n",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "countbattleships",
        "battleships",
        "cols",
        "count",
        "rows",
        "continue",
        "board"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 54,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 52,
      "pedagogical_type": "practice",
      "text_complexity": 0.54,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt8f001ihxt868gwtoaf",
      "title": "53. Rotate Image",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дана квадратная матрица, представляющая изображение, где каждый пиксель хранится в виде целого числа. Необходимо повернуть изображение на 90 градусов по часовой стрелке in-place. Для этого можно выполнить следующие шаги:\\nТранспонировать матрицу (заменить строки на столбцы).Развернуть (обратить порядок элементов) каждую строку.\\n",
      "code_content": "function rotate(matrix) {  \n    const n = matrix.length;  \n  \n    // Транспонируем матрицу  \n    for (let i = 0; i < n; i++) {  \n        for (let j = i; j < n; j++) {  \n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];  \n        }  \n    }  \n    // Разворачиваем каждую строку  \n    for (let i = 0; i < n; i++) {  \n        matrix[i].reverse();  \n    }  \n}  \n  \n// Тест:  \nlet matrix = [  \n    [1, 2, 3],  \n    [4, 5, 6],  \n    [7, 8, 9],  \n];  \nrotate(matrix);  \n  \nconsole.log(matrix); // [[7, 4, 1], [8, 5, 2], [9, 6, 3]]",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "place",
        "reverse",
        "image",
        "matrix",
        "rotate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 46,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 53,
      "pedagogical_type": "practice",
      "text_complexity": 0.4,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt93001jhxt8ad06wrjj",
      "title": "54. Spiral Matrix",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан двумерный массив (матрица). Необходимо вывести все его элементы по спирали, начиная с верхнего левого угла и двигаясь по часовой стрелке. Решение задачи предполагает использование четырех указателей (верх, низ, левый и правый), которые определяют текущие границы для обхода матрицы.\\n",
      "code_content": "function spiralOrder(matrix) {  \n    const result = [];  \n    if (matrix.length === 0) return result;  \n  \n    let top = 0;  \n    let bottom = matrix.length - 1;  \n    let left = 0;  \n    let right = matrix[0].length - 1;  \n  \n    while (top <= bottom && left <= right) {  \n        // Обходим верхнюю строку слева направо  \n        for (let i = left; i <= right; i++) result.push(matrix[top][i]);  \n        top++;  \n  \n        // Обходим правый столбец сверху вниз  \n        for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);  \n        right--;  \n  \n        // Обходим нижнюю строку справа налево, если еще осталась  \n        if (top <= bottom) {  \n            for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);  \n            bottom--;  \n        }  \n  \n        // Обходим левый столбец снизу вверх, если еще осталась  \n        if (left <= right) {  \n            for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);  \n            left++;  \n        }  \n    }  \n    return result;  \n}  \n  \n// Тест:  \nconst matrix = [  \n    [1, 2, 3],  \n    [4, 5, 6],  \n    [7, 8, 9],  \n];  \n  \nconsole.log(spiralOrder(matrix)); // [1, 2, 3, 6, 9, 8, 7, 4, 5]",
      "code_language": "js",
      "code_lines": 34,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (34 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "spiral",
        "bottom",
        "spiralorder",
        "right",
        "matrix",
        "top",
        "result",
        "left"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 54,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 54,
      "pedagogical_type": "practice",
      "text_complexity": 0.4,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxt9u001khxt80ap2d64f",
      "title": "55. Number of Islands",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дана двумерная сетка, где '1' представляет землю, а '0' — воду. Необходимо посчитать количество островов, где остров — это группа смежных единиц (соседство по вертикали и горизонтали). Решение основано на обходе в глубину (DFS), чтобы \"затопить\" остров и избежать повторного подсчёта.\\n",
      "code_content": "function numIslands(grid) {  \n    if (grid.length === 0) return 0;  \n    const rows = grid.length;  \n    const cols = grid[0].length;  \n    let count = 0;  \n  \n    function dfs(i, j) {  \n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] === '0') return;  \n        grid[i][j] = '0'; // Помечаем как посещенное  \n        dfs(i + 1, j);  \n        dfs(i - 1, j);  \n        dfs(i, j + 1);  \n        dfs(i, j - 1);  \n    }  \n  \n    for (let i = 0; i < rows; i++) {  \n        for (let j = 0; j < cols; j++) {  \n            if (grid[i][j] === '1') {  \n                count++;  \n                dfs(i, j);  \n            }  \n        }  \n    }  \n    return count;  \n}  \n  \n// Примеры использования:  \nconst grid1 = [  \n    ['1', '1', '0', '0', '0'],  \n    ['1', '1', '0', '0', '0'],  \n    ['0', '0', '1', '0', '0'],  \n    ['0', '0', '0', '1', '1'],  \n];  \n  \nconsole.log(numIslands(grid1)); // Ожидаемый вывод: 3  \n  \nconst grid2 = [  \n    ['1', '0', '1', '0', '1'],  \n    ['0', '1', '0', '1', '0'],  \n    ['1', '0', '1', '0', '1'],  \n];  \nconsole.log(numIslands(grid2)); // Ожидаемый вывод: 8",
      "code_language": "js",
      "code_lines": 37,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (37 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "dfs",
        "islands",
        "number",
        "cols",
        "count",
        "rows",
        "numislands",
        "grid"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 57,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 55,
      "pedagogical_type": "practice",
      "text_complexity": 0.42,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtal001lhxt8g54m0uw7",
      "title": "56. Find The Celebrity",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)"
      ],
      "text_content": "Постановка задачи:Дан массив m, представляющий матрицу, где m[a][b] === 1 означает, что человек a знает человека b, а m[a][b] === 0 — не знает. Необходимо найти знаменитость — человека, которого знают все, но который не знает никого. Если знаменитость существует, вернуть её индекс, иначе вернуть -1.\\nРешение состоит из двух шагов:\\nПоиск кандидата:Инициализируем кандидата нулевым человеком. Проходим по всем остальным людям, и если кандидат знает другого человека, обновляем кандидата на этого чел...",
      "code_content": "function getCelebrity(m) {  \n    const n = m.length;  \n    let candidate = 0;  \n  \n    // Шаг 1: Находим кандидата  \n    for (let i = 1; i < n; i++) {  \n        if (knows(candidate, i, m)) {  \n            candidate = i;  \n        }  \n    }  \n  \n    // Шаг 2: Проверяем кандидата  \n    for (let i = 0; i < n; i++) {  \n        if (i !== candidate && (knows(candidate, i, m) || !knows(i, candidate, m))) {  \n            return -1;  \n        }  \n    }  \n    return candidate;  \n}  \n  \nfunction knows(a, b, m) {  \n    return m[a][b] === 1;  \n}  \n  \nconst m1 = [  \n    [0, 1, 0],  \n    [0, 0, 0],  \n    [0, 1, 0],  \n];  \n  \nconsole.log(getCelebrity(m1)); // Ожидаемый вывод: 1  \n  \nconst m2 = [  \n    [0, 1, 1, 0],  \n    [0, 0, 1, 0],  \n    [0, 0, 0, 0],  \n    [0, 0, 1, 0],  \n];  \n  \nconsole.log(getCelebrity(m2)); // Ожидаемый вывод: 2  \n  \nconst m3 = [  \n    [0, 1],  \n    [1, 0],  \n];  \n  \nconsole.log(getCelebrity(m3)); // Ожидаемый вывод: -1 (нет знаменитости)",
      "code_language": "js",
      "code_lines": 38,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (38 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "find",
        "candidate",
        "knows",
        "getcelebrity",
        "the",
        "celebrity"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 76,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 56,
      "pedagogical_type": "practice",
      "text_complexity": 0.9,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtbd001mhxt8k0it92zs",
      "title": "57. Фильтрация, сортировка, преобразование и удаление дубликатов",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов, где каждый объект содержит следующие свойства:\\nvalue: строка;order: число;expired: булево значение.\\nНеобходимо выполнить следующие шаги:\\nОтфильтровать объекты, оставив только те, у которых свойство expired равно false.Отсортировать отфильтрованные объекты по возрастанию значения свойства order.Для каждого оставшегося объекта перевернуть строку из свойства value.Объединить перевернутые строки в одну.Удалить повторяющиеся символы из объединенной строки, со...",
      "code_content": "const data = [  \n    { value: 'abcd', order: 4, expired: false },  \n    { value: 'qwer', order: 2, expired: true },  \n    { value: 'xyz1', order: 1, expired: false },  \n    { value: 'abx2', order: 2, expired: false },  \n];  \n  \n// array methods  \nfunction filterAndSortData(data) {  \n    const validItems = data.filter(item => !item.expired);  \n  \n    validItems.sort((a, b) => a.order - b.order);  \n  \n    let concatenated = validItems.map(item => item.value.split('').reverse().join('')).join('');  \n  \n    return [...new Set(concatenated)].join('');  \n}  \n  \nconst result1 = filterAndSortData(data);  \nconsole.log(result1);",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средние концепции (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_map",
        "array_filter"
      ],
      "keywords": [
        "concatenated",
        "item",
        "reverse",
        "nvalue",
        "filter",
        "filterandsortdata",
        "data",
        "value",
        "map",
        "order",
        "sort",
        "set",
        "expired",
        "validitems",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 55,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 57,
      "pedagogical_type": "practice",
      "text_complexity": 0.56,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtcb001nhxt8r4jhte4d",
      "title": "58. Фильтрация, сортировка, преобразование и удаление дубликатов с использованием разных подходов",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Дан массив объектов с полями:\\nvalue — строка,order — число,expired — булевое значение.\\nНеобходимо выполнить следующие операции:\\nОтфильтровать объекты, оставив только те, у которых expired равно false.Отсортировать оставшиеся объекты по возрастанию значения свойства order.Для каждого объекта перевернуть строку из свойства value.Объединить перевернутые строки в одну строку.Удалить из полученной строки дубликаты символов, сохраняя порядок их первого появления.Вернуть итоговую с...",
      "code_content": "const input = [  \n    { value: 'abcd', order: 4, expired: false },  \n    { value: 'qwer', order: 2, expired: true },  \n    { value: 'xyz1', order: 1, expired: false },  \n    { value: 'abx2', order: 2, expired: false },  \n];  \n  \n// array methods  \nfunction generateResult(input) {  \n    const validItems = input.filter(item => !item.expired);  \n  \n    validItems.sort((a, b) => a.order - b.order);  \n  \n    let concatenated = validItems  \n        .map(item => item.value.split('').reverse().join(''))  \n        .join('');  \n  \n    return [...new Set(concatenated)].join('');  \n}  \n\nconst result1 = generateResult(input);  \nconsole.log(result1);  \n  \n// set  \nfunction generateResult2(input) {  \n    const filteredSortedItems = input  \n        .filter(item => !item.expired)  \n        .sort((a, b) => a.order - b.order);  \n  \n    const uniqueChars = new Set();  \n    let result = '';  \n  \n    for (const item of filteredSortedItems) {  \n        const reversedValue = item.value.split('').reverse().join('');  \n        for (const char of reversedValue) {  \n            if (!uniqueChars.has(char)) {  \n                uniqueChars.add(char);  \n                result += char;  \n            }  \n        }  \n    }  \n    return result;  \n}  \n  \nconst result2 = generateResult2(input);  \nconsole.log(result2);  \n  \n// reduce  \nfunction generateResult3(input) {  \n    return input  \n        .filter(item => !item.expired)  \n        .sort((a, b) => a.order - b.order)  \n        .reduce((acc, item) => {  \n            const reversed = item.value.split('').reverse().join('');  \n            for (const char of reversed) {  \n                if (!acc.seen.has(char)) {  \n                    acc.seen.add(char);  \n                    acc.result += char;  \n                }  \n            }  \n            return acc;  \n        }, { result: '', seen: new Set() }).result;  \n}  \n  \nconst result3 = generateResult3(input);  \nconsole.log(result3);",
      "code_language": "js",
      "code_lines": 55,
      "complexity_score": 6.5,
      "difficulty_factors": [
        "Длинный код (55 строк)",
        "Средняя вложенность (4)",
        "Средние концепции (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_map",
        "array_filter",
        "array_reduce"
      ],
      "keywords": [
        "filteredsorteditems",
        "input",
        "value",
        "add",
        "set",
        "expired",
        "validitems",
        "join",
        "reverse",
        "acc",
        "filter",
        "generateresult",
        "seen",
        "map",
        "char",
        "split",
        "sort",
        "concatenated",
        "item",
        "reversedvalue",
        "nvalue",
        "reduce",
        "uniquechars",
        "result",
        "order",
        "has",
        "reversed"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 109,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 58,
      "pedagogical_type": "exercise",
      "text_complexity": 0.72,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtd2001ohxt8fy12nxiy",
      "title": "59. Работа с массивом объектов: группировка и сортировка по году",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Напишите функцию, которая на вход принимает массив объектов с полями date и amount. Функция должна вернуть объект, в котором:\\nКлючи — это год, извлечённый из поля date каждого объекта.Значения — массивы объектов, относящихся к этому году, отсортированные по дате (в порядке возрастания).\\nПример входных данных:\\nАлгоритм решения:\\nПройтись по массиву и сгруппировать объекты по году, извлекая год из поля date.Для каждого года отсортировать массив объектов по дате.Вернуть итоговы...",
      "code_content": "const operations = [\n  { \"date\": \"2017-07-31\", \"amount\": \"5422\" },\n  { \"date\": \"2017-06-30\", \"amount\": \"5220\" },\n  { \"date\": \"2017-05-31\", \"amount\": \"5365\" },\n  { \"date\": \"2017-08-31\", \"amount\": \"5451\" },\n  { \"date\": \"2017-09-30\", \"amount\": \"5303\" },\n  { \"date\": \"2018-03-31\", \"amount\": \"5654\" },\n  { \"date\": \"2017-10-31\", \"amount\": \"5509\" },\n  { \"date\": \"2017-12-31\", \"amount\": \"5567\" },\n  { \"date\": \"2017-11-30\", \"amount\": \"5597\" },\n  { \"date\": \"2018-01-31\", \"amount\": \"5392\" },\n  { \"date\": \"2018-02-28\", \"amount\": \"5087\" },\n  { \"date\": \"2018-04-14\", \"amount\": \"2567\" }\n];",
      "code_language": "js",
      "code_lines": 14,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables"
      ],
      "js_features_used": [],
      "keywords": [
        "amount",
        "date",
        "operations"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 44,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 59,
      "pedagogical_type": "example",
      "text_complexity": 1.16,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtdt001phxt8sus1xbly",
      "title": "60. Find All Duplicates in an Array",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Дан массив чисел, где каждый элемент находится в диапазоне от 1 до n (n — длина массива). Некоторые элементы могут повторяться. Необходимо найти все дубликаты, то есть те элементы, которые появляются дважды. Задачу можно решить, изменяя входной массив (in-place) или используя дополнительные структуры данных. Приведены несколько подходов:\\nПометка с помощью отрицания:Проходим по массиву и используем значение каждого элемента для вычисления индекса.Если элемент по этому индексу у...",
      "code_content": "// 1. Пометка с помощью отрицания  \nfunction findDuplicatesNegation(nums) {  \n    const duplicates = [];  \n    for (let i = 0; i < nums.length; i++) {  \n        const index = Math.abs(nums[i]) - 1;  \n        if (nums[index] < 0) {  \n            duplicates.push(index + 1);  \n        } else {  \n            nums[index] = -nums[index];  \n        }  \n    }  \n    // Восстанавливаем исходный массив  \n    for (let i = 0; i < nums.length; i++) {  \n        nums[i] = Math.abs(nums[i]);  \n    }  \n    return duplicates;  \n}  \n  \nconst nums1 = [4, 3, 2, 7, 8, 2, 3, 1];  \nconsole.log(findDuplicatesNegation(nums1));  \n  \n  \n// 2. Сортировка с использованием обмена  \nfunction findDuplicatesSwap(nums) {  \n    const duplicates = [];  \n    for (let i = 0; i < nums.length; i++) {  \n        while (nums[i] !== nums[nums[i] - 1]) {  \n            const temp = nums[i];  \n            nums[i] = nums[temp - 1];  \n            nums[temp - 1] = temp;  \n        }  \n    }  \n    for (let i = 0; i < nums.length; i++) {  \n        if (nums[i] !== i + 1) {  \n            duplicates.push(nums[i]);  \n        }  \n    }  \n    return duplicates;  \n}  \n  \nconst nums2 = [4, 3, 2, 7, 8, 2, 3, 1];  \nconsole.log(findDuplicatesSwap(nums2));  \n  \n  \n// 3. Изменение массива как счётчика  \nfunction findDuplicatesCounting(nums) {  \n    const duplicates = [];  \n    const n = nums.length;  \n    for (let i = 0; i < n; i++) {  \n        const index = (nums[i] - 1) % n;  \n        nums[index] += n;  \n    }  \n    for (let i = 0; i < n; i++) {  \n        if (nums[i] > 2 * n) {  \n            duplicates.push(i + 1);  \n        }  \n    }  \n    return duplicates;  \n}  \n  \nconst nums3 = [4, 3, 2, 7, 8, 2, 3, 1];  \nconsole.log(findDuplicatesCounting(nums3));  \n  \n  \n// 4. Использование Set  \nfunction findDuplicatesSet(nums) {  \n    const duplicates = [];  \n    const seen = new Set();  \n    for (const num of nums) {  \n        if (seen.has(num)) {  \n            duplicates.push(num);  \n        } else {  \n            seen.add(num);  \n        }  \n    }  \n    return duplicates;  \n}  \n  \nconst nums4 = [4, 3, 2, 7, 8, 2, 3, 1];  \nconsole.log(findDuplicatesSet(nums4));  \n  \n  \n// 5. Абсолют индексная маркировка  \nfunction findDuplicatesAbsoluteMarking(nums) {  \n    const duplicates = [];  \n    const n = nums.length;  \n    for (let i = 0; i < n; i++) {  \n        const index = Math.abs(nums[i]) - 1;  \n        if (nums[index] < 0) {  \n            duplicates.push(index + 1);  \n        } else {  \n            nums[index] *= -1;  \n        }  \n    }  \n    for (let i = 0; i < n; i++) {  \n        nums[i] = Math.abs(nums[i]);  \n    }  \n    return duplicates;  \n}  \n  \nconst nums5 = [4, 3, 2, 7, 8, 2, 3, 1];  \nconsole.log(findDuplicatesAbsoluteMarking(nums5));",
      "code_language": "js",
      "code_lines": 89,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Длинный код (89 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "searching",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "find",
        "temp",
        "add",
        "set",
        "duplicates",
        "num",
        "all",
        "findduplicatesabsolutemarking",
        "nums",
        "findduplicatescounting",
        "seen",
        "index",
        "array",
        "findduplicatesset",
        "findduplicatesswap",
        "place",
        "abs",
        "math",
        "has",
        "findduplicatesnegation"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 120,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 60,
      "pedagogical_type": "practice",
      "text_complexity": 1.47,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxujl0028hxt8lotcvh0v",
      "title": "2. sum 3",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализуйте каррированную функцию sum, которая может принимать неограниченное количество аргументов в цепочке вызовов и возвращать их сумму, когда вызов завершён без аргументов. Если функция вызывается без аргументов, она должна вернуть 0.\\n",
      "code_content": "const sum = (a = 0) => {\n  return (b) => b !== undefined ? sum(a + b) : a;\n};\n\n// Примеры использования:\nconsole.log(sum()); // Вернет 0\nconsole.log(sum(1)()); // Вернет 1\nconsole.log(sum(2)(3)()); // Вернет 5\nconsole.log(sum(10)(7)(41)()); // Вернет 58",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "sum"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 31,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.32,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtek001qhxt8dp3pcpki",
      "title": "61. mergeIntervals",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Дан массив интервалов, где каждый интервал представлен массивом из двух чисел [start, end]. Необходимо объединить все пересекающиеся интервалы и вернуть новый массив, содержащий только объединенные интервалы.\\nАлгоритм решения:\\nЕсли входной массив пуст, возвращаем пустой массив.Сортируем интервалы по их начальным значениям.Инициализируем массив merged первым интервалом.Проходим по оставшимся интервалам и для каждого:Если текущий интервал пересекается с последним интервалом в m...",
      "code_content": "const mergeIntervals = function(intervals) {  \n    if (intervals.length === 0) return [];  \n  \n    // Шаг 1: Сортируем интервалы по началу  \n    intervals.sort((a, b) => a[0] - b[0]);  \n  \n    // Шаг 2: Создаем массив для хранения объединенных интервалов  \n    const merged = [intervals[0]];  \n  \n    for (let i = 1; i < intervals.length; i++) {  \n        const lastMerged = merged[merged.length - 1];  \n        const current = intervals[i];  \n  \n        // Если текущий интервал пересекается с последним объединенным интервалом, объединяем их  \n        if (current[0] <= lastMerged[1]) {  \n            lastMerged[1] = Math.max(lastMerged[1], current[1]);  \n        } else {  \n            // Если нет пересечения, добавляем текущий интервал в результат  \n            merged.push(current);  \n        }  \n    }  \n    return merged;  \n};  \n  \n// Примеры использования  \nconst intervals1 = [[1, 3], [2, 6], [7, 8], [8, 10], [15, 18]];  \nconsole.log(mergeIntervals(intervals1)); // [[1, 6], [7, 10], [15, 18]]  \n  \nconst intervals2 = [[1, 4], [4, 5]];  \nconsole.log(mergeIntervals(intervals2)); // [[1, 5]]  \n  \nconst intervals3 = [[1, 4]];  \nconsole.log(mergeIntervals(intervals3)); // [[1, 4]]  \n  \nconst intervals4 = [];  \nconsole.log(mergeIntervals(intervals4)); // []",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "max",
        "merged",
        "lastmerged",
        "mergeintervals",
        "start",
        "math",
        "current",
        "intervals",
        "end",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 86,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 61,
      "pedagogical_type": "practice",
      "text_complexity": 1.41,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtfb001rhxt8mtm6j2j3",
      "title": "62. countShips",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Дан одномерный массив, представляющий квадратное поле, где 1 обозначает часть корабля, а 0 — пустую клетку. Размер поля вычисляется как корень квадратный из длины массива. Необходимо посчитать количество кораблей, где корабль — это группа смежных единиц (соседство по вертикали и горизонтали). Решение предполагает преобразование одномерного массива в двумерный и применение обхода в глубину (DFS) для подсчёта и \"затопления\" кораблей.\\n",
      "code_content": "function countShips(field) {  \n    const n = Math.sqrt(field.length);  \n    const grid = [];  \n    let index = 0;  \n  \n    // Преобразуем одномерный массив в двумерный массив (grid) размером n x n  \n    for (let i = 0; i < n; i++) {  \n        grid.push(field.slice(index, index + n));  \n        index += n;  \n    }  \n  \n    let count = 0;  \n  \n    // Функция DFS для обхода и \"затопления\" корабля  \n    function dfs(i, j) {  \n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] === 0) {  \n            return;  \n        }  \n        grid[i][j] = 0;  \n        dfs(i + 1, j);  \n        dfs(i - 1, j);  \n        dfs(i, j + 1);  \n        dfs(i, j - 1);  \n    }  \n  \n    // Проходим по всем клеткам поля и считаем корабли  \n    for (let i = 0; i < n; i++) {  \n        for (let j = 0; j < n; j++) {  \n            if (grid[i][j] === 1) {  \n                count++;  \n                dfs(i, j);  \n            }  \n        }  \n    }  \n    return count;  \n}  \n  \n// Пример 1: Поле размером 4x4  \nconst field1 = [  \n    0, 1, 0, 1,  \n    0, 0, 0, 1,  \n    0, 0, 0, 0,  \n    1, 1, 1, 0  \n];  \nconsole.log(countShips(field1)); // Ожидаемый вывод: 3  \n  \n// Пример 2: Поле размером 4x4 с другими кораблями  \nconst field2 = [  \n    0, 0, 0, 1,  \n    1, 0, 0, 1,  \n    0, 0, 0, 0,  \n    1, 1, 1, 0  \n];  \nconsole.log(countShips(field2)); // Ожидаемый вывод: 3  \n  \n// Пример 3: Поле размером 5x5  \nconst field3 = [  \n    1, 0, 0, 1, 0,  \n    0, 0, 0, 1, 0,  \n    1, 0, 0, 0, 0,  \n    0, 0, 1, 1, 0,  \n    1, 0, 0, 0, 0  \n];  \nconsole.log(countShips(field3)); // Ожидаемый вывод: 5\n",
      "code_language": "js",
      "code_lines": 57,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Длинный код (57 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "dfs",
        "grid",
        "slice",
        "sqrt",
        "count",
        "math",
        "field",
        "countships",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 82,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 62,
      "pedagogical_type": "practice",
      "text_complexity": 0.6,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtg2001shxt84ztkofyt",
      "title": "63. median of two sorted arrays",
      "category": "JS",
      "subcategory": "Array",
      "path_titles": [
        "Средние – сложные (задачи с более высоким алгоритмическим накалом)"
      ],
      "text_content": "Постановка задачи:Даны два отсортированных массива nums1 и nums2. Необходимо найти медиану объединённого массива. Решение должно работать за логарифмическое время, что достигается с помощью поиска k-го элемента (с использованием подхода \"разделяй и властвуй\").\\nАлгоритм решения:\\nВычисляем общее количество элементов.Если общее количество нечетное, медианой будет элемент с индексом (totalLen / 2) + 1.Если количество четное, медиана – это среднее арифметическое двух центральных элементов.Для поиск...",
      "code_content": "function findMedianSortedArrays(nums1, nums2) {  \n    const totalLen = nums1.length + nums2.length;  \n    if (totalLen % 2 === 1) {  \n        return getKth(nums1, nums2, Math.floor(totalLen / 2) + 1);  \n    } else {  \n        return (  \n            (getKth(nums1, nums2, totalLen / 2) +  \n             getKth(nums1, nums2, totalLen / 2 + 1)) /  \n            2  \n        );  \n    }  \n}  \n  \nfunction getKth(nums1, nums2, k) {  \n    let index1 = 0, index2 = 0;  \n  \n    while (true) {  \n        // Если один из массивов исчерпан, возвращаем k-й элемент из второго массива  \n        if (index1 === nums1.length) return nums2[index2 + k - 1];  \n        if (index2 === nums2.length) return nums1[index1 + k - 1];  \n        if (k === 1) return Math.min(nums1[index1], nums2[index2]);  \n  \n        // Определяем новые индексы для сравнения  \n        const newIndex1 = Math.min(index1 + Math.floor(k / 2) - 1, nums1.length - 1);  \n        const newIndex2 = Math.min(index2 + Math.floor(k / 2) - 1, nums2.length - 1);  \n  \n        const pivot1 = nums1[newIndex1];  \n        const pivot2 = nums2[newIndex2];  \n  \n        if (pivot1 <= pivot2) {  \n            k -= newIndex1 - index1 + 1;  \n            index1 = newIndex1 + 1;  \n        } else {  \n            k -= newIndex2 - index2 + 1;  \n            index2 = newIndex2 + 1;  \n        }  \n    }  \n}  \n  \nconsole.log(findMedianSortedArrays([1, 3], [2])); // Ожидаемый вывод: 2.0  \nconsole.log(findMedianSortedArrays([1, 2], [3, 4])); // Ожидаемый вывод: 2.5  \nconsole.log(findMedianSortedArrays([0, 0], [0, 0])); // Ожидаемый вывод: 0.0  \nconsole.log(findMedianSortedArrays([], [1]));       // Ожидаемый вывод: 1.0  \nconsole.log(findMedianSortedArrays([2], []));       // Ожидаемый вывод: 2.0",
      "code_language": "js",
      "code_lines": 38,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (38 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "sorting",
        "searching",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "findmediansortedarrays",
        "floor",
        "two",
        "sorted",
        "math",
        "median",
        "getkth",
        "min",
        "arrays",
        "totallen"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 82,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 63,
      "pedagogical_type": "practice",
      "text_complexity": 1.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtvk001uhxt8fcidaqns",
      "title": "Эммитер Т-Банк",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [
        "1. эммитер"
      ],
      "text_content": "Задача: Реализовать класс EventEmitter, который позволяет подписываться (on), отписываться (off) и вызывать (emit) события с передачей аргументов.\\n",
      "code_content": "class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(eventName, callback) {\n    (this.events[eventName] ||= []).push(callback);\n  }\n\n  off(eventName, callback) {\n    if (!this.events[eventName]) return;\n    this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);\n    if (!this.events[eventName].length) delete this.events[eventName];\n  }\n\n  emit(eventName, ...args) {\n    this.events[eventName]?.forEach(callback => callback(...args));\n  }\n}\n\n// Пример использования:\nconst emitter = new EventEmitter();\n\nfunction listener(data) {\n  console.log(\"Получено событие:\", data);\n}\n\nemitter.on(\"testEvent\", listener);\nemitter.emit(\"testEvent\", { message: \"Hello World!\" }); // Получено событие: { message: \"Hello World!\" }\n\nemitter.off(\"testEvent\", listener);\nemitter.emit(\"testEvent\", { message: \"This will not be logged\" }); // Подписчиков нет",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "es6_classes",
        "constructor",
        "array_filter",
        "array_forEach"
      ],
      "keywords": [
        "filter",
        "emitter",
        "callback",
        "eventname",
        "eventemitter",
        "listener",
        "foreach",
        "data",
        "message",
        "delete",
        "off",
        "args",
        "emit",
        "constructor",
        "events"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 48,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.17,
      "user_success_rate": 1.0,
      "avg_solve_time": 1.0
    },
    {
      "id": "cmbhuxukd0029hxt8s70bhq5t",
      "title": "3. перегрузка аргументов",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализуйте функцию f, которая поддерживает два варианта вызова:\\nЕсли функция вызывается с двумя аргументами, она возвращает их сумму.Если функция вызывается с одним аргументом, она возвращает другую функцию, ожидающую второй аргумент для последующего сложения.\\n",
      "code_content": "function f(a, b) {  \n    if (b !== undefined) return a + b;  \n    else return (b) => a + b;  \n}  \n  \nconsole.log(f(2, 3)); // 5  \nconsole.log(f(2)(3)); // 5",
      "code_language": "js",
      "code_lines": 6,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "conditionals",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 30,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy12c0067hxt8uobjhtnj",
      "title": "Рефактор задержки с while",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "3. ОТП БАНК"
      ],
      "text_content": "",
      "code_content": "const ExpensiveTree = memo(() => {\n  const now = performance.now();\n  while (performance.now() - now < 500) {}\n  return <p>Slow component</p>;\n});",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "objects",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "component",
        "performance",
        "slow",
        "expensivetree",
        "now",
        "memo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 22,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 17,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtw9001vhxt81jngl6xv",
      "title": "эмиттер литкод",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [
        "1. эммитер"
      ],
      "text_content": "Задача: Реализовать класс EventEmitter, аналогичный задаче с LeetCode, который поддерживает подписку (subscribe), отписку (unsubscribe) и вызов (emit) событи\\n✅ Особенности:\\nПростая подписка и отписка.Хранение обработчиков событий в Map для быстрого доступа.Использование Set для хранения колбэков исключает дублирование обработчиков.Возвращает функцию для удобного удаления подписки.\\n",
      "code_content": "class EventEmitter {\n  constructor() {\n    this.events = new Map();\n  }\n\n  // Подписка на событие\n  subscribe(event, callback) {\n    if (!this.events.has(event)) {\n      this.events.set(event, new Set());\n    }\n    const callbacks = this.events.get(event);\n    callbacks.add(callback);\n\n    // Возвращаем функцию для отписки\n    return () => this.unsubscribe(event, callback);\n  }\n\n  // Отписка от события\n  unsubscribe(event, callback) {\n    if (!this.events.has(event)) return;\n    const callbacks = this.events.get(event);\n    callbacks.delete(callback);\n    if (callbacks.size === 0) {\n      this.events.delete(event);\n    }\n  }\n\n  // Вызов события с аргументами\n  emit(event, ...args) {\n    if (!this.events.has(event)) return;\n    this.events.get(event).forEach(callback => callback(...args));\n  }\n}\n\n// Пример использования\nconst emitter = new EventEmitter();\n\nconst handler = (data) => console.log(`Received: ${data}`);\n\nconst unsubscribe = emitter.subscribe(\"event1\", handler);\nemitter.emit(\"event1\", \"Hello!\"); // Output: Received: Hello!\n\nunsubscribe(); // Отписка\nemitter.emit(\"event1\", \"World!\"); // Нет вывода",
      "code_language": "js",
      "code_lines": 36,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (36 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "classes",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals",
        "es6_classes",
        "constructor",
        "array_forEach"
      ],
      "keywords": [
        "callbacks",
        "emitter",
        "add",
        "get",
        "set",
        "events",
        "subscribe",
        "handler",
        "constructor",
        "size",
        "eventemitter",
        "map",
        "foreach",
        "delete",
        "args",
        "emit",
        "leetcode",
        "unsubscribe",
        "callback",
        "data",
        "has",
        "received",
        "event"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 67,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.91,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtx0001whxt8x62v3c2t",
      "title": "эмиттер точка банк",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [
        "1. эммитер"
      ],
      "text_content": "Задача: Реализовать улучшенный класс Emitter, который:\\nПозволяет подписываться на события (on);Возвращает функцию для отписки при подписке;Позволяет отписываться от событий (off);Корректно обрабатывает вызовы обработчиков событий (emit);Поддерживает одноразовую подписку (once).\\n",
      "code_content": "class Emitter {  \n    constructor() {  \n        this.events = new Map();  \n    }  \n  \n    // Subscribe to an event  \n    on(eventName, listener) {  \n        if (!this.events.has(eventName)) {  \n            this.events.set(eventName, new Set());  \n        }  \n        const listeners = this.events.get(eventName);  \n        listeners.add(listener);  \n  \n        // Return an unsubscribe function  \n        return () => {  \n            this.off(eventName, listener);  \n        };  \n    }  \n  \n    // Unsubscribe from an event  \n    off(eventName, listener) {  \n        const listeners = this.events.get(eventName);  \n        if (!listeners) return;  \n        listeners.delete(listener);  \n        if (listeners.size === 0) {  \n            this.events.delete(eventName);  \n        }  \n    }  \n    // Emit an event  \n    emit(eventName, ...args) {  \n        const listeners = this.events.get(eventName);  \n        if (!listeners) return;  \n  \n        // Create a copy to prevent modification during iteration  \n        const listenersCopy = Array.from(listeners);  \n        listenersCopy.forEach((listener) => {  \n            try {  \n                listener(...args);  \n            } catch (error) {  \n                console.error(`Error in listener for event '${eventName}':`, error);  \n            }  \n        });  \n    }  \n  \n    // Subscribe to an event once  \n    once(eventName, listener) {  \n        const wrapper = (...args) => {  \n            listener(...args);  \n            this.off(eventName, wrapper);  \n        };  \n        this.on(eventName, wrapper);  \n    }  \n}  \n  \n  \nconst emitter = new Emitter();  \n  \nconst handlerTest = () => console.log('Ho-ho-ho!');  \nemitter.on('foo', handlerTest);  \nemitter.on('foo', (...data) => console.log('foo', ...data));  \nemitter.on('bar', (data) => console.log('bar', data));  \n  \nemitter.emit('foo', 'Hello', 'World!');  \n// Ho-ho-ho!  \n// foo Hello World!  \n  \nemitter.emit('bar', 'Hello', 'World!');  \n// bar Hello  \n  \nemitter.off('foo', handlerTest);  \n  \nemitter.emit('foo', 'Test');  \n// foo Test  \n  \nemitter.emit('bar');  \n// bar undefined",
      "code_language": "js",
      "code_lines": 63,
      "complexity_score": 6.5,
      "difficulty_factors": [
        "Длинный код (63 строк)",
        "Глубокая вложенность (5)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "classes",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "error_handling",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals",
        "es6_classes",
        "constructor",
        "array_forEach"
      ],
      "keywords": [
        "emitter",
        "listener",
        "add",
        "get",
        "set",
        "once",
        "events",
        "listeners",
        "handlertest",
        "wrapper",
        "constructor",
        "eventname",
        "size",
        "array",
        "map",
        "foreach",
        "error",
        "try",
        "delete",
        "off",
        "args",
        "emit",
        "data",
        "catch",
        "listenerscopy",
        "has",
        "from",
        "event"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 91,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.27,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtxs001xhxt8l4xr9x12",
      "title": "эмиттер яндекс-мультитрак с усложнениями",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [
        "1. эммитер"
      ],
      "text_content": "Задача: Реализовать класс EventEmitter с дополнительными возможностями, такими как очередность событий, обработка асинхронных событий или поддержка различных режимов вызова.\\nДобавлены:\\nАсинхронные события (поддержка промисов в обработчиках).Очередь событий (гарантия выполнения в порядке поступления).Режим once (одноразовая подписка).Фильтрация событий (можно передавать фильтр-функцию).\\n",
      "code_content": "class AdvancedEventEmitter {\n  constructor() {\n    this.events = new Map();\n    this.queue = [];\n    this.isProcessing = false;\n  }\n\n  // Подписка на событие\n  subscribe(event, callback) {\n    if (!this.events.has(event)) {\n      this.events.set(event, new Set());\n    }\n    this.events.get(event).add(callback);\n\n    return () => this.unsubscribe(event, callback);\n  }\n\n  // Одноразовая подписка\n  once(event, callback) {\n    const wrapper = (...args) => {\n      callback(...args);\n      this.unsubscribe(event, wrapper);\n    };\n    this.subscribe(event, wrapper);\n  }\n\n  // Отписка от события\n  unsubscribe(event, callback) {\n    if (!this.events.has(event)) return;\n    const callbacks = this.events.get(event);\n    callbacks.delete(callback);\n    if (callbacks.size === 0) {\n      this.events.delete(event);\n    }\n  }\n\n  // Вызов события (асинхронная обработка с очередью)\n  async emit(event, ...args) {\n    if (!this.events.has(event)) return;\n\n    this.queue.push({ event, args });\n    if (!this.isProcessing) {\n      this.isProcessing = true;\n      while (this.queue.length > 0) {\n        const { event, args } = this.queue.shift();\n        await this._processEvent(event, args);\n      }\n      this.isProcessing = false;\n    }\n  }\n\n  // Внутренний обработчик событий\n  async _processEvent(event, args) {\n    if (!this.events.has(event)) return;\n    const callbacks = [...this.events.get(event)];\n\n    for (const callback of callbacks) {\n      try {\n        const result = callback(...args);\n        if (result instanceof Promise) {\n          await result; // Ждем выполнения промиса\n        }\n      } catch (error) {\n        console.error(`Ошибка в обработчике события \"${event}\":`, error);\n      }\n    }\n  }\n}\n\n// Пример использования\nconst emitter = new AdvancedEventEmitter();\n\nconst asyncHandler = async (data) => {\n  await new Promise(resolve => setTimeout(resolve, 1000)); // Симуляция задержки\n  console.log(`Async received: ${data}`);\n};\n\nconst syncHandler = (data) => console.log(`Sync received: ${data}`);\n\nemitter.subscribe(\"event1\", asyncHandler);\nemitter.subscribe(\"event1\", syncHandler);\n\nconsole.log(\"Emit start...\");\nemitter.emit(\"event1\", \"Hello!\"); // Асинхронное выполнение\n\n// Одноразовое событие\nemitter.once(\"event1\", (data) => console.log(`Received ONCE: ${data}`));\n\nsetTimeout(() => {\n  console.log(\"Emit second time...\");\n  emitter.emit(\"event1\", \"Second event\");\n}, 3000);\n\n// Output:\n// Emit start...\n// Sync received: Hello!\n// (Спустя 1 секунду) Async received: Hello!\n// Received ONCE: Hello!\n// Emit second time...\n// Sync received: Second event\n// (Спустя 1 секунду) Async received: Second event",
      "code_language": "js",
      "code_lines": 85,
      "complexity_score": 10.5,
      "difficulty_factors": [
        "Длинный код (85 строк)",
        "Глубокая вложенность (5)",
        "Сложные концепции (2)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "classes",
        "async",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "error_handling",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals",
        "object_destructuring",
        "async_await",
        "promises",
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "callbacks",
        "await",
        "emitter",
        "asynchandler",
        "async",
        "set",
        "get",
        "add",
        "queue",
        "once",
        "synchandler",
        "events",
        "promise",
        "isprocessing",
        "subscribe",
        "wrapper",
        "constructor",
        "size",
        "sync",
        "eventemitter",
        "map",
        "error",
        "try",
        "delete",
        "args",
        "emit",
        "resolve",
        "instanceof",
        "unsubscribe",
        "callback",
        "data",
        "settimeout",
        "advancedeventemitter",
        "catch",
        "result",
        "has",
        "received",
        "event"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 120,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.87,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtyl001yhxt8pgy5uxwd",
      "title": "2. Implement Queue using Stacks",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать класс Queue, используя два стека. Очередь должна поддерживать методы enqueue (добавление элемента) и dequeue (удаление элемента по FIFO).\\n",
      "code_content": "class Stack {  \n    constructor() {  \n        this.items = [];  \n    }  \n  \n    push(data) {  \n        this.items.push(data);  \n    }  \n  \n    pop() {  \n        return this.items.pop();  \n    }  \n  \n    size() {  \n        return this.items.length;  \n    }  \n}  \n  \nclass Queue {  \n    constructor() {  \n        this.stack1 = new Stack();  \n        this.stack2 = new Stack();  \n    }  \n  \n    enqueue(data) {  \n        this.stack1.push(data);  \n    }  \n  \n    dequeue() {  \n        if (this.stack2.size() === 0) {  \n            while (this.stack1.size() > 0) {  \n                this.stack2.push(this.stack1.pop());  \n            }  \n        }  \n        if (this.stack2.size() === 0) {  \n            throw new Error('Queue is empty');  \n        }  \n  \n        return this.stack2.pop();  \n    }  \n  \n    size() {  \n        return this.stack1.size() + this.stack2.size();  \n    }  \n}  \n  \n  \nconst queue = new Queue();  \n  \n  \nqueue.enqueue(1);  \n  \nqueue.enqueue(2);  \n  \nqueue.enqueue(3);  \n  \nconsole.log(queue.dequeue()); // Output: 1  \n  \n  \nqueue.enqueue(4);  \n  \nconsole.log(queue.dequeue()); // Output: 2  \n  \nconsole.log(queue.dequeue()); // Output: 3  \n  \nconsole.log(queue.dequeue()); // Output: 4  \n  \n// queue.dequeue(); // Uncommenting this line would throw an Error: Queue is empty",
      "code_language": "js",
      "code_lines": 47,
      "complexity_score": 6.0,
      "difficulty_factors": [
        "Средний код (47 строк)",
        "Средняя вложенность (4)",
        "Сложные концепции (1)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "classes",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "throw",
        "fifo",
        "enqueue",
        "dequeue",
        "items",
        "using",
        "data",
        "size",
        "error",
        "stacks",
        "implement",
        "queue",
        "stack",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 72,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxtze001zhxt8gi7a8rbq",
      "title": "3. синглтон",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать паттерн \"Singleton\", который гарантирует, что у класса может быть только один экземпляр, доступный через getInstance().\\n",
      "code_content": "\nclass Singleton {  \n    constructor() {  \n        if (Singleton._instance) {  \n            throw new Error('Singleton classes cannot be instantiated more than once.');  \n        }  \n        Singleton._instance = this;  \n        }  \n  \n    static getInstance() {  \n        if (!Singleton._instance) {  \n            Singleton._instance = new Singleton();  \n        }  \n        return Singleton._instance;  \n    }  \n}  \n  \nconst first = Singleton.getInstance();  \n  \nconst second = Singleton.getInstance();  \n  \nconsole.log(first === second); // Output: true",
      "code_language": "js",
      "code_lines": 17,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "classes",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "throw",
        "second",
        "error",
        "singleton",
        "first",
        "static",
        "constructor",
        "getinstance"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 36,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.67,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu050020hxt8rivfqodp",
      "title": "4. класс store",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать класс Store, который позволяет:\\nХранить состояние (get);Обновлять состояние (set);Подписываться на изменения (subscribe);Отписываться от подписки.\\n",
      "code_content": "class Store {  \n    constructor() {  \n        this._state = {};  \n        this._listeners = new Set();  \n    }  \n  \n    set(newState) {  \n        const prevState = this._state;  \n        this._state = { ...this._state, ...newState };  \n        this._listeners.forEach((listener) => listener(this._state, prevState));  \n    }  \n  \n    get() {  \n        return { ...this._state }; // Return a copy to prevent external mutation  \n    }  \n  \n    subscribe(listener) {  \n        this._listeners.add(listener);  \n        return () => {  \n            this._listeners.delete(listener);  \n        };  \n    }  \n}  \n  \nconst store = new Store();  \n  \nconst unsubscribe = store.subscribe((newState, prevState) => {  \n    console.log('State changed from', prevState, 'to', newState);  \n});  \n  \nstore.set({ name: 'Alice' });  \n  \n// Output: State changed from {} to { name: 'Alice' }  \n  \nstore.set({ age: 30 });  \n  \n// Output: State changed from { name: 'Alice' } to { name: 'Alice', age: 30 }  \n  \nconsole.log(store.get()); // Output: { name: 'Alice', age: 30 }  \n  \nunsubscribe(); // Stop listening to state changes  \n  \nstore.set({ name: 'Bob' });  \n// No output; listener has been unsubscribed",
      "code_language": "js",
      "code_lines": 32,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (32 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "objects",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "es6_classes",
        "constructor",
        "array_forEach"
      ],
      "keywords": [
        "name",
        "unsubscribe",
        "subscribe",
        "listener",
        "foreach",
        "prevstate",
        "delete",
        "age",
        "set",
        "get",
        "newstate",
        "add",
        "store",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 50,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu0y0021hxt8m2amkhfg",
      "title": "5. класс cat",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Исследовать работу this в разных контекстах:\\nВнутри класса;В стрелочных функциях;В обычных функциях;При bind().\\n",
      "code_content": "class Cat {  \n    sound = 'meow';  \n  \n    say = () => {  \n        console.log(this.sound);  \n    };  \n  \n    say2() {  \n        console.log(this.sound);  \n    }  \n}  \n  \nconst myCat = {  \n    sound: 'meow meow',  \n    say: () => {  \n        console.log(this.sound);  \n    },  \n    say2: function () {  \n        console.log(this.sound);  \n    }  \n};  \n  \nconst cat = new Cat();  \n  \ncat.say();    // 'meow'  \ncat.say2();   // 'meow'  \n  \n// myCat.say();   // undefined  \n  \nmyCat.say2();  // 'meow meow'  \n  \nconst outSay = cat.say.bind(myCat);  \nconst outSay2 = cat.say2.bind(cat);  \nconst outSay3 = cat.say2.bind(myCat);  \n  \noutSay();    // Output: 'meow'  \n  \noutSay2();   // 'meow'  \n  \noutSay3();   // 'meow meow'",
      "code_language": "js",
      "code_lines": 29,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (29 строк)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "classes",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "es6_classes"
      ],
      "keywords": [
        "outsay",
        "sound",
        "bind",
        "mycat",
        "say",
        "cat"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 43,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "exercise",
      "text_complexity": 0.13,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu1p0022hxt83jo9hqhv",
      "title": "6. класс на основании инстанса + типизация",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать класс List<T>, который:\\nПозволяет хранить элементы в Map, используя функцию getItemKey для получения уникального ключа;Позволяет добавлять (addItem) и удалять (removeItem) элементы;Предоставляет ReadonlyArray<T> для доступа к элементам без возможности их изменения.\\n",
      "code_content": "class List<T> {  \n    private itemsMap: Map<string, T> = new Map();  \n    private readonly getItemKey: (item: T) => string;  \n  \n    constructor(params: { getItemKey: (item: T) => string }) {  \n        this.getItemKey = params.getItemKey;  \n    }  \n  \n    addItem(item: T): void {  \n        const key = this.getItemKey(item);  \n        if (!this.itemsMap.has(key)) {  \n            this.itemsMap.set(key, item);  \n        }  \n    }    removeItem(item: T): void {  \n        const key = this.getItemKey(item);  \n        this.itemsMap.delete(key);  \n    }  \n  \n    // Readonly access to items  \n    get items(): ReadonlyArray<T> {  \n        return Array.from(this.itemsMap.values());  \n    }  \n}  \n  \nconst list = new List<{  \n    firstName: string;  \n    lastName: string;  \n}>({  \n    getItemKey: (item) => item.firstName + item.lastName,  \n});  \n  \nlist.addItem({  \n    firstName: 'Иван',  \n    lastName: 'Петров',  \n});  \n  \nlist.addItem({  \n    firstName: 'Женя',  \n    lastName: 'Киселев',  \n});  \n  \nlist.addItem({  \n    firstName: 'Иван',  \n    lastName: 'Петров',  \n});  \n  \nlist.removeItem({  \n    firstName: 'Иван',  \n    lastName: 'Петров',  \n});  \n  \n// Cannot modify items directly  \n// list.items = []; // Error  \n// list.items.push({ firstName: 'Катя', lastName: 'Самойлова' }); // Error  \n  \nconsole.log(list.items);  \n// Output: [{ firstName: 'Женя', lastName: 'Киселев' }]",
      "code_language": "js",
      "code_lines": 47,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (47 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "classes",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "void",
        "items",
        "set",
        "get",
        "readonly",
        "additem",
        "constructor",
        "values",
        "key",
        "list",
        "readonlyarray",
        "array",
        "map",
        "delete",
        "params",
        "itemsmap",
        "item",
        "firstname",
        "getitemkey",
        "string",
        "private",
        "has",
        "from",
        "removeitem",
        "lastname"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 70,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu2i0023hxt8epssc7k4",
      "title": "7. class sock&box",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать систему сортировки носков по цвету:\\nSock — класс носка с цветом;Box — класс коробки, в которой хранятся носки;getSocksInfo — метод, возвращающий информацию о количестве пар и одинарных носках по цветам.\\n",
      "code_content": "\nclass Sock {  \n    color: string;  \n  \n    constructor(color: string) {  \n        this.color = color;  \n    }  \n}  \n  \nclass Box {  \n    private sortedSocks: Map<string, Sock[]> = new Map();  \n  \n    constructor(socks: Sock[] = []) {  \n        this.addSocks(socks);  \n    }  \n  \n    addSocks(socks: Sock[]) {  \n        for (const sock of socks) {  \n            this.addSock(sock);  \n        }  \n    }  \n    addSock(sock: Sock) {  \n        const color = sock.color;  \n        if (!this.sortedSocks.has(color)) {  \n            this.sortedSocks.set(color, []);  \n        }  \n        this.sortedSocks.get(color)?.push(sock);  \n    }  \n  \n    getSocksInfo() {  \n        const result: {  \n            color: string;  \n            pairs: number;  \n            singleSock: boolean;  \n        }[] = [];  \n  \n        // @ts-ignore  \n        for (const [color, socks] of this.sortedSocks.entries()) {  \n            const pairs = Math.floor(socks.length / 2);  \n            const singleSock = socks.length % 2 !== 0;  \n            result.push({ color, pairs, singleSock });  \n        }  \n  \n        return result;  \n    }  \n}\n\n\nconst box = new Box();\n\nbox.addSock(new Sock('red'));\nbox.addSock(new Sock('blue'));\nbox.addSock(new Sock('red'));\nbox.addSocks([new Sock('green'), new Sock('blue'), new Sock('blue')]);\n\nconsole.log(box.getSocksInfo());\n\n// Output:\n// [\n//   { color: 'red', pairs: 1, singleSock: false },\n//   { color: 'blue', pairs: 1, singleSock: true },\n//   { color: 'green', pairs: 0, singleSock: true }\n// ]",
      "code_language": "js",
      "code_lines": 50,
      "complexity_score": 6.0,
      "difficulty_factors": [
        "Средний код (50 строк)",
        "Средняя вложенность (4)",
        "Сложные концепции (1)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "addsocks",
        "addsock",
        "color",
        "sortedsocks",
        "get",
        "set",
        "boolean",
        "box",
        "socks",
        "constructor",
        "sock",
        "floor",
        "getsocksinfo",
        "map",
        "entries",
        "number",
        "nsock",
        "pairs",
        "singlesock",
        "string",
        "result",
        "math",
        "private",
        "has"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 80,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "exercise",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu3a0024hxt8kgth0xff",
      "title": "8. myMath",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача: Реализовать класс MyMath, который:\\nПоддерживает арифметические операции (add, subtract, multiply, divide);Позволяет вызывать методы цепочкой;Возвращает новый экземпляр объекта для каждой операции.\\n",
      "code_content": "\nclass MyMath {  \n    constructor(value = 0) {  \n        this.value = value;  \n    }  \n  \n    add(num) {  \n        return new MyMath(this.value + num);  \n    }  \n  \n    multiply(num) {  \n        return new MyMath(this.value * num);  \n    }  \n  \n    divide(num) {  \n        if (num === 0) {  \n            throw new Error('Cannot divide by zero!');  \n        }  \n        return new MyMath(this.value / num);  \n    }  \n  \n    subtract(num) {  \n        return new MyMath(this.value - num);  \n    }  \n  \n    result() {  \n        return this.value;  \n    }  \n}  \n  \n  \nconst calculation = new MyMath(10)  \n    .add(5)  \n    .multiply(2)  \n    .divide(3)  \n    .subtract(1)  \n    .result();  \n  \nconsole.log(calculation); // Output: 9",
      "code_language": "js",
      "code_lines": 30,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (30 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "classes",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "num",
        "throw",
        "divide",
        "value",
        "mymath",
        "error",
        "result",
        "calculation",
        "subtract",
        "add",
        "multiply",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 10,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxu410025hxt8ylv0xh71",
      "title": "9. tbq",
      "category": "JS",
      "subcategory": "Classes",
      "path_titles": [],
      "text_content": "Задача:\\nСоздать интерфейс Workable с методом doWork();Создать класс Worker, реализующий Workable;Создать класс User, который содержит экземпляр Workable и вызывает его doWork().\\n",
      "code_content": "interface Workable {\n  doWork(): void;\n}\n\nclass Worker implements Workable {\n  doWork(): void {\n    console.log('I am working');\n  }\n}\n\nclass User {\n  name: string;\n  age: number;\n  worker: Workable;\n\n  constructor(name: string, age: number, worker: Workable) {\n    this.name = name;\n    this.age = age;\n    this.worker = worker;\n  }\n\n  doWork(): void {\n    this.worker.doWork();\n  }\n}\n\n// Usage\nconst worker = new Worker();\nconst user = new User('Anton', 37, worker);\n\nuser.doWork(); // Output: 'I am working'",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "es6_classes",
        "constructor"
      ],
      "keywords": [
        "interface",
        "implements",
        "name",
        "dowork",
        "void",
        "number",
        "tbq",
        "worker",
        "workable",
        "string",
        "age",
        "user",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 42,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxul3002ahxt8xbqlc9h0",
      "title": "4. one (plus(two()))",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализуйте три функции: one, two и plus, чтобы они поддерживали перегрузку аргументов и работали как в выражениях one(plus(two())) и two(plus(one())), возвращая сумму чисел 1 и 2 (то есть 3).\\nЕсли функция one или two вызывается без аргумента, она возвращает соответствующее число (1 или 2).Если функция вызывается с функцией в качестве аргумента, она передаёт ей своё значение.Функция plus принимает число и возвращает функцию, которая прибавляет это число к своему аргументу.\\n",
      "code_content": "function one(arg) {  \n    if (arg) {  \n        return arg(1);  \n    } else {  \n        return 1;   \n    }  \n}  \n  \nfunction two(arg) {  \n    if (arg) {  \n        return arg(2);  \n    } else {  \n        return 2;  \n    }  \n}  \n  \nfunction plus(a) {  \n    return function (x) {  \n        return x + a;  \n    }  \n}  \n  \n// Примеры использования:\nconsole.log(one(plus(two()))); // Ожидается 3\nconsole.log(two(plus(one()))); // Ожидается 3",
      "code_language": "js",
      "code_lines": 22,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средний код (22 строк)"
      ],
      "programming_concepts": [
        "functions",
        "conditionals",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "arg",
        "one",
        "plus",
        "two"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 53,
      "target_skill_level": "beginner",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.69,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxulw002bhxt8d5lmmlb8",
      "title": "5. once",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи: Реализуйте функцию once, которая принимает другую функцию fn и возвращает новую функцию. Новая функция должна позволять вызов fn только один раз, а последующие вызовы должны возвращать undefined. Это полезно для создания функций, которые выполняются только единожды, независимо от того, сколько раз их вызовут.\\n",
      "code_content": "function once (fn) {  \n    let hasBeenCalled = false  \n    let result  \n    return (...args) => {  \n        if (!hasBeenCalled) {  \n            result = fn(...args)  \n            hasBeenCalled = true  \n            return result  \n        } else {  \n            return undefined  \n        }  \n    }}  \n  \n  \nlet fn = (a, b, c) => a + b + c   \nlet onceFn = once(fn)  \n  \n  \nconsole.log(onceFn(1,2,3))  \nconsole.log(onceFn(1,2,3))",
      "code_language": "js",
      "code_lines": 16,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "destructuring",
        "arrow_functions",
        "spread_operator"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "args",
        "result",
        "oncefn",
        "hasbeencalled",
        "once"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 43,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "exercise",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxumn002chxt8l6eazjvy",
      "title": "6. once - modification",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию once, которая принимает функцию (func) в качестве аргумента и возвращает новую функцию. Новая функция должна вызывать переданную функцию только один раз, сохраняя результат первого вызова, а при последующих вызовах возвращать этот же результат без повторного выполнения исходной функции. При этом следует корректно обрабатывать передачу контекста (this) и аргументов.\\n",
      "code_content": "function once (func) {\n    let hasBeenCalled = false\n    let result\n    return function (...args) {\n        if (!hasBeenCalled) {\n            result = func.call(this, ...args)\n            hasBeenCalled = true\n        }\n        return result\n    }\n}",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "destructuring",
        "spread_operator"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "modification",
        "args",
        "func",
        "result",
        "call",
        "hasbeencalled",
        "once"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.52,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxune002dhxt8aic7842d",
      "title": "7. compose&pipe",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте две функции: compose и pipe. Функция compose должна принимать массив функций и возвращать новую функцию, которая является композицией этих функций, применяемых справа налево. Функция pipe должна принимать массив функций и возвращать новую функцию, которая применяет их слева направо. Продемонстрируйте работу обеих функций на примере простых арифметических операций, таких как удвоение числа, возведение в квадрат и прибавление единицы.\n![[image_1.png]]\\n",
      "code_content": "const compose = functions => functions.reduceRight((acc, current) => x => current(acc(x)))  \n  \n  \nconst pipe = functions => x => functions.reduce((acc, current) => current(acc), x)  \n  \n  \nconst double = x => x * 2  \n  \nconst square = x => x * x  \n  \nconst addOne = x => x + 1  \n  \n  \nconst piped = pipe([addOne, square, double])  \n  \nconst composed = compose([addOne, square, double])  \n  \n  \nconsole.log(piped(3))  \n  \n  \nconsole.log(composed(3))",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "double",
        "square",
        "acc",
        "reduce",
        "addone",
        "compose",
        "pipe",
        "functions",
        "composed",
        "reduceright",
        "current",
        "piped",
        "png"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "example",
      "text_complexity": 0.61,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuo7002ehxt8wv0wa0s9",
      "title": "8. spy",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию spy, которая принимает функцию f и возвращает её обёртку (wrapper). Обёртка должна вызывать исходную функцию с переданными аргументами и возвращать её результат, а также сохранять информацию о каждом вызове — количество вызовов, массив аргументов каждого вызова и массив результатов — в специальном свойстве data. Продемонстрируйте работу spy, например, на функции, которая складывает два числа.\\n",
      "code_content": "\n  \nfunction _sum(a, b) {  \n    return a + b;  \n}  \n  \nfunction spy(f) {  \n    function wrapper(...args) {  \n        const result = f.apply(this, args);  \n        wrapper.data.calls++;  \n        wrapper.data.args.push(args);  \n        wrapper.data.results.push(result);  \n        return result;  \n    }  \n  \n    wrapper.data = {  \n        calls: 0,  \n        args: [],  \n        results: []  \n    };  \n  \n    return wrapper;  \n}  \n  \n  \nconst spiedSum = spy(_sum);  \n  \nconsole.log(spiedSum(2, 3)); // 5  \nconsole.log(spiedSum(5, 7)); // 12  \n  \nconsole.log(spiedSum.data);  \n// {  \n//     calls: 2,  \n//     args: [[2, 3], [5, 7]],  \n//     results: [5, 12]  \n// }\n",
      "code_language": "js",
      "code_lines": 27,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средний код (27 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "apply",
        "data",
        "result",
        "calls",
        "wrapper",
        "spiedsum",
        "args",
        "results",
        "spy"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 52,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "example",
      "text_complexity": 0.58,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvr3003ahxt8w8d6zyjw",
      "title": "8. isPrime",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию, которая проверяет, является ли число n простым. Простое число — это число, имеющее ровно два делителя: 1 и само себя. Решение должно быть представлено в трех вариантах:\\nПростая проверка делителей с использованием цикла.Оптимизированный вариант с проверкой делителей только до sqrt(n).Дальнейшая оптимизация, исключающая четные числа (кроме 2).\\n",
      "code_content": "\n// for  \nfunction isPrimeSimple(number) {  \n    if (number <= 1) return false;  \n  \n    for (let i = 2; i < number; i++) {  \n        if (number % i === 0) {  \n            return false;  \n        }  \n    }    return true;  \n}  \n  \n// sqrt  \nfunction isPrimeSqrt(number) {  \n    if (number <= 1) return false;  \n    if (number === 2) return true;  \n  \n    for (let i = 2; i <= Math.sqrt(number); i++) {  \n        if (number % i === 0) {  \n            return false;  \n        }  \n    }    return true;  \n}  \n  \n  \n// optimized sqrt  \nfunction isPrimeOptimized(number) {  \n    if (number <= 1) return false;  \n    if (number === 2) return true;   \nif (number % 2 === 0) return false;   \n    for (let i = 3; i <= Math.sqrt(number); i += 2) {  \n        if (number % i === 0) {  \n            return false;  \n        }  \n    }    return true;  \n}  \n  \n  \nconsole.log(isPrimeSimple(7));  \nconsole.log(isPrimeSimple(12));  \nconsole.log(isPrimeSimple(23));  \nconsole.log(isPrimeSimple(100));  \n  \nconsole.log(isPrimeSqrt(7));  \nconsole.log(isPrimeSqrt(12));  \nconsole.log(isPrimeSqrt(23));  \nconsole.log(isPrimeSqrt(100));  \n  \n  \nconsole.log(isPrimeOptimized(7));  console.log(isPrimeOptimized(12)); console.log(isPrimeOptimized(23));  console.log(isPrimeOptimized(100));\n\n",
      "code_language": "js",
      "code_lines": 39,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (39 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "number",
        "isprime",
        "sqrt",
        "isprimesimple",
        "math",
        "isprimesqrt",
        "isprimeoptimized"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 60,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "practice",
      "text_complexity": 0.98,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuov002fhxt8df139lwi",
      "title": "9. callLimit",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию callLimit, которая принимает три аргумента: функцию fn, лимит вызовов (limit) и опциональную callback-функцию. Возвращаемая функция должна выполнять следующие действия:\\nВызывать исходную функцию fn с переданными аргументами до тех пор, пока количество вызовов не достигнет лимита.После достижения лимита дальнейшие вызовы не должны вызывать fn и возвращать undefined.Если callback-функция передана, вызвать её один раз при достижении лимита.Обеспечить метод res...",
      "code_content": "\nfunction callLimit(fn, limit, callback) {  \n    let count = 0;  \n  \n    const resFunc = (...args) => {  \n        if (count < limit) {  \n            count++;  \n            if (count === limit) callback?.();  \n            return fn(...args);  \n        }  \n    };  \n  \n    // Метод для сброса счётчика вызовов  \n    resFunc.reset = () => count = 0;  \n  \n    return resFunc;  \n}  \n  \n  \nfunction log(title, message) {  \n    console.log(title + ': ' + message);  \n}  \n  \nvar logLimited = callLimit(log, 3);  \nlogLimited('title1', 'desc'); // Выведет: title1: desc  \nlogLimited('title2', 'desc'); // Выведет: title2: desc  \nlogLimited('title3', 'desc'); // Выведет: title3: desc  \nlogLimited('title4', 'desc'); // Ничего не выведет, т.к. лимит достигнут  \n  \nlogLimited.reset(); // Перезагрузка счётчика  \n  \nlogLimited('title5', 'desc'); // Выведет: title5: desc  \nlogLimited('title6', 'desc'); // Выведет: title6: desc  \nlogLimited('title7', 'desc'); // Выведет: title7: desc  \n  \nvar logLimited2 = callLimit(log, 2, () => console.log('finish'));  \nlogLimited2('foo', 'bar'); // Выведет: foo: bar  \nlogLimited2('foo2', 'bar'); // Выведет: foo2: bar и затем finish\n",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "title",
        "reset",
        "callback",
        "message",
        "count",
        "loglimited",
        "limit",
        "resfunc",
        "calllimit",
        "args"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 67,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.74,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxupk002ghxt8wr5jtnth",
      "title": "10. deepEqual",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию deepEqual, которая глубоко сравнивает два значения. Функция должна возвращать true, если оба значения идентичны по структуре и содержанию, и false — в противном случае. При этом необходимо:\\nЕсли значения равны по ссылке (оператор ===), вернуть true.Если один из аргументов не является объектом (или равен null), вернуть false.Для объектов и массивов сравнить их собственные свойства и элементы с использованием рекурсии.Учесть различие между массивами и объекта...",
      "code_content": "\nfunction deepEqual(a, b, visited = new Map()) {\n    if (a === b) return true;\n    \n    if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {\n        return false;\n    }\n    \n    // Проверка на ранее посещенные объекты для рекурсивных структур\n    if (visited.has(a)) return visited.get(a) === b;\n    visited.set(a, b);\n\n    // Проверка на тип массивов\n    if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n    const entriesA = Object.entries(a);\n    const entriesB = Object.entries(b);\n\n    if (entriesA.length !== entriesB.length) return false;\n\n    for (let [key, valueA] of entriesA) {\n        if (!(key in b) || !deepEqual(valueA, b[key], visited)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Примеры использования для проверки\n\nconsole.log(deepEqual({ a: 1, b: { c: 3 } }, { a: 1, b: { c: 3 } })); // true\nconsole.log(deepEqual([1, 2, 3], [1, 2, 3])); // true\nconsole.log(deepEqual([1, 2, 3], [1, 2, 4])); // false\nconsole.log(deepEqual({ a: 1 }, { a: 1, b: 2 })); // false\nconsole.log(deepEqual({ a: { b: { c: 1 } } }, { a: { b: { c: 1 } } })); // true\n\n// Тест на рекурсивные ссылки\nconst obj1 = {};\nconst obj2 = {};\nobj1.self = obj1;\nobj2.self = obj2;\nconsole.log(deepEqual(obj1, obj2)); // true\n\n",
      "code_language": "js",
      "code_lines": 32,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (32 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "regex",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "entriesb",
        "entriesa",
        "key",
        "self",
        "array",
        "visited",
        "map",
        "isarray",
        "get",
        "typeof",
        "has",
        "valuea",
        "set",
        "deepequal",
        "object",
        "entries"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 71,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "exercise",
      "text_complexity": 0.79,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuq9002hhxt8khog3l32",
      "title": "11. some",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте собственный метод массива some, который принимает функцию-предикат (fn) и возвращает true, если хотя бы один элемент массива удовлетворяет этому предикату, и false в противном случае. Функция должна перебрать все элементы массива и остановиться, как только предикат вернёт true для какого-либо элемента.\\n",
      "code_content": "\nArray.prototype.some = function(fn) {  \n  \n    for (let i = 0; i < this.length; i++) {  \n        if (fn(this[i])) {  \n            return true;  \n        }  \n    }    return false;  \n};  \n  \nconst numbers = [1, 2, 3, 4, 5];  \n  \nconst hasEven = numbers.some(num => num % 2 === 0);  \n  \nconsole.log(hasEven); // true  \n  \nconst hasGreaterThan10 = numbers.some(num => num > 10);  \n  \nconsole.log(hasGreaterThan10); // false\n",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_some"
      ],
      "keywords": [
        "num",
        "prototype",
        "array",
        "some",
        "haseven",
        "numbers"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 46,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 10,
      "pedagogical_type": "exercise",
      "text_complexity": 0.44,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxur0002ihxt8zeku9txm",
      "title": "12. map",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию map, которая принимает массив и функцию-преобразователь, применяет эту функцию ко всем элементам массива и возвращает новый массив с результатами преобразования. Задача должна быть решена различными способами:\\nС использованием цикла for.Как метод прототипа массива (Array.prototype.myMap).С использованием метода reduce.С использованием метода forEach.\\n",
      "code_content": "  \n// for  \n\n\nconst array = [1, 2, 3, 4, 5, 6, 7 , 8 , 9, 10]  \nconst sum = x => x * 2  \n  \nconst map = (arr, fn) => {  \n    const transformedArr = [];  \n    for (let index = 0; index < arr.length; index++) {  \n        transformedArr.push(fn(arr[index], index));  \n    }  \n    return transformedArr;  \n};  \n  \nconst test = map(array, sum)  \n  \nconsole.log(test)  \n  \n  \n// как метод массива  \n  \nArray.prototype.myMap = function(fn) {  \n  \n    const transformedArr = [];  \n  \n    for (let index = 0; index < this.length; index++) {  \n        transformedArr.push(fn(this[index], index));  \n  \n    }  \n    return transformedArr;  \n};  \n  \nconst result = array.myMap(sum);  \n  \nconsole.log(result); // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n\n// reduce    \nconst map1 = (arr, fn) => arr.reduce((acc, current, index) => {  \n    acc.push(fn(curr, idx));  \n    return acc;  \n}, []);  \n  \n  \n  \n// forEach  \nconst map3 = (arr, fn) => {  \n    const transformedArr = [];  \n    arr.forEach((element, index) => {  \n        transformedArr.push(fn(element, index));  \n    });  \n    return transformedArr;  \n};",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce",
        "array_forEach"
      ],
      "keywords": [
        "sum",
        "acc",
        "transformedarr",
        "reduce",
        "prototype",
        "mymap",
        "array",
        "idx",
        "map",
        "foreach",
        "result",
        "element",
        "arr",
        "curr",
        "test",
        "current",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 63,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 0.93,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwe2003chxt8rwypcfj0",
      "title": "1. sum",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Сумма значений в древовидной структуре\nДана древовидная структура, где каждый узел содержит числовое значение и массив потомков. Напишите функцию, которая рекурсивно вычисляет сумму всех значений в дереве.\\n",
      "code_content": "const tree1 = {  \n    value: 1,  \n    next: [  \n        {  \n            value: 3,  \n            next: [  \n                { value: 3, next: null },  \n                { value: 2, next: null }  \n            ]  \n        },  \n        { value: 2, next: null }  \n    ]  \n};  \n  \nfunction sum(tree) {  \n    let total = tree.value;  \n  \n    if (tree.next) {  \n        for (const node of tree.next) {  \n            total += sum(node);  \n        }  \n    }  \n    return total;  \n}\n  \n  \nconsole.log(sum(tree1));",
      "code_language": "js",
      "code_lines": 23,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (23 строк)",
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops"
      ],
      "js_features_used": [],
      "keywords": [
        "tree",
        "sum",
        "total",
        "next",
        "value",
        "node"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 51,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.27,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxurr002jhxt8q7700ftr",
      "title": "13. filter",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию filter, которая принимает массив и функцию-предикат (fn) и возвращает новый массив, содержащий только те элементы, для которых функция-предикат возвращает true. Решение необходимо реализовать различными способами:\\nС использованием цикла for.Как метод прототипа массива (например, Array.prototype.myFilter).С использованием метода forEach.\\n",
      "code_content": "\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  \nconst isEven = x => x % 2 === 0;  \n  \n  \n// for  \n  \nconst filter = (arr, fn) => {  \n    const newArray = []  \n  \n    for (let i = 0; i < arr.length; i++) {  \n        if (fn(arr[i])) {  \n            newArray.push(arr[i])  \n        }  \n    }    return newArray  \n}  \n  \nconst test = filter(arr, isEven)  \n  \nconsole.log(test)  \n\n// как метод \n\nArray.prototype.myFilter = function(fn) {  \n    const newArray = [];  \n  \n    for (let i = 0; i < this.length; i++) {  \n        if (fn(this[i])) {  \n            newArray.push(this[i]);  \n        }  \n    }  \n    return newArray;  \n};\n  \n// forEach  \n  \nconst filter2 = (arr, fn) => {  \n    const newArray = []  \n  \n    arr.forEach((element, index) => {  \n        if (fn(element)) {  \n            newArray.push(element)  \n        }  \n    })  \n    return newArray  \n}  \n  \nconst test2 = filter2(arr, isEven)  \n  \nconsole.log(test2)\n",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "myfilter",
        "filter",
        "prototype",
        "element",
        "array",
        "foreach",
        "arr",
        "newarray",
        "test",
        "iseven",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 66,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 12,
      "pedagogical_type": "example",
      "text_complexity": 0.9,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxusg002khxt8u0cts5iq",
      "title": "14. reduce",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию reduce, которая принимает массив, функцию-аккумулятор и начальное значение аккумулятора, а затем возвращает итоговое значение, полученное путем последовательного применения функции-аккумулятора ко всем элементам массива. Необходимо реализовать две версии:\\nС использованием цикла for.С использованием метода forEach.\nПродемонстрируйте работу обеих реализаций на примере, где функция-аккумулятор умножает каждый элемент массива на 2 и суммирует полученные значени...",
      "code_content": "\nconst array = [1, 2, 3, 4, 5]  \nconst power = (acc, x) => acc + x * 2;  \n  \n  \n// for  \n  \nconst reduce = (arr, fn, init = 0) => {  \n  \n    let acc = init  \n    for (let i = 0; i < arr.length; i++) {  \n        acc = fn(acc, arr[i])  \n    }  \n    return acc  \n}  \n  \n  \nconst test = reduce(array, power)  \n  \nconsole.log(test)  \n  \n  \n// forEach  \nconst reduce2 = (arr, fn, init = 0) => {  \n    let acc = init  \n  \n    arr.forEach((element, index) => {  \n        console.log(acc)  \n        acc = fn(acc, element)  \n    })  \n    return acc  \n}  \n  \n  \nconst test2 = reduce2(array, power)  \n  \nconsole.log(test2)\n",
      "code_language": "js",
      "code_lines": 23,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средний код (23 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "acc",
        "reduce",
        "element",
        "array",
        "foreach",
        "arr",
        "power",
        "test",
        "init",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 51,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 13,
      "pedagogical_type": "example",
      "text_complexity": 0.55,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxut7002lhxt8qmwr0xmj",
      "title": "15. dailyTemperatures",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию dailyTemperatures, которая принимает массив чисел, представляющих ежедневные температуры, и возвращает новый массив, где для каждого дня записано, через сколько дней наступит более высокая температура, чем в данный день. Если для какого-либо дня более высокая температура не наступит, в соответствующей позиции массива должно стоять 0.\\n",
      "code_content": "\nfunction dailyTemperatures(temperatures) {  \n    const length = temperatures.length  \n    const result = new Array(length).fill(0)  \n    const stack = []  \n  \n    for (let i = 0; i < temperatures.length; i++) {  \n  \n        while (stack.length > 0 && temperatures[i] > temperatures[stack[stack.length - 1]])  {  \n                const prevIndex = stack.pop()  \n                console.log(prevIndex)  \n                result[prevIndex] = i - prevIndex  \n        }  \n        stack.push(i)  \n    }  \n  \n    return result  \n}  \n  \n  \n// console.log(dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73])); // Ожидаемый вывод: [1, 1, 4, 2, 1, 1, 0, 0]  \n//  \n// console.log(dailyTemperatures([30, 40, 50, 60])); // Ожидаемый вывод: [1, 1, 1, 0]  \n  \n// console.log(dailyTemperatures([30, 60, 90])); // Ожидаемый вывод: [1, 1, 0]\n",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "dailytemperatures",
        "previndex",
        "array",
        "fill",
        "result",
        "stack",
        "temperatures"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 54,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 14,
      "pedagogical_type": "exercise",
      "text_complexity": 0.48,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxutz002mhxt8s89q83nw",
      "title": "16. bookingCalculate",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию bookingCalculate, которая принимает два параметра:\\nКоличество ночей бронирования (nights).Начальную дату бронирования (startDate), которая по умолчанию равна текущей дате.\\nФункция должна вычислять общую стоимость бронирования, где стоимость ночи зависит от дня недели:\\nБудние дни (понедельник – пятница): 1500.Выходные дни (суббота и воскресенье): 2200.\\nПри расчёте стоимости функция должна учитывать, что бронирование может начинаться в любой день недели, и...",
      "code_content": "\nfunction bookingCalculate(nights, startDate = new Date()) {  \n  \n    const costs = { weekday: 1500, weekend: 2200 };  \n    let totalCost = 0;  \n  \n    for (let i = 0; i < nights; i++) {  \n        const dayOfWeek = (startDate.getDay() + i) % 7;  \n        totalCost += (dayOfWeek === 0 || dayOfWeek === 6) ? costs.weekend : costs.weekday;  \n    }  \n  \n    return totalCost;  \n}  \n  \n  \n// console.log(bookingCalculate(7)); // Ожидаемый вывод: 11900 (если неделя начнётся с понедельника)  \n  \n// console.log(bookingCalculate(3, new Date('2023-11-10'))); // Ожидаемый вывод: 5900\n",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "weekend",
        "date",
        "totalcost",
        "costs",
        "nights",
        "dayofweek",
        "getday",
        "weekday",
        "startdate",
        "bookingcalculate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 15,
      "pedagogical_type": "exercise",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwn2003ohxt8r75wdyfw",
      "title": "13. getValues",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Получение значений по ключам\nРеализуйте функцию, которая принимает объект и список ключей (в виде строки, массива или нескольких аргументов) и возвращает строку, содержащую значения этих ключей, объединенные пробелами.\\n",
      "code_content": "\n\n  function getValues(obj, ...keys) {\n    // Если `keys` — одна строка, разбиваем её на массив; если это массив, используем его как есть\n    keys = typeof keys[0] === 'string' ? keys[0].split(' ') : keys.flat();\n\n    return keys.map(key => obj[key]).join(' ');\n}\n\nconst obj = {  \n    key1: 'value1',  \n    key2: 'value2',  \n    key3: 'value3',  \n};  \n\nconsole.log(getValues(obj, 'key1 key2 key3')); // \"value1 value2 value3\"\nconsole.log(getValues(obj, 'key1', 'key2', 'key3')); // \"value1 value2 value3\"\nconsole.log(getValues(obj, ['key1', 'key2', 'key3'])); // \"value1 value2 value3\"\n\n",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "objects",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_map"
      ],
      "keywords": [
        "keys",
        "key",
        "obj",
        "getvalues",
        "map",
        "flat",
        "typeof",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 12,
      "pedagogical_type": "exercise",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuuq002nhxt8rooy764b",
      "title": "17. reverse",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию convertToStrAndReverse, которая принимает один аргумент s и возвращает строку, полученную следующим образом:\\nЕсли s является строкой или массивом, преобразуйте его в массив символов, затем разверните (reverse) порядок элементов и объедините их обратно в строку.Если s не является строкой или массивом, функция должна вернуть пустую строку.\\nПримеры:\\nДля входа '123' функция должна вернуть '321'.Для входа [1, 2, 3] функция должна вернуть '321'.Для входа объект...",
      "code_content": "\n  \nfunction convertToStrAndReverse(s) {  \n  \n    const isConvertible = typeof s === 'string' || Array.isArray(s);  \n  \n    if (isConvertible) {  \n        return Array.from(s).reverse().join('');  \n    }  \n  \n    return '';  \n}  \n  \n  \n  \n  \nconsole.log(convertToStrAndReverse('123'));      // '321'  \n  \nconsole.log(convertToStrAndReverse([1, 2, 3]));  // '321'  \n  \nconsole.log(convertToStrAndReverse({ length: 5 })); // ''  \n  \nconsole.log(convertToStrAndReverse(123)); // ''\n",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "isconvertible",
        "reverse",
        "array",
        "isarray",
        "typeof",
        "from",
        "converttostrandreverse",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 45,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 16,
      "pedagogical_type": "example",
      "text_complexity": 0.75,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuvg002ohxt8ydqy5mni",
      "title": "18. basic throttling",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию throttle, которая принимает функцию (func) и интервал времени (wait) в миллисекундах, и возвращает новую функцию. Эта новая функция должна вызывать исходную функцию не чаще одного раза за указанный интервал. При последующих вызовах в течение интервала вызов функции игнорируется. Также продемонстрируйте работу throttle на примере функции, которая увеличивает счётчик. В демонстрации функция вызывается каждые 500 миллисекунд, но благодаря throttle фактические в...",
      "code_content": "function throttle(func, wait) {  \n    let inThrottle = false  \n    return function (...args) {  \n        if (!inThrottle) {  \n            func.apply(this, args)  \n            inThrottle = true  \n            setTimeout(() => inThrottle = false, wait)  \n        }  \n    }}  \n\n\n// Функция, которую будем тротлить  \nfunction logMessage(message) {  \n    console.log('Сообщение:', message, 'Time:', new Date().toLocaleTimeString());  \n}  \n\n\n// Пример функции, которую будем тротлить  \nlet counter = 0;  \nfunction logCounter() {  \n    counter++;  \n    console.log('Counter:', counter, 'Time:', new Date().toLocaleTimeString());  \n}  \n\n\n// Применяем throttle к logCounter с интервалом 2000 миллисекунд (2 секунды)  \nconst throttledLogCounter = throttle(logCounter, 2000);  \n\n\n// Вызываем throttledLogCounter каждые 500 миллисекунд  \nlet intervalId = setInterval(() => {  \n    throttledLogCounter();  \n}, 500);  \n\n\n// Останавливаем вызовы через 10 секунд  \nsetTimeout(() => {  \n    clearInterval(intervalId);  \n    console.log('Тест завершён.');  \n}, 10000);",
      "code_language": "js",
      "code_lines": 30,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (30 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "strings",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "intervalid",
        "throttling",
        "date",
        "basic",
        "counter",
        "wait",
        "logcounter",
        "throttle",
        "func",
        "apply",
        "inthrottle",
        "message",
        "throttledlogcounter",
        "setinterval",
        "args",
        "settimeout",
        "clearinterval",
        "tolocaletimestring",
        "logmessage"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 70,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 17,
      "pedagogical_type": "example",
      "text_complexity": 0.78,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuw8002phxt8zdhyaonc",
      "title": "19. debounce",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию debounce, которая принимает функцию (fn) и интервал времени (t, по умолчанию 1000 миллисекунд), и возвращает новую функцию, которая откладывает вызов fn до тех пор, пока не пройдёт t миллисекунд с момента последнего вызова. Если новая вызов происходит до истечения времени задержки, предыдущий таймер сбрасывается, и отсчет начинается заново. Это позволяет предотвратить частые вызовы функции, оптимизируя, например, обработку событий ввода.\\n",
      "code_content": "const debounce = (fn, t = 1000) => {  \n    let timer;  \n    return (...args) => {  \n        clearTimeout(timer);  \n        timer = setTimeout(() => fn(...args), t);  \n    }  \n};",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "spread_operator"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "timer",
        "debounce",
        "cleartimeout",
        "settimeout",
        "args"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 41,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 18,
      "pedagogical_type": "example",
      "text_complexity": 0.63,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuwz002qhxt8d1p114i6",
      "title": "20. sleep",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию sleep, которая возвращает Promise, разрешающийся через заданный интервал времени. Функцию нужно реализовать несколькими способами:\\nБазовая реализация с использованием Promise и setTimeout.Однострочная реализация в стиле стрелочных функций.Реализация с использованием async/await.\nТакже продемонстрируйте примеры использования этих реализаций, например, для логирования сообщений \"start\" и \"end\" с задержкой.\\n",
      "code_content": "// basic  \n  \nfunction sleepBasic(ms) {  \n    return new Promise(resolve => {  \n        setTimeout(resolve, ms)  \n    })  \n}\n  \n// one line with arrow style  \n  \nconst sleepArrow = (millis) => new Promise(resolve => setTimeout(resolve, millis));  \n  \n  \n// usage basic  \n  \nfunction examplePromise() {  \n    console.log('start')  \n    return sleep(5000).then(() => console.log('end'))  \n}  \n  \n// log  \n  \n// console.log(examplePromise())  \n// console.log(sleepArrow())  \n  \n  \n  \n// async/await  \n  \nasync function sleep(millis) {  \n    await new Promise(resolve => setTimeout(resolve, millis));  \n}  \n  \n  \n// usage async/await  \n  \n  \nasync function exampleAsync() {  \n    console.log('Start');  \n    await sleep(3000);  \n    console.log('End');  \n}  \n  \n  \n// log  \n  \n// console.log(exampleAsync())",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await",
        "promises"
      ],
      "keywords": [
        "resolve",
        "promise",
        "millis",
        "sleepbasic",
        "await",
        "settimeout",
        "exampleasync",
        "async",
        "then",
        "examplepromise",
        "sleeparrow",
        "sleep"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 58,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 19,
      "pedagogical_type": "example",
      "text_complexity": 0.47,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv0u002vhxt8eoifk8pr",
      "title": "Банкомат Райфайзена",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [
        "Банкоматы"
      ],
      "text_content": "",
      "code_content": "\n  \n// Необходимо написать функцию для банкомата, которая возвращает массив возможных номиналов купюр для выдачи по запросу пользователя.  \n// 1. Номиналы должны выдаваться максимально крупные с минимально возможным количеством выданных купюр.  \n// 2. Если выдать нужную сумму невозможно, функция должна выводить ошибку через стандартный механизм ошибок.  \n  \n// Формат вывода: массив строк от большего номинала к меньшему, например `[\"5000x1\", \"1000x3\"]`.  \n  \n// Дополнительно: вводится ограничение на количество купюр в банкомате.  \n  \n// Пример номиналов:  \n  \nconst nominals = [10, 50, 100, 200, 500, 1000, 2000, 5000];  \n  \nconst limits = {10:10,50:10,100:10,200:10,500:10,1000:10,2000:10,5000:10};  \n  \n  \nfunction atmGiveMoney(amount, nominals, limits) {  \n    const minNominal = Math.min(...nominals);  \n    if (amount % minNominal !== 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    const sorted = [...nominals].sort((a, b) => b - a);  \n    let remaining = amount;  \n    const result = [];  \n  \n    for (const nominal of sorted) {  \n        if (remaining <= 0) break;  \n        const needed = Math.floor(remaining / nominal);  \n        if (needed > 0) {  \n            const available = limits[nominal] || 0;  \n            const take = Math.min(needed, available);  \n            if (take > 0) {  \n                remaining -= take * nominal;  \n                limits[nominal] = available - take; // обновляем лимит  \n                result.push(`${nominal}x${take}`);  \n            }  \n        }    }  \n    if (remaining > 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    return result;  \n}  \n  \n  \nconsole.log(atmGiveMoney(18500, nominals, limits))   \n// [ '5000x3', '2000x1', '1000x1', '500x1' ]  \n  \nconsole.log(atmGiveMoney(8750, nominals, limits));  \n  \n// [ '5000x1', '2000x1', '1000x1', '500x1', '200x1', '50x1' ]  \n  \nconsole.log(atmGiveMoney(10000, nominals, limits));  \n  \n// [ '5000x2' ]  \n  \nconsole.log(atmGiveMoney(150, nominals, limits));  \n  \n// [ '100x1', '50x1' ]  \n  \n  \nconst customLimits = { 10: 20, 50: 15, 100: 20, 200: 5, 500: 3, 1000: 5, 2000: 2, 5000: 1 };  \n  \nconsole.log(atmGiveMoney(13500, nominals, customLimits));  \n  \n// Ожидаемый вывод: [ '5000x1', '2000x2', '1000x3', '500x1' ]\n",
      "code_language": "js",
      "code_lines": 44,
      "complexity_score": 5.5,
      "difficulty_factors": [
        "Средний код (44 строк)",
        "Глубокая вложенность (5)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "sorting",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals"
      ],
      "keywords": [
        "customlimits",
        "amount",
        "remaining",
        "limits",
        "break",
        "atmgivemoney",
        "nominal",
        "take",
        "available",
        "floor",
        "error",
        "sorted",
        "needed",
        "nominals",
        "sort",
        "throw",
        "result",
        "math",
        "min",
        "minnominal"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 57,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 24,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuxs002rhxt8ny7coxj8",
      "title": "21. throttling с сохранием аргументов и this",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию throttle, которая принимает функцию (func) и интервал времени (wait) в миллисекундах, и возвращает новую функцию. Новая функция должна вызывать исходную функцию не чаще одного раза за указанный интервал. При вызове, если функция уже находится в состоянии ожидания, последующие вызовы должны сохранять последние переданные аргументы, и когда интервал истечет, функция должна быть вызвана с сохраненными аргументами, а затем цикл повторяется. Также необходимо прод...",
      "code_content": "function throttle(func, wait) {  \n    let waiting = false, lastArgs = null;  \n  \n    return function(...args){  \n        console.log('throttle: функция вызвана.');  \n  \n        if (!waiting) {  \n            func.apply(this, args);  \n            console.log('throttle: вызвали func немедленно.');  \n            waiting = true;  \n  \n            let timeout = () => {  \n                setTimeout(() => {  \n                    waiting = false;  \n                    console.log('throttle: таймер истёк, waiting = false.');  \n                    if(lastArgs){  \n                        func.apply(this, lastArgs);  \n                        console.log('throttle: вызвали func с lastArgs.');  \n                        lastArgs = null;  \n                        waiting = true;  \n                        timeout();  \n                    }  \n                }, wait);  \n            };  \n  \n            timeout();  \n        } else {  \n            lastArgs = args;  \n            console.log('throttle: функция в ожидании, сохранили аргументы в lastArgs.');  \n        }  \n    }}  \n  \n  \n// Функция, которую будем тротлить  \nlet counter = 0;  \nfunction testFunc() {  \n    counter++;  \n    console.log('>>> testFunc выполнена. Counter:', counter, 'Time:', new Date().toLocaleTimeString());  \n}  \n  \n// Применяем throttle к testFunc с интервалом 2000 миллисекунд (2 секунды)  \nlet throttledTestFunc = throttle(testFunc, 2000);  \n  \n// Вызываем throttledTestFunc каждые 500 миллисекунд  \nlet intervalId = setInterval(() => {  \n    throttledTestFunc();  \n}, 500);  \n  \n// Останавливаем вызовы через 10 секунд  \nsetTimeout(() => {  \n    clearInterval(intervalId);  \n    console.log('Тест завершён.');  \n}, 10000);",
      "code_language": "js",
      "code_lines": 44,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (44 строк)",
        "Глубокая вложенность (6)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "strings",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "intervalid",
        "throttling",
        "date",
        "counter",
        "nhttps",
        "wait",
        "waiting",
        "throttle",
        "func",
        "lastargs",
        "apply",
        "throttledtestfunc",
        "setinterval",
        "args",
        "settimeout",
        "testfunc",
        "clearinterval",
        "tolocaletimestring",
        "timeout"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 92,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 20,
      "pedagogical_type": "example",
      "text_complexity": 0.94,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuyj002shxt8u66jvno7",
      "title": "22. memo",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию memoize, которая принимает функцию fn и возвращает её мемоизированную версию. Мемоизированная функция должна кэшировать результаты вызовов fn для каждого уникального набора аргументов (используя, например, JSON.stringify для формирования ключа), чтобы при повторном вызове с теми же аргументами не вычислять результат заново, а возвращать значение из кэша. Дополнительно, при каждом вызове выводите в консоль сообщение о том, что результат вычислен или получен и...",
      "code_content": "function memoize(fn) {  \n    const cache = new Map()  \n  \n    return function(...args) {  \n        const key = JSON.stringify(args)  \n        if (cache.has(key)) {  \n            const result = cache.get(key)  \n            console.log(`Вычислено из кэша : ${result}`)  \n            return cache.get(key);  \n        }  \n        const result = fn(...args)  \n        cache.set(key, result)  \n        console.log(`Вычислено: ${result}`);  \n        return result  \n    }  \n}  \n  \nlet callCount = 0;  \n  \nconst memoizedFn2 = memo((a, b) => {  \n    callCount += 1   \nreturn a + b   \n})  \n  \n  \nconsole.log(memoizedFn2(2, 3));  \nconsole.log(memoizedFn2(2, 3));  \nconsole.log(memoizedFn2(2, 3));  \n  \nconsole.log(callCount)",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals"
      ],
      "keywords": [
        "stringify",
        "cache",
        "key",
        "memoize",
        "map",
        "json",
        "result",
        "has",
        "get",
        "set",
        "callcount",
        "args",
        "memo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 67,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 21,
      "pedagogical_type": "example",
      "text_complexity": 0.75,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxuza002thxt89mb63y9k",
      "title": "23. memo2",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию memo, которая принимает функцию fn и возвращает её мемоизированную версию, способную кэшировать результаты вызова fn для каждого уникального набора аргументов и для каждого контекста (this). Для хранения кэша используйте WeakMap, чтобы обеспечить корректную обработку методов объектов. При вызове возвращаемой функции, если результат для данного контекста и набора аргументов уже был вычислен, функция должна вернуть значение из кэша, иначе вычислить результат, ...",
      "code_content": "\nconst memo = (fn) => {  \n    const cache = new WeakMap();  \n  \n    return function(...args) {  \n        const context = this;  \n        // Если контекст объекта отсутствует в кэше, создаем для него новый `Map`  \n        if (!cache.has(context)) {  \n            cache.set(context, new Map());  \n        }  \n  \n        const map = cache.get(context);  \n        const key = JSON.stringify(args);  \n  \n        // Проверка на наличие результата в кэше  \n        if (map.has(key)) {  \n            return map.get(key);  \n        }  \n  \n        // Вычисление и кэширование результата  \n        const result = fn.apply(context, args);  \n        map.set(key, result);  \n        return result;  \n    };  \n};  \n  \nlet callCount = 0;  \n  \nconst obj = {  \n    x: 2,  \n    y: 3,  \n    sum(a, b) {  \n        callCount += 1;  \n        return a + b + this.x + this.y;  \n    }  \n};  \n  \n// Мемоизация метода объекта  \nobj.memoizedSum = memo(obj.sum);  \n  \nconsole.log(obj.memoizedSum(1, 2)); // Первый вызов: вычисляет и возвращает 8 (1 + 2 + 2 + 3)  \nconsole.log(obj.memoizedSum(1, 2)); // Второй вызов: возвращает 8 из кэша  \nconsole.log(obj.memoizedSum(2, 3)); // Третий вызов: вычисляет и возвращает 10 (2 + 3 + 2 + 3)  \n  \nconsole.log(callCount); // Выводит 2, потому что вычисления выполнялись только для новых аргументов\n",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "apply",
        "sum",
        "stringify",
        "cache",
        "key",
        "obj",
        "context",
        "weakmap",
        "map",
        "json",
        "result",
        "memoizedsum",
        "has",
        "get",
        "set",
        "callcount",
        "args",
        "memo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 72,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 22,
      "pedagogical_type": "exercise",
      "text_complexity": 0.7,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv02002uhxt8d791nlzh",
      "title": "24. memo3",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "Постановка задачи:\nРеализуйте функцию cachedFn, которая принимает функцию (fn) и возвращает её мемоизированную версию. При вызове возвращаемой функции для аргумента a, если результат для данного a уже сохранён в кэше, функция должна вернуть результат из кэша (с сообщением об этом в консоли); в противном случае — вычислить результат с помощью fn, сохранить его в кэше и вернуть результат. Продемонстрируйте работу функции на примере квадрирования числа.\\n",
      "code_content": "function squaring(a) {\n  return a ** 2;\n}\n\nfunction cachedFn(fn) {\n  const cache = new Map(); \n\n  return function (a) {\n    if (cache.has(a)) {\n      console.log(`${cache.get(a)} from cache`); \n      return cache.get(a);\n    }\n    const result = fn(a);\n    cache.set(a, result); \n    console.log(result); \n    return result;\n  };\n}\n\nconst memoizedSquaring = cachedFn(squaring);\n\nmemoizedSquaring(3); // 9\nmemoizedSquaring(3); // 9 from cache\nmemoizedSquaring(5); // 25\nmemoizedSquaring(5); // 25 from cache\nmemoizedSquaring(3); // 9 from cache\n",
      "code_language": "js",
      "code_lines": 22,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (22 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "template_literals",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "cache",
        "memoizedsquaring",
        "squaring",
        "map",
        "result",
        "has",
        "get",
        "from",
        "set",
        "cachedfn"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 59,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 23,
      "pedagogical_type": "example",
      "text_complexity": 0.65,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy0xa0060hxt8gj17myut",
      "title": "useID",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "1. СберБанк"
      ],
      "text_content": "",
      "code_content": "const createNewItem = (itemData: Omit<Item, 'id'>): Item => {\n  const id = Math.floor(Math.random() * 1000);\n  return { ...itemData, id };\n};",
      "code_language": "js",
      "code_lines": 4,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "spread_operator"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator"
      ],
      "keywords": [
        "item",
        "omit",
        "random",
        "floor",
        "createnewitem",
        "math",
        "useid",
        "itemdata"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 17,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 10,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy0y00061hxt8t6b6zbyr",
      "title": "State",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "1. СберБанк"
      ],
      "text_content": "",
      "code_content": "setState((prev) => prev + 1);",
      "code_language": "js",
      "code_lines": 1,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "state",
        "prev",
        "setstate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 16,
      "target_skill_level": "beginner",
      "path_depth": 2,
      "order_in_file": 11,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv1n002whxt8sxl78206",
      "title": "1",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [
        "Банкоматы",
        "Банкомат в трех частях"
      ],
      "text_content": "",
      "code_content": "\nconst nominals = [10, 50, 100, 200, 500, 1000, 2000, 5000];  \n  \nfunction atm(sum, nominals) {  \n    const minNominal = Math.min(...nominals);  \n    if (sum % minNominal !== 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    const sorted = [...nominals].sort((a, b) => b - a);  \n    let remaining = sum;  \n    const parts = [];  \n  \n    for (const n of sorted) {  \n        const count = Math.floor(remaining / n);  \n        if (count > 0) {  \n            remaining -= count * n;  \n            parts.push(`${n}x${count}`);  \n        }  \n        if (remaining === 0) break;  \n    }  \n  \n    if (remaining > 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    return parts.join(\", \");  \n}  \n  \nconsole.log(atm(55400, nominals));  \n  \n// '5000x11, 2000x2'  \n  \nconsole.log(atm(8750, nominals));  \n  \n// '5000x1, 2000x1, 1000x1, 500x1, 200x1, 50x1'  \n  \nconsole.log(atm(13500, nominals));  \n  \n// '5000x2, 2000x1, 1000x3, 500x1'\n\n",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Средняя вложенность (4)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "sorting",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals"
      ],
      "keywords": [
        "sum",
        "break",
        "throw",
        "floor",
        "atm",
        "count",
        "error",
        "sorted",
        "sort",
        "math",
        "remaining",
        "nominals",
        "min",
        "parts",
        "minnominal",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 42,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 25,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv2d002xhxt8vf2kulif",
      "title": "2",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [
        "Банкоматы",
        "Банкомат в трех частях"
      ],
      "text_content": "",
      "code_content": "\n// Модифицировать функцию `atm`, чтобы она поддерживала несколько валют. // Каждая валюта имеет свой набор номиналов. // Функция должна принимать в качестве аргументов сумму и код валюты.  \n  \n  \nconst currencyNominals = {  \n    rub: [50, 100, 200, 500, 1000, 2000, 5000],  \n    uah: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000],  \n    eur: [5, 10, 20, 50, 100, 200, 500]  \n};  \n  \nfunction atmWithCurrency(sum, currency) {  \n    const nominals = currencyNominals[currency.toLowerCase()];  \n    if (!nominals) return \"Invalid currency\";  \n  \n    const minNominal = Math.min(...nominals);  \n    if (sum % minNominal !== 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    const sorted = [...nominals].sort((a,b) => b - a);  \n    let remaining = sum;  \n    const parts = [];  \n  \n    for (const n of sorted) {  \n        const count = Math.floor(remaining / n);  \n        if (count > 0) {  \n            remaining -= count * n;  \n            parts.push(`${n}x${count}`);  \n        }  \n        if (remaining === 0) break;  \n    }  \n  \n    if (remaining > 0) {  \n        throw new Error(\"Невозможно выдать данную сумму\");  \n    }  \n  \n    return parts.join(\", \");  \n}  \n  \nconsole.log(atmWithCurrency(14350, 'eur'));  \n  \n// Ожидаемый вывод: '500x28, 100x3, 50x1'  \n  \nconsole.log(atmWithCurrency(7550, 'rub'));  \n  \n// Ожидаемый вывод: '5000x1, 2000x1, 500x1, 50x1'  \n  \nconsole.log(atmWithCurrency(1000, 'usd'));  \n  \n// Ожидаемый вывод: \"Invalid currency\"\n\n",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Средняя вложенность (4)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "sorting",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals"
      ],
      "keywords": [
        "sum",
        "uah",
        "rub",
        "remaining",
        "join",
        "break",
        "currency",
        "tolowercase",
        "eur",
        "floor",
        "count",
        "error",
        "sorted",
        "nominals",
        "sort",
        "atmwithcurrency",
        "throw",
        "currencynominals",
        "math",
        "min",
        "parts",
        "minnominal"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 47,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 26,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv43002zhxt8rlqm3i8g",
      "title": "Simplify path",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [
        "ВК  canonizePath в трех частях"
      ],
      "text_content": "",
      "code_content": "\nexport const fs = [  \n  \n    '/dir/subdir/../file.txt',  \n    '/dir/subdir/a/b/c/d/file.txt',  \n    '/dir//file.txt',  \n    '/dir////file.txt',  \n    '/dir/',  \n    '/dir/..',  \n    '/',  \n    '/dir/./././././file.txt',  \n    '/dir/subdir/../../../file.txt',  \n    '/dir/subdir/../../../subdir/../file.txt',  \n    '/dir1',  \n    '/dir2/subdir1/file1.txt',  \n    '/dir2/subdir1/file2.txt',  \n    '/dir3/subdir1/file2.txt',  \n    '/dir3/subdir2',  \n    '/dir3/subdir2/file3.txt',  \n];  \n  \n// Реализовать функцию`canonizePath`, которая переделывает путь, нормализуя его следующим образом:  \n  \n// - Схлопывает все последовательные слеши (`///`превращаются в один`/`).  \n// - Удаляет`..`, поднимаясь на уровень выше в иерархии путей.  \n// - Игнорирует все`.` как ссылки на текущую директорию  \n  \n  \n  \nfunction simplifyPath(path) {  \n    const stack = [];  \n  \n    for (const part of path.split('/')) {  \n        if (part === '..') {  \n            if (stack.length > 0) {  \n                stack.pop();  \n            }  \n        } else if (part && part !== '.') {  \n            stack.push(part);  \n        }  \n    }    return '/' + stack.join('/');  \n}  \n  \nconsole.log(simplifyPath(\"/home/\")); // \"/home\"  \n  \nconsole.log(simplifyPath(\"/home//foo/\")); // \"/home/foo\"  \n  \nconsole.log(simplifyPath(\"/home/user/Documents/../Pictures\")); // \"/home/user/Pictures\"  \n  \nconsole.log(simplifyPath(\"/../\")); // \"/\"  \n  \nconsole.log(simplifyPath(\"/.../a/../b/c/../d/./\")); // \"/.../b/d\"  \n  \n  \nfs.forEach(path => {  \n    console.log(`Original: ${path} -> Simplified: ${simplifyPath(path)}`);  \n});\n",
      "code_language": "js",
      "code_lines": 42,
      "complexity_score": 5.0,
      "difficulty_factors": [
        "Средний код (42 строк)",
        "Средняя вложенность (4)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "modules",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "dom",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals",
        "array_forEach"
      ],
      "keywords": [
        "documents",
        "path",
        "export",
        "part",
        "simplifypath",
        "pictures",
        "foreach",
        "original",
        "simplified",
        "simplify",
        "user",
        "stack",
        "dir",
        "home",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 54,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 28,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv4u0030hxt8z9gmuesj",
      "title": "printfiles",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "",
      "code_content": "\nfunction printFiles(data, depth = 0) {\n    const prefix = ' '.repeat(depth * 4); // Создаем отступ, соответствующий уровню вложенности\n    console.log(`${prefix}${data.name}`);\n\n    // Если у узла есть дочерние элементы, рекурсивно обрабатываем их, увеличивая глубину\n    if (data.children) {\n        data.children.forEach(child => printFiles(child, depth + 1));\n    }\n}\n\n// Тестовые данные\nconst data = {\n    name: 'folder',\n    children: [\n        { name: 'file1.txt' },\n        { name: 'file2.txt' },\n        {\n            name: 'images',\n            children: [\n                { name: 'image.png' },\n                {\n                    name: 'vacation',\n                    children: [\n                        { name: 'crocodile.png' },\n                        { name: 'penguin.png' }\n                    ]\n                }\n            ]\n        },\n        { name: 'shopping-list.pdf' }\n    ]\n};\n\n// Запуск функции для вывода структуры файловой системы\nprintFiles(data);\n\n",
      "code_language": "js",
      "code_lines": 32,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (32 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrow_functions",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "template_literals",
        "array_forEach"
      ],
      "keywords": [
        "children",
        "printfiles",
        "name",
        "data",
        "repeat",
        "foreach",
        "prefix",
        "child",
        "depth"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 38,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 29,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxv5k0031hxt8h713wjbt",
      "title": "execution",
      "category": "JS",
      "subcategory": "Custom method and function",
      "path_titles": [],
      "text_content": "",
      "code_content": "\n  \n/// обеспечить порядок вывода a => b => c  \n  \nfunction foo(callback) {  \n   return new Promise((resolve, reject) => {  \n    setTimeout(function() {  \n       resolve(callback('A'))  \n    }, Math.random() * 100);  \n   })  \n}  \n  \nfunction bar(callback) {  \n    return new Promise((resolve, reject) => {  \n        setTimeout(function() {  \n            resolve(callback('B'))  \n        }, Math.random() * 100);  \n    })  \n}  \n  \nfunction baz(callback) {  \n    return new Promise((resolve, reject) => {  \n        setTimeout(function() {  \n            resolve(callback('C'))  \n        }, Math.random() * 100);  \n    })  \n}  \n  \nconst execution = async () => {  \n    try {  \n        await foo()  \n        await bar()  \n        await baz()  \n    } catch (error) {  \n        console.log(error.message)  \n    }  \n}\n",
      "code_language": "js",
      "code_lines": 31,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (31 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await",
        "promises"
      ],
      "keywords": [
        "resolve",
        "bar",
        "random",
        "baz",
        "await",
        "callback",
        "message",
        "settimeout",
        "catch",
        "reject",
        "error",
        "async",
        "math",
        "execution",
        "foo",
        "try",
        "promise"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 42,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 30,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvqc0039hxt8u37on9me",
      "title": "7. sumOfNumber",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию, которая принимает целое число и возвращает сумму его цифр. Отрицательные числа должны обрабатываться как положительные. Например, 123 превращается в 6, а -987 в 24.\\n",
      "code_content": "\n\nfunction sumOfNumber(num) {  \n    return Math.abs(num)  \n        .toString()  \n        .split('')  \n        .reduce((sum, digit) => sum + parseInt(digit, 10), 0);  \n}  \n  \n  \n  \nconsole.log(sumOfNumber(32));       // Output: 5 (3 + 2)  \n  \nconsole.log(sumOfNumber(-123));     // Output: 6 (1 + 2 + 3)  \n  \nconsole.log(sumOfNumber(0));        // Output: 0  \n  \nconsole.log(sumOfNumber(10001));    // Output: 2 (1 + 0 + 0 + 0 + 1)\n",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "strings",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "sum",
        "abs",
        "num",
        "digit",
        "reduce",
        "sumofnumber",
        "tostring",
        "parseint",
        "math",
        "split"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 30,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "example",
      "text_complexity": 0.27,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvlt0033hxt8orquj5qz",
      "title": "1. Факториал",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию для вычисления факториала числа n. Факториал определяется как произведение всех целых чисел от 1 до n, а факториал 0 равен 1. Решение должно быть представлено в трех вариантах:\\nИтеративный способ с использованием цикла.Рекурсивный способ.Использование метода reduce для функционального подхода.\\n",
      "code_content": "\n// for  \nfunction factorialIterative(n) {  \n    if (n < 0) return null;   \nlet result = 1;  \n  \n    for (let i = 2; i <= n; i++) {  \n        result *= i;  \n    }  \n  \n    return result;  \n}  \n\n\n// recursive  \nfunction factorialRecursive(n) {  \n    if (n < 0) return null;  \n    if (n === 0 || n === 1) return 1;   \nreturn n * factorialRecursive(n - 1);  \n}  \n  \n  \n  \n// reduce  \nfunction factorialReduce(n) {  \n    if (n < 0) return null;   \nif (n === 0 || n === 1) return 1;  \n  \n    return Array.from({ length: n }, (_, i) => i + 1)  \n        .reduce((acc, num) => acc * num, 1);  \n}  \n\nconsole.log(factorialIterative(5)); console.log(factorialIterative(0));  \nconsole.log(factorialIterative(1));  \nconsole.log(factorialIterative(-5));   \n\n  \nconsole.log(factorialRecursive(5));  \nconsole.log(factorialRecursive(0));  \nconsole.log(factorialRecursive(1));  \nconsole.log(factorialRecursive(-5));  \n  \n\n\nconsole.log(factorialReduce(5));  \nconsole.log(factorialReduce(0));  \nconsole.log(factorialReduce(1)); console.log(factorialReduce(-5));\n\n",
      "code_language": "js",
      "code_lines": 32,
      "complexity_score": 6.0,
      "difficulty_factors": [
        "Средний код (32 строк)",
        "Сложные концепции (1)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "destructuring",
        "arrow_functions",
        "recursion",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "factorialiterative",
        "num",
        "acc",
        "reduce",
        "array",
        "result",
        "factorialreduce",
        "from",
        "factorialrecursive"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 71,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "practice",
      "text_complexity": 0.41,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvmj0034hxt8pgunvy4a",
      "title": "2. fibonacci",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию для вычисления n-го числа Фибоначчи. Числа Фибоначчи определяются как последовательность, где каждое число равно сумме двух предыдущих:\\nF(1) = 1, F(2) = 1F(n) = F(n-1) + F(n-2)\\nРешение должно быть представлено в трех вариантах:\\nРекурсивный способ.Итеративный способ с оптимизированным использованием памяти.Рекурсивный способ с мемоизацией для увеличения производительности.\\n",
      "code_content": "  \nfunction fibonacciRecursive(n) {  \n  \n   if (n <= 2) return 1  \n\n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)  \n}   \nconsole.log(fibonacciRecursive(6)); // 8  \nconsole.log(fibonacciRecursive(10)); // 55  \nconsole.log(fibonacciRecursive(15)); // 610\n",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Сложные концепции (1)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "functions",
        "conditionals",
        "recursion",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "fibonaccirecursive",
        "fibonacci"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 49,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "practice",
      "text_complexity": 0.47,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvnb0035hxt8vys5zdse",
      "title": "3. largestPossibleNumber",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Дано целое число n. Требуется переставить его цифры так, чтобы получить наибольшее возможное число.\\n",
      "code_content": "\nfunction largestPossibleNumber(n) {  \n    return +n.toString()  \n        .split('')  \n        .sort((a, b) => b - a)  \n        .join('');  \n} \n  \n  \n  \nconsole.log(largestPossibleNumber(0) === 0);            // true  \n  \nconsole.log(largestPossibleNumber(1) === 1);            // true  \n  \nconsole.log(largestPossibleNumber(111) === 111);        // true  \n  \nconsole.log(largestPossibleNumber(15) === 51);          // true  \n  \nconsole.log(largestPossibleNumber(1021) === 2110);      // true  \n  \nconsole.log(largestPossibleNumber(123456789) === 987654321); // true\n",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "functions",
        "strings",
        "arrow_functions",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "join",
        "tostring",
        "largestpossiblenumber",
        "split",
        "sort"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "practice",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvo00036hxt8hdoh0aib",
      "title": "4. reverseNumber",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию, которая принимает целое число и возвращает его развернутый вариант, сохраняя знак (+ или -). Например, 123 превращается в 321, а -456 в -654.\\n",
      "code_content": "\nconst reverseNumber = (number) => {\n    const reversed = +Math.abs(number).toString().split('').reverse().join('');\n    return number < 0 ? -reversed : reversed;\n};\n\n  \n  \n  \nconsole.log(reverseNumber(24));         // Output: 42  \n  \nconsole.log(reverseNumber(-123));       // Output: -321  \n  \nconsole.log(reverseNumber(120));        // Output: 21  \n  \nconsole.log(reverseNumber(0));          // Output: 0\n",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "strings",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "abs",
        "reverse",
        "number",
        "tostring",
        "reversed",
        "math",
        "reversenumber",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "example",
      "text_complexity": 0.26,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvou0037hxt8lxnj0pjo",
      "title": "5. sumRangeFor",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию для нахождения суммы всех чисел в заданном диапазоне [start, end]. Решение должно быть представлено в трех вариантах:\\nИтеративный способ с использованием цикла.Рекурсивный способ.Вычисление по формуле суммы арифметической прогрессии.\\n",
      "code_content": "\nfunction sumRangeFor(start, end) {  \n    let sum = 0;  \n    for (let i = start; i <= end; i++) {  \n        sum += i;  \n    }  \n    return sum;  \n}  \n  \n  \n  \nfunction sumRangeRecursive(start, end) {  \n    if (start > end) return 0;  \n    return start + sumRangeRecursive(start + 1, end);  \n}  \n  \n  \n  \nfunction sumRangeFormula(start, end) {  \n    const n = end - start + 1;  \n    return (n * (start + end)) / 2;  \n}  \n  \n  \n  \nconsole.log(sumRangeFor(1, 5));  \nconsole.log(sumRangeFor(0, 10));  \nconsole.log(sumRangeFor(-3, 3));  \n  \n  \nconsole.log(sumRangeFormula(1, 5));  \nconsole.log(sumRangeFormula(0, 10));  \nconsole.log(sumRangeFormula(-3, 3));  \n  \nconsole.log(sumRangeRecursive(1, 5));  \nconsole.log(sumRangeRecursive(0, 10));  \nconsole.log(sumRangeRecursive(-3, 3));\n\n",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 5.5,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Сложные концепции (1)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "recursion"
      ],
      "js_features_used": [],
      "keywords": [
        "sum",
        "start",
        "sumrangeformula",
        "sumrangefor",
        "end",
        "sumrangerecursive"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 57,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "practice",
      "text_complexity": 0.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxvpm0038hxt8di4dikfj",
      "title": "6. fizzBuzz",
      "category": "JS",
      "subcategory": "Numbers",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализовать функцию, которая принимает массив чисел и возвращает новый массив, где:\\nЧисла, кратные 3, заменяются на \"Fizz\".Числа, кратные 5, заменяются на \"Buzz\".Числа, кратные 15, заменяются на \"FizzBuzz\".Остальные числа остаются без изменений.\\n",
      "code_content": "\nfunction fizzBuzz(numbers) {  \n    return numbers.map(num => {  \n        if (num % 15 === 0) return \"FizzBuzz\";  \n        if (num % 3 === 0) return \"Fizz\";  \n        if (num % 5 === 0) return \"Buzz\";  \n        return num;  \n    });  \n}  \n  \n  \nconsole.log(fizzBuzz([1, 2, 3, 4, 5, 15]));  \n  \n// Output: [1, 2, \"Fizz\", 4, \"Buzz\", \"FizzBuzz\"]  \n  \n  \nconsole.log(fizzBuzz([3, 5, 6, 10, 15, 30]));  \n  \n// Output: [\"Fizz\", \"Buzz\", \"Fizz\", \"Buzz\", \"FizzBuzz\", \"FizzBuzz\"]\n",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "conditionals",
        "loops",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_map"
      ],
      "keywords": [
        "numbers",
        "fizzbuzz",
        "num",
        "map"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "practice",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy0yq0062hxt8eh9stuz5",
      "title": "Батчинг",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "1. СберБанк"
      ],
      "text_content": "",
      "code_content": "const ExampleComponent = () => {\n  const [state, setState] = useState(0);\n  const onClick = () => {\n    setState((prev) => prev + 1);\n    setState((prev) => prev + 1);\n    setState((prev) => prev + 1);\n  };\n  return <button onClick={onClick}>{state}</button>;\n};",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "arrow_functions",
        "events"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring"
      ],
      "keywords": [
        "button",
        "usestate",
        "examplecomponent",
        "prev",
        "onclick",
        "state",
        "setstate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 20,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 12,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwet003dhxt8pj55oqwk",
      "title": "2. getAllValues",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Сумма всех значений в массиве древовидных структур\nДан массив объектов, представляющих древовидные структуры, в которых каждый узел содержит числовое значение и массив потомков. Реализуйте функцию, которая вычисляет сумму всех значений во всех деревьях.\\n",
      "code_content": "\nconst values = [  \n    {  \n        value: 2,  \n        children: [  \n            {  \n                value: 5,  \n                children: [  \n                    {  \n                        value: 8,  \n                        children: [],  \n                    },  \n                ],  \n            },  \n        ],  \n    },  \n    {  \n        value: 5,  \n        children: [],  \n    },  \n    {  \n        value: 10,  \n        children: [  \n            {  \n                value: 90,  \n                children: [],  \n            },  \n        ],  \n    },  \n]  \n  \nfunction getAllValues(nodes) {  \n    return nodes.reduce((total, node) => {  \n        return total + node.value + (node.children ? getAllValues(node.children) : 0);  \n    }, 0);  \n}\n  \nconsole.log(getAllValues(values)); // Вывод: 120\n",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "objects",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "children",
        "values",
        "reduce",
        "total",
        "nodes",
        "value",
        "node",
        "getallvalues"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 54,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwfk003ehxt8iwndvw9w",
      "title": "3. treeValueSum",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Сумма значений в бинарном дереве\nДано бинарное дерево, где каждый узел содержит числовое значение и ссылки на левый и правый дочерние узлы. Напишите функцию, которая вычисляет сумму всех значений в дереве.\\n",
      "code_content": "\nconst tree = {  \n    left: {  \n        left: {  \n            left: {  \n                right: {  \n                    left: { value: 7 },  \n                    right: { value: 14 },  \n                    value: 66,  \n                },  \n                value: 23,  \n            },  \n            value: 90,  \n        },  \n        right: { value: 67 },  \n        value: 34,  \n    },  \n    right: { value: 11 },  \n    value: 16,  \n};  \n  \nfunction treeValueSum(tree) {  \n    let total = tree.value;  \n  \n    if (tree.left) {  \n        total += treeValueSum(tree.left);  \n    }  \n  \n    if (tree.right) {  \n        total += treeValueSum(tree.right);  \n    }  \n  \n    return total;  \n}  \n  \nconsole.log(treeValueSum(tree)); // Вывод: 328  \n  \n  \n",
      "code_language": "js",
      "code_lines": 30,
      "complexity_score": 5.5,
      "difficulty_factors": [
        "Средний код (30 строк)",
        "Глубокая вложенность (6)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "objects",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "tree",
        "total",
        "value",
        "right",
        "treevaluesum",
        "left"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 62,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwga003fhxt88xcx9kb6",
      "title": "4. collectValuesDFS4",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Обход дерева в глубину (DFS) итеративно\nДано древовидное представление данных, где каждый узел содержит значение и массив потомков. Реализуйте итеративный алгоритм обхода дерева в глубину (DFS), возвращающий массив значений узлов в порядке обхода.\\n",
      "code_content": "\nconst tree = {  \n    value: 1,  \n    children: [  \n        { value: 2, children: [{ value: 3 }] },  \n        { value: 4, children: [{ value: 5 }, { value: 6 }] }  \n    ],  \n};  \n  \n  \nfunction collectValuesIterative(root) {  \n    const values = [];  \n    const stack = [root];  \n  \n    while (stack.length > 0) {  \n        const node = stack.pop();  \n        values.push(node.value);  \n  \n        if (node.children) {  \n            for (let i = node.children.length - 1; i >= 0; i--) {  \n                stack.push(node.children[i]);  \n            }  \n        }    }  \n    return values;  \n}  \n  \nconsole.log(collectValuesIterative(tree)); // Вывод: [1, 2, 3, 4, 5, 6]\n\n",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (4)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "dfs",
        "root",
        "values",
        "tree",
        "children",
        "value",
        "node",
        "collectvaluesiterative",
        "stack"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 52,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.83,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwh3003ghxt8bp1vouz7",
      "title": "5. collectValuesBFS",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Обход дерева в ширину (BFS)\nДано дерево, где каждый узел содержит числовое значение и массив потомков. Реализуйте функцию, которая выполняет обход дерева в ширину (BFS) и возвращает массив значений узлов в порядке обхода.\\n",
      "code_content": "\n  \nconst a = {  \n    value: 1,  \n    children: [  \n        {  \n            value: 2,  \n            children: [{ value: 4 }, { value: 5 }],  \n        },  \n        {  \n            value: 3,  \n            children: [{ value: 6 }, { value: 7 }],  \n        },  \n    ],  \n};  \n  \nfunction collectValuesBFS(root) {  \n    const values = [];  \n    const queue = [root];  \n  \n    while (queue.length > 0) {  \n        const node = queue.shift();  \n        values.push(node.value);  \n        queue.push(...(node.children ?? []));  \n    }  \n    return values;  \n}  \n  \n  \nconsole.log(collectValuesBFS(a)); // Вывод: [1, 2, 3, 4, 5, 6, 7]\n",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "children",
        "root",
        "values",
        "collectvaluesbfs",
        "value",
        "node",
        "bfs",
        "queue"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 55,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "exercise",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwht003hhxt8g1rmis4k",
      "title": "6. flattenObject(obj)",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование вложенного объекта в плоский (flattenObject)\nНапишите функцию, которая принимает вложенный объект и преобразует его в плоскую структуру, объединяя ключи через точку. Глубина вложенности объекта может быть произвольной.\\n",
      "code_content": "  \n// Напишите функцию flattenObject(obj), которая принимает в качествеаргумента вложенный объект obj // и возвращает новый объект,в котором все свойства объекта obj \"разглажены\"(преобразованы в одноуровневую структуру)  \n  \nconst obj = {  \n    a: {  \n        b: {  \n            c: 1,  \n            d: 2  \n        },  \n        e: 3  \n    },  \n    f: 4  \n};  \n  \n  \nconst flattenObject = (obj, parentKey = '', result = {}) => {  \n  \n    for (const [key, value] of Object.entries(obj)) {  \n  \n        const newKey = parentKey ? `${parentKey}.${key}` : key;  \n  \n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {  \n            flattenObject(value, newKey, result);  \n  \n        } else {  \n            result[newKey] = value;  \n        }  \n  \n    }  \n  \n    return result;  \n  \n  \n};  \n  \n  \nconst flattenedObj = flattenObject(obj);  \n  \n// Ожидаемый результат: { 'a.b.c': 1, 'a.b.d': 2, 'a.e': 3, 'f': 4 }  \n  \nconsole.log(flattenedObj);",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "template_literals"
      ],
      "keywords": [
        "parentkey",
        "key",
        "obj",
        "object",
        "value",
        "array",
        "isarray",
        "result",
        "flattenobject",
        "typeof",
        "newkey",
        "flattenedobj",
        "entries"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 46,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy5t004jhxt81ai0mp7u",
      "title": "5. findVowels (колво гласных)",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Подсчет количества гласных в строке\nРеализуйте функцию, которая подсчитывает количество гласных букв в заданной строке.\\n",
      "code_content": "\n// vowels - aeiouAEIOU  \n  \n  \n// for of  \n  \nfunction findVowelsForLoop(str) {  \n    const vowels = 'aeiouAEIOU';  \n    let count = 0;  \n  \n    for (let char of str) {  \n        if (vowels.includes(char)) {  \n            count++;  \n        }  \n    }    return count;  \n}  \n  \n  \n// методы массивов  \n  \nfunction findVowelsFilter(str) {  \n    const vowels = 'aeiouAEIOU';  \n    return str.split('').filter(char => vowels.includes(char)).length;  \n}  \n  \n  \n  \nconsole.log(findVowelsForLoop('hello')); // Ожидаемый вывод: 2  console.log(findVowelsForLoop('why'));   // Ожидаемый вывод: 0    \n  \nconsole.log(findVowelsFilter('hello'));  \nconsole.log(findVowelsFilter('why'));\n",
      "code_language": "js",
      "code_lines": 19,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "arrow_functions",
        "searching",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_filter"
      ],
      "keywords": [
        "filter",
        "findvowelsforloop",
        "findvowelsfilter",
        "includes",
        "count",
        "str",
        "vowels",
        "findvowels",
        "char",
        "split"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 35,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwik003ihxt85wanudxu",
      "title": "7. Реализуйте поверхностное копирование объекта",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Реализация поверхностного и глубокого копирования объекта\nРеализуйте функцию копирования объекта, которая может выполнять как поверхностное копирование, так и глубокое копирование. При глубоком копировании вложенные объекты должны создаваться заново, а при поверхностном — копироваться только на верхнем уровне.\\n",
      "code_content": "const obj = {  \n    foo: 'bar',  \n    baz: {  \n        qux: {  \n            a: 'b'  \n        }  \n    }};  \n  \nconst copyObj = (obj, shallow = true) => {  \n    if (shallow) {  \n        return { ...obj };  \n    } else {  \n  \n        const deepCopy = (item) => {  \n            if (typeof item !== 'object' || item === null) {  \n                return item;  \n            }  \n  \n            if (Array.isArray(item)) {  \n                return item.map(deepCopy);  \n            }  \n  \n            const result = {};  \n            for (const key in item) {  \n                if (item.hasOwnProperty(key)) {  \n                    result[key] = deepCopy(item[key]);  \n                }  \n            }            return result;  \n        };  \n  \n        return deepCopy(obj);  \n    }  \n};  \n  \n  \nconst _obj = copyObj(obj);   \n_obj.baz.qux.a = 'c';  \n  \nconsole.log(obj.baz.qux.a); // 'c'  \n  \nconst __obj = copyObj(_obj, false);  \n  \n__obj.baz.qux.a = 'd';  \n  \nconsole.log(_obj.baz.qux.a); // 'c'",
      "code_language": "js",
      "code_lines": 34,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (34 строк)",
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_map"
      ],
      "keywords": [
        "item",
        "key",
        "obj",
        "hasownproperty",
        "baz",
        "copyobj",
        "array",
        "map",
        "isarray",
        "result",
        "qux",
        "foo",
        "typeof",
        "shallow",
        "deepcopy"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 62,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 0.37,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwjb003jhxt8vlwlon6v",
      "title": "8. inverse",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Инвертирование значений в объекте\nДан вложенный объект, содержащий числовые значения 0 и 1. Реализуйте функцию, которая рекурсивно заменяет 0 на 1 и 1 на 0, сохраняя структуру объекта.\\n",
      "code_content": "\nfunction inverse(obj) {  \n  \n    for (const key in obj) {  \n        if (typeof obj[key] === 'object' && obj[key] !== null) {  \n            inverse(obj[key]);  \n        } else if (obj[key] === 1) {  \n            obj[key] = 0;  \n        } else if (obj[key] === 0) {  \n            obj[key] = 1;  \n        }  \n    }  \n  \n}  \n  \n// Тестовые данные  \nconst tree = {  \n    a: {  \n        a: 1,  \n        b: {  \n            a: 0,  \n            b: 1,  \n        },  \n        c: 0,  \n    },  \n    b: 0,  \n    c: 1,  \n};  \n  \ninverse(tree);  \n  \nconsole.log(tree);  \n  \n/* Ожидаемый вывод:  \n{  \n  a: {    a: 0,    b: {      a: 1,      b: 0,    },    c: 1,  },  b: 1,  c: 0,}  \n*/\n",
      "code_language": "js",
      "code_lines": 30,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (30 строк)",
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "tree",
        "inverse",
        "key",
        "obj",
        "typeof"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 57,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "exercise",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwk5003khxt8zzpe4n0p",
      "title": "9. goSberPro",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Добавление уровня вложенности в объект\nНапишите функцию, которая добавляет в объект специальное поле \"sber_pro\", отражающее глубину вложенности каждого уровня.\\n",
      "code_content": "\nfunction goSberPro(obj, depth = 0) {  \n    obj['sber_pro'] = depth;  \n  \n    for (const key in obj) {  \n        if (typeof obj[key] === 'object' && obj[key] !== null) {  \n            goSberPro(obj[key], depth + 1);  \n        }  \n    }  \n    return obj;  \n}  \n  \n// Тестовые данные  \nconst input = { a: 1, b: 2, c: { d: { e: 3 } } };  \n  \nconst result = goSberPro(input);  \n  \nconsole.log(result);  \n  \n/* Ожидаемый вывод:  \n{  \n  a: 1,  b: 2,  c: {    d: {      e: 3,      sber_pro: 2    },    sber_pro: 1  },  sber_pro: 0}  \n*/\n",
      "code_language": "js",
      "code_lines": 17,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "gosberpro",
        "key",
        "obj",
        "input",
        "result",
        "typeof",
        "depth"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.19,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwkv003lhxt8og7qs4xq",
      "title": "10. deepcopy",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Глубокое копирование объекта\nРеализуйте функцию глубокого копирования объекта, которая создает новую структуру данных без ссылок на оригинальный объект.\\n",
      "code_content": "\nfunction deepCopy(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  // Если это массив, возвращаем копию через map\n  return Array.isArray(obj)\n    ? obj.map(deepCopy)\n    : Object.fromEntries(\n        Object.entries(obj).map(([key, value]) => [key, deepCopy(value)])\n      );\n}\n\n// Тестовые данные\nconst original = { a: 1, b: { c: 2 } };\nconst copy = deepCopy(original);\n\nconsole.log(copy); // { a: 1, b: { c: 2 } }\n\n// Проверка глубокого копирования\ncopy.b.c = 3;\nconsole.log(original.b.c); // 2 (не изменилось в оригинале)\n\n\n",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_map"
      ],
      "keywords": [
        "key",
        "obj",
        "copy",
        "array",
        "value",
        "deepcopy",
        "map",
        "isarray",
        "original",
        "fromentries",
        "typeof",
        "object",
        "entries"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwll003mhxt8uaub838w",
      "title": "11. transform",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование массива объектов в объект\nДан массив объектов с полями name и value. Реализуйте функцию, которая преобразует этот массив в объект, используя name в качестве ключа и value в качестве значения.\\n",
      "code_content": "\nfunction transform(arr) {  \n    return arr.reduce((acc, item) => {  \n        acc[item.name] = item.value;  \n        return acc;  \n    }, {});  \n}  \n  \n// Тестовые данные  \nconst arr = [  \n    { name: 'name', value: 'Анатолий' },  \n    { name: 'age', value: '40' },  \n];  \n  \nconsole.log(transform(arr)); // { name: 'Анатолий', age: '40' }\n",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "objects",
        "destructuring",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "item",
        "name",
        "acc",
        "transform",
        "reduce",
        "value",
        "arr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 10,
      "pedagogical_type": "exercise",
      "text_complexity": 0.31,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwmb003nhxt8pxpfkxxk",
      "title": "12. массив строк",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование объекта в массив строк\nНапишите функцию, которая преобразует вложенный объект в массив строк, представляющих пути к значениям в формате \"ключ: значение\".\\n",
      "code_content": "\nfunction objectToArray(obj, parentKey = '') {  \n    const result = [];  \n  \n    for (const key in obj) {  \n        const value = obj[key];  \n        const formattedKey = parentKey  \n            ? `${parentKey} ${capitalize(key)}`  \n            : capitalize(key);  \n  \n        if (typeof value === 'object' && value !== null) {  \n            result.push(...objectToArray(value, formattedKey));  \n        } else {  \n            result.push(`${formattedKey}: ${value}`);  \n        }  \n    }  \n    return result;  \n}  \n  \nfunction capitalize(str) {  \n    return str.charAt(0).toUpperCase() + str.slice(1).replace('_', ' ');  \n}  \n  \n// Тестовые данные  \nconst data = {  \n    id: 1,  \n    instrument_type: 'stock',  \n    instrument_name: 'Alrosa',  \n    contract: {  \n        id: 12,  \n        size: 25,  \n        payment: {  \n            value: '125',  \n            currency: 'RUB',  \n        },  \n    },  \n};  \n  \nconst result = objectToArray(data);  \n  \nconsole.log(result);  \n  \n/* Ожидаемый вывод:  \n[  \n  'Id: 1',  'Instrument type: stock',  'Instrument name: Alrosa',  'Contract id: 12',  'Contract size: 25',  'Contract payment value: 125',  'Contract payment currency: RUB',]  \n*/\n",
      "code_language": "js",
      "code_lines": 38,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (38 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "destructuring",
        "template_literals",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator",
        "template_literals"
      ],
      "keywords": [
        "parentkey",
        "value",
        "contract",
        "objecttoarray",
        "slice",
        "currency",
        "charat",
        "replace",
        "payment",
        "key",
        "size",
        "typeof",
        "str",
        "formattedkey",
        "touppercase",
        "obj",
        "data",
        "result",
        "capitalize"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 0.22,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwns003phxt8etnfnnm2",
      "title": "14. convertMenu",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование списка элементов в дерево\nДан массив объектов с полями id, parentId и title, представляющих элементы меню. Напишите функцию, которая преобразует этот список в древовидную структуру.\\n",
      "code_content": "\nfunction convertMenu(items, rootNodeId) {  \n    const idMap = {};  \n  \n    // Инициализация узлов и создание хеш-таблицы  \n    items.forEach(item => {  \n        idMap[item.id] = { ...item, children: [] };  \n    });  \n  \n    let rootNode = idMap[rootNodeId];  \n   \n  \n    // Построение дерева  \n    items.forEach(item => {  \n        const node = idMap[item.id];  \n        if (item.parentId === rootNodeId) {  \n            rootNode.children.push(node);  \n        } else if (item.parentId !== null && item.id !== rootNodeId) {  \n            const parent = idMap[item.parentId];  \n            if (parent) {  \n                parent.children.push(node);  \n            }  \n        }    });  \n  \n    return rootNode;  \n}  \n  \n// Тестовые данные  \nconst items = [  \n    { id: 1, parentId: null, title: 'Food' },  \n    { id: 2, parentId: 1, title: 'Sweets' },  \n    { id: 3, parentId: 2, title: 'Chocolate bars' },  \n    { id: 4, parentId: 1, title: 'Fruits' },  \n    { id: 5, parentId: null, title: 'BBQ utilities' },  \n];  \n  \nconst rootNodeId = 1;  \n  \nconst result = convertMenu(items, rootNodeId);  \n  \n  \nconsole.log(JSON.stringify(result, null, 2));\n",
      "code_language": "js",
      "code_lines": 31,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (31 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "objects",
        "strings",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "array_forEach"
      ],
      "keywords": [
        "children",
        "title",
        "item",
        "stringify",
        "idmap",
        "items",
        "rootnode",
        "parent",
        "foreach",
        "node",
        "result",
        "json",
        "parentid",
        "convertmenu",
        "rootnodeid"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 50,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 13,
      "pedagogical_type": "exercise",
      "text_complexity": 0.26,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwoq003qhxt89loz0fmq",
      "title": "15. flattenObject(obj)",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование вложенного объекта в плоский\nРеализуйте функцию, которая преобразует вложенный объект в плоскую структуру, объединяя ключи через точку.\\n",
      "code_content": "\nfunction flattenObject(obj, parentKey = '', result = {}) {  \n    for (const key in obj) {  \n        const value = obj[key];  \n        const newKey = parentKey ? `${parentKey}.${key}` : key;  \n  \n        if (typeof value === 'object' && value !== null) {  \n            flattenObject(value, newKey, result);  \n        } else {  \n            result[newKey] = value;  \n        }  \n    }  \n    return result;  \n}  \n  \n// Тестовые данные  \nconst obj = {  \n    a: {  \n        b: {  \n            c: 1,  \n            d: 2,  \n        },  \n        e: 3,  \n    },  \n    f: 4,  \n};  \n  \nconst flattenedObj = flattenObject(obj);  \n  \nconsole.log(flattenedObj);  \n  \n/* Ожидаемый вывод:  \n{  \n  'a.b.c': 1,  'a.b.d': 2,  'a.e': 3,  'f': 4,}  \n*/\n",
      "code_language": "js",
      "code_lines": 29,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (29 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "destructuring",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "parentkey",
        "key",
        "obj",
        "value",
        "result",
        "flattenobject",
        "typeof",
        "newkey",
        "flattenedobj"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 42,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 14,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxwpg003rhxt8qckt1kte",
      "title": "16. a.b.c.d.e => {a:{b:c{d:{e:{}}}}}",
      "category": "JS",
      "subcategory": "Objects",
      "path_titles": [],
      "text_content": "Преобразование строки в вложенный объект\nНапишите функцию, которая принимает строку вида \"a.b.c.d.e\" и преобразует её в объект { a: { b: { c: { d: { e: {} } } } } }.\\n",
      "code_content": "\nfunction stringToNestedObject(str, value = {}) {  \n    const keys = str.split('.');  \n    const lastIndex = keys.length - 1;  \n    let result = {};  \n    let current = result;  \n  \n    for (let i = 0; i < keys.length; i++) {  \n        const key = keys[i];  \n        if (i === lastIndex) {  \n            current[key] = value;  \n        } else {  \n            current[key] = {};  \n            current = current[key];  \n        }  \n    }  \n    return result;  \n}  \n  \n// Тестовые данные  \nconst str = 'a.b.c.d.e';  \nconst value = 42;  \n  \nconst nestedObj = stringToNestedObject(str, value);  \n  \nconsole.log(JSON.stringify(nestedObj, null, 2));\n",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "objects",
        "strings",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "keys",
        "stringify",
        "key",
        "value",
        "json",
        "result",
        "split",
        "str",
        "lastindex",
        "current",
        "nestedobj",
        "stringtonestedobject"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 43,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 15,
      "pedagogical_type": "exercise",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxx7e003thxt8a3fnleyl",
      "title": "1. Add Two Promises",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:Даны два промиса, возвращающих числа. Необходимо написать функцию, которая возвращает новый промис, резолвящийся в сумму результатов этих двух промисов.\\n",
      "code_content": "// promise.all + async await  \nasync function sumPromises1(promise1, promise2) {  \n    const [result1, result2] = await Promise.all([promise1, promise2]);\n    return result1 + result2;\n}  \n\n// вложенные then  \nfunction sumPromises2(promise1, promise2) {  \n    return promise1.then(result1 =>\n        promise2.then(result2 => result1 + result2)\n    );\n}  \n\n// Создание промисов  \nconst promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20));  \nconst promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60));  \n\nasync function runInOrder() {  \n    // Вариант 1  \n    const result1 = await sumPromises1(promise1, promise2);\n    console.log(\"sumPromises1:\", result1);  \n\n    // Вариант 2  \n    const result2 = await sumPromises2(promise1, promise2);\n    console.log(\"sumPromises2:\", result2);\n}  \n\n// Запуск  \nrunInOrder();",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "destructuring",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring",
        "async_await",
        "promises"
      ],
      "keywords": [
        "resolve",
        "all",
        "await",
        "two",
        "settimeout",
        "runinorder",
        "async",
        "then",
        "add",
        "promise",
        "promises"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 43,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "practice",
      "text_complexity": 0.7,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxx85003uhxt8ysyfns6p",
      "title": "2. Цепочка из 3 промисов",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:Реализуйте цепочку из трёх промисов с задержкой в 3 секунды на каждом этапе. Для этого необходимо:\\nНаписать функцию multiplyByThree, которая принимает число, через 3 секунды умножает его на 3 (обратите внимание, в коде умножение происходит на 2, что может быть ошибкой) и возвращает результат в виде промиса.Сформировать цепочку промисов, где:Первый промис обрабатывает начальное число.Результат каждого промиса передаётся следующему.После третьего промиса результат выводится в ко...",
      "code_content": "// сделать цепочку из 3 промисов  \n// каждый промис умножает входное число на 3 и передает дальше через 3 секунды  \n// последний выводит в консоль  \n  \n  \nconst number = 3  \n// сама функция  \nfunction multiplyByThree(value) {  \n    return new Promise(resolve => {  \n        setTimeout(() => {  \n            resolve(value * 2)  \n        }, 3000)  \n    })  \n}  \n  \n  \n  \n// then usage  \nmultiplyByThree(number)  \n    .then(result => multiplyByThree(result))  \n    .then(result => multiplyByThree(result))  \n    .then(result => console.log(result))  \n  \n  \n  \n// async await usage  \nasync function processWithAsyncAwait(value) {  \n  \n    const result1 = await multiplyByThree(value)  \n    const result2 = await multiplyByThree(result1)  \n    const result3 = await multiplyByThree(result2)  \n  \n    console.log(result3)  \n}  \n  \n  \nprocessWithAsyncAwait(number);",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await",
        "promises"
      ],
      "keywords": [
        "resolve",
        "multiplybythree",
        "number",
        "await",
        "value",
        "settimeout",
        "processwithasyncawait",
        "result",
        "async",
        "then",
        "promise"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 80,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 1.4,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxybu004rhxt821vvdjmk",
      "title": "13. reverseWords",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Переворот слов в строке (Reverse Words)\nНапишите функцию, которая переворачивает каждое слово в заданной строке, сохраняя порядок слов.\\n",
      "code_content": "function reverseWords(str) {  \n    return str.split(' ').map(word => word.split('').reverse().join('')).join(' ');  \n}  \n  \nconst str = '123'  \n  \n  \nconsole.log(reverseWords(str)) // 321\n",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 1.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "strings",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_map"
      ],
      "keywords": [
        "reverse",
        "reversewords",
        "words",
        "map",
        "str",
        "word",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 12,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxx8w003vhxt8nblvhg45",
      "title": "3. Выводить индексы элементов с интервалом 1 секунда",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nСоздайте функцию, которая выводит индексы элементов массива с интервалом в 1 секунду, не используя setInterval. Для демонстрации различных подходов, реализуйте эту функциональность несколькими способами:\\nС использованием setTimeout в цикле:Для каждого элемента массива установите задержку, пропорциональную его индексу, чтобы выводить индекс с нужным интервалом.С использованием async/await и функции задержки (sleep):Напишите функцию delay, возвращающую промис с задержкой, а за...",
      "code_content": "// функция должна выводить индексы элементов массива с интервалом 1 секунда  \n// нельзя использовать setInterval  \n  \n  \nfunction logIndexesWithTimeout(arr) {  \n    for (let i = 0; i < arr.length; i++) {  \n        setTimeout(() => {  \n            console.log(\"Index with setTimeout:\", i);  \n        }, i * 1000);  \n    }  \n}  \n  \nlogIndexesWithTimeout([1, 2, 3, 4, 5]);  \n  \n  \n  \n  \n// sleep для задержки, для использования в async/await  \nfunction delay(ms) {  \n    return new Promise(resolve => setTimeout(resolve, ms));  \n}  \n  \n  \n// async await + sleep  \nasync function logIndexesAsync(arr) {  \n    for (let i = 0; i < arr.length; i++) {  \n        console.log(\"Index with async/await:\", i);  \n        await delay(1000);  \n    }  \n}  \n  \n// Пример использования:  \nlogIndexesAsync([1, 2, 3, 4, 5]);  \n  \n  \n  \n// reduce + then  \nfunction logIndexesWithPromises(arr) {  \n    arr.reduce((promise, _, index) => {  \n        return promise.then(() => {  \n            console.log(\"Index with promises:\", index);  \n            return new Promise(resolve => setTimeout(resolve, 1000));  \n        });  \n    }, Promise.resolve());  \n}  \n  \n  \n// logIndexesWithPromises([1, 2, 3, 4, 5]);  \n  \n  \n  \n// рекурсия + setTimeout  \nfunction logIndexesRecursively(arr, index = 0) {  \n    if (index < arr.length) {  \n        console.log(\"Index with recursion:\", index);  \n        setTimeout(() => logIndexesRecursively(arr, index + 1), 1000);  \n    }  \n}  \n  \nlogIndexesRecursively([1, 2, 3, 4, 5]);",
      "code_language": "js",
      "code_lines": 41,
      "complexity_score": 8.5,
      "difficulty_factors": [
        "Средний код (41 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (2)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "async",
        "arrow_functions",
        "recursion",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await",
        "promises",
        "array_reduce"
      ],
      "keywords": [
        "resolve",
        "logindexeswithpromises",
        "logindexesrecursively",
        "delay",
        "reduce",
        "logindexesasync",
        "await",
        "settimeout",
        "setinterval",
        "async",
        "then",
        "arr",
        "promise",
        "sleep",
        "logindexeswithtimeout",
        "index"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 120,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 1.74,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxx9q003whxt82t576qha",
      "title": "4. Обертка над фетчем",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "**Постановка задачи:\\nРеализуйте функцию customFetch, которая выполняет HTTP-запрос по заданному URL с возможностью повторной попытки в случае ошибки. Функция принимает два параметра:\\nurl — адрес для запроса.count — количество оставшихся попыток.\\nЕсли запрос с помощью fetch завершается неудачно, функция уменьшает счетчик попыток и через 1 секунду повторяет запрос, пока не исчерпает все попытки. Если ни одна из попыток не увенчалась успехом, функция возвращает ошибку. Такой подход позволяет реа...",
      "code_content": "function customFetch(url, count) {\n  return fetch(url).catch((err) => {\n    return new Promise((res, rej) => {\n      count--;\n      if (count > 0) {\n        setTimeout(() => {\n          customFetch(url, count).then(res).catch(rej);\n        }, 1000);\n      } else {\n        console.log(\"zdes\", err);\n        rej(err);\n      }\n    });\n  });\n}",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "functions",
        "conditionals",
        "async",
        "arrow_functions",
        "error_handling"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "url",
        "res",
        "fetch",
        "customfetch",
        "nurl",
        "count",
        "catch",
        "settimeout",
        "http",
        "then",
        "rej",
        "promise",
        "err"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 56,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.69,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxag003xhxt80033zpaf",
      "title": "5. fetchData",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте асинхронную функцию fetchData, которая выполняет последовательные запросы на получение JSON-данных и обрабатывает ошибки следующим образом:\\nСначала функция вызывает getJson('/json/1') и ожидает результат.Если в полученном объекте json1 отсутствует свойство key, функция должна сгенерировать ошибку с сообщением \"No key\".Если свойство key присутствует, функция выполняет следующий запрос с помощью getJson('/json/2') и возвращает значение свойства key2 из результата.Ве...",
      "code_content": "async function fetchData() {  \n    try {  \n        const json1 = await getJson('/json/1');  \n        if (!json1.key) {  \n            throw new Error('No key');  \n        }  \n        const json2 = await getJson('/json/2');  \n        return json2.key2;  \n    } catch (error) {  \n        console.error(error);  \n        throw error; // Re-throw the error if necessary  \n    }  \n}  \n  \nfetchData()  \n    .then(result => {  \n        console.log(result);  \n    })  \n    .catch(error => {  \n        // Additional error handling if needed  \n    });",
      "code_language": "js",
      "code_lines": 20,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "async",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await"
      ],
      "keywords": [
        "throw",
        "key",
        "await",
        "catch",
        "json",
        "error",
        "getjson",
        "try",
        "then",
        "async",
        "fetchdata",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 74,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 4,
      "pedagogical_type": "example",
      "text_complexity": 0.96,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxb6003yhxt8agyoqdvi",
      "title": "6. promisify",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "https://bigfrontend.dev/problem/promisify\\nhttps://leetcode.ca/2023-10-30-2776-Convert-Callback-Based-Function-to-Promise-Based-Function/\\nПостановка задачи:\\nРеализуйте функцию promisify, которая принимает на вход функцию, использующую стандартный Node.js-стиль коллбэков (где последний аргумент — функция обратного вызова с параметрами error и data), и возвращает новую функцию, которая возвращает промис.\\nТребования:\\nФункция promisify должна принимать исходную функцию func и возвращать функцию,...",
      "code_content": "function promisify(func) {  \n    return function (...args) {  \n        return new Promise((resolve, reject) => {  \n  \n            console.log(\"Calling promisified function...\");  \n  \n            // Вызываем исходную функцию с коллбэком    \nfunc.call(this, ...args, (error, data) => {  \n                if (error) {  \n                    console.log(\"Error occurred:\", error);  \n                    reject(error);  \n                } else {  \n                    resolve(data);  \n                }  \n            });  \n        });  \n    }  \n}  \n  \n  \n  \n// Оригинальная функция с коллбэком, которая выполняется с задержкой  \nfunction delayedCallback(data, delay, callback) {  \n    setTimeout(() => {  \n        if (typeof data === 'undefined') {  \n            callback(\"No data provided\", null);  \n        } else {  \n            callback(null, `Processed: ${data}`);  \n        }  \n    }, delay);  \n}  \n  \n  \n// Промисификация функции с использованием promisify  \nconst delayedPromise = promisify(delayedCallback);  \n  \n  \n// Использование функции, возвращающей промис  \n  \ndelayedPromise(\"Hello, world!\", 1000)  \n    .then(result => console.log(result))  // Ожидаемый вывод: \"Processed: Hello, world!\"  \n    .catch(error => console.error(error)); // Если ошибка, например, data === undefined",
      "code_language": "js",
      "code_lines": 32,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (32 строк)",
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "async",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "spread_operator",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "template_literals",
        "promises"
      ],
      "keywords": [
        "processed",
        "delayedpromise",
        "delay",
        "promisify",
        "func",
        "call",
        "then",
        "error",
        "typeof",
        "args",
        "https",
        "resolve",
        "callback",
        "data",
        "settimeout",
        "catch",
        "reject",
        "result",
        "promise",
        "delayedcallback"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 100,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "example",
      "text_complexity": 1.8,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyck004shxt8xbifcpjd",
      "title": "14. string.prototype.repeatify",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Метод repeatify для строки\nРеализуйте метод repeatify, который дублирует строку заданное количество раз.\\n",
      "code_content": "\nString.prototype.repeatify = function(count) {  \n    let result = '';  \n  \n    for (let i = 0; i < count; i++) {  \n        result += this;  \n    }  \n  \n    return result;  \n};  \n  \n  \n  \nconst str = '123';  \n  \nconsole.log(str.repeatify(3)) // '123123123'\n",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "repeatify",
        "prototype",
        "count",
        "string",
        "result",
        "str"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 27,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 13,
      "pedagogical_type": "exercise",
      "text_complexity": 0.13,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxbx003zhxt8dtyuwmzw",
      "title": "7. fetchDataWithDelay",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию fetchDataWithDelay, которая выполняет следующие шаги:\\nВыполняет HTTP-запрос по заданному URL с помощью fetch.Преобразует ответ в формат JSON.Задерживает возврат полученных данных на 1 секунду, прежде чем промис будет разрешён.\\nРешите задачу двумя способами:\\nС использованием цепочки промисов (.then):Создайте функцию, в которой после получения и преобразования данных создаётся новый промис с задержкой в 1 секунду.С использованием async/await:Напишите асинх...",
      "code_content": "function fetchDataWithDelay(url) {  \n  \n    return fetch(url)  \n        .then(response => response.json())  \n        .then(data => {  \n            return new Promise(resolve => setTimeout(() => resolve(data), 1000));  \n  \n        });  \n}  \n  \n// Пример использования функции  \nfetchDataWithDelay('https://api.example.com/data')  \n    .then(data => console.log(data))  \n    .catch(error => console.error('Ошибка:', error));",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "functions",
        "async",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "resolve",
        "url",
        "fetch",
        "await",
        "data",
        "settimeout",
        "catch",
        "response",
        "json",
        "error",
        "http",
        "then",
        "async",
        "try",
        "promise",
        "fetchdatawithdelay"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 61,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 1.42,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxco0040hxt8asigmboe",
      "title": "8. timeLimit",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию timeLimit, которая принимает асинхронную функцию fn и временной лимит t (в миллисекундах). Функция должна возвращать новую обёртку, при вызове которой:\\nЕсли fn завершается быстрее, чем за t миллисекунд, возвращается её результат.Если выполнение fn занимает больше времени, чем указано в лимите, возвращается ошибка с сообщением \"Time Limit Exceeded\".\\nПодсказка: Для решения используйте Promise.race, чтобы \"соревновались\" выполнение fn(...args) и промис с зад...",
      "code_content": "const timeLimit = function(fn, t) {  \n    return async function(...args) {  \n        const timeoutPromise = new Promise((_, reject) => {  \n            setTimeout(() => reject(\"Time Limit Exceeded\"), t);  \n        });  \n  \n        return Promise.race([fn(...args), timeoutPromise]);  \n    };  \n};  \n  \n  \nconst limitedFunction = timeLimit(async (n) => {  \n    await new Promise(res => setTimeout(res, 100));  \n    return n * n;  \n}, 50);  \n  \n  \n  \nlimitedFunction(5)  \n    .then(console.log)   \n\t.catch(console.error);",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 3.0,
      "difficulty_factors": [
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "error_handling"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "async_await",
        "promises"
      ],
      "keywords": [
        "res",
        "await",
        "race",
        "timeoutpromise",
        "settimeout",
        "catch",
        "timelimit",
        "reject",
        "error",
        "async",
        "then",
        "promise",
        "limitedfunction",
        "args"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 68,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "example",
      "text_complexity": 1.41,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxdf0041hxt8qtiizdxr",
      "title": "9. withTimeout",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию, которая обеспечивает ограничение по времени для выполнения промиса. Если переданный промис не завершается в заданный интервал, функция должна отклонять результат с ошибкой \"Promise timed out\". Необходимо создать два варианта решения:\\nВариант 1 (withTimeout1):Используйте setTimeout для установки таймера и clearTimeout для его очистки, если промис завершается до истечения времени. Функция должна возвращать новый промис, который:Разрешается, если исходный пр...",
      "code_content": "// Вариант 1: Использование setTimeout и clearTimeout для явного контроля таймера  \n\nfunction withTimeout1(promise, timeout) {  \n    return new Promise((resolve, reject) => {  \n                  \nconst timer = setTimeout(() => {  \n            reject(new Error(\"Promise timed out\"));  \n        }, timeout);  \n  \n        promise  \n            .then(value => {  \n                clearTimeout(timer); // Очищаем таймер, если промис разрешается  \n                resolve(value);  \n            })  \n            .catch(err => {  \n                clearTimeout(timer); // Очищаем таймер, если промис отклоняется  \n                reject(err);  \n            });  \n                  \n});  \n}  \n  \n  \n// Вариант 2: Использование Promise.race  \nfunction withTimeout2(promise, timeout) {  \n    const timeoutPromise = new Promise((_, reject) =>  \n        setTimeout(() => reject(new Error(\"Promise timed out\")), timeout)  \n    );  \n  \n    return Promise.race([promise, timeoutPromise]); // Возвращает результат первого завершившегося промиса  \n  \n}  \n  \n  \n  \n// Пример использования для вариантов 1, 2  \nconst examplePromise = new Promise(resolve => setTimeout(() => resolve(\"Success!\"), 3000));  \n  \nwithTimeout1(examplePromise, 2000).then(console.log).catch(console.error); // \"Promise timed out\"  \nwithTimeout2(examplePromise, 2000).then(console.log).catch(console.error); // \"Promise timed out\"",
      "code_language": "js",
      "code_lines": 28,
      "complexity_score": 2.5,
      "difficulty_factors": [
        "Средний код (28 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "resolve",
        "timer",
        "cleartimeout",
        "race",
        "settimeout",
        "value",
        "catch",
        "reject",
        "error",
        "timeoutpromise",
        "then",
        "timeout",
        "examplepromise",
        "promise",
        "withtimeout",
        "err"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 92,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "example",
      "text_complexity": 1.85,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxe60042hxt8395kf8t0",
      "title": "10. Кастомный race",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию race, которая принимает массив значений, где каждый элемент может быть как промисом, так и обычным значением. Функция должна возвращать новый промис, который разрешается или отклоняется с тем значением или ошибкой, которое произойдет первым. Для каждого элемента массива необходимо использовать Promise.resolve(), чтобы гарантировать корректную работу даже для не-промисов.\\nТребования:\\nЕсли первый завершившийся элемент (или значение) успешно завершается, рез...",
      "code_content": "function race(promises) {  \n    return new Promise((resolve, reject) => {  \n  \n        promises.forEach((promise) => {  \n            // Оборачиваем каждый элемент в Promise.resolve() на случай, если это не промис  \n            Promise.resolve(promise).then(resolve, reject);  \n        });  \n  \n  \n    });  \n}  \n  \n  \nconst p1 = new Promise((resolve) => setTimeout(resolve, 500, \"p1\"));  \nconst p2 = new Promise((resolve, reject) => setTimeout(reject, 300, \"p2 Error\"));  \nconst p3 = \"Immediate Value\"; // Не-промис  \n  \n  \n// Используем race  \nrace([p1, p2, p3])  \n    .then((value) => console.log(\"Resolved with:\", value))  \n    .catch((error) => console.error(\"Rejected with:\", error)); // Ожидаемый вывод: \"Resolved with: Immediate Value\"",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises",
        "array_forEach"
      ],
      "keywords": [
        "resolve",
        "race",
        "settimeout",
        "value",
        "foreach",
        "reject",
        "catch",
        "error",
        "then",
        "promise",
        "promises"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 75,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "example",
      "text_complexity": 1.79,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1340068hxt8rr8dkllm",
      "title": "Счетчик полуавтоматический",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "4. IBS"
      ],
      "text_content": "",
      "code_content": "const Counter = () => {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    const interval = setInterval(() => setCount((prev) => prev + 1), 3000);\n    return () => clearInterval(interval);\n  }, []);\n  return <button onClick={() => setCount((prev) => prev + 1)}>{count}</button>;\n};",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "destructuring",
        "arrow_functions",
        "events"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring"
      ],
      "keywords": [
        "button",
        "setcount",
        "interval",
        "usestate",
        "counter",
        "count",
        "setinterval",
        "prev",
        "clearinterval",
        "onclick",
        "useeffect"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 19,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 18,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxex0043hxt8dsobibwk",
      "title": "11. Кастомный finally",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию myFinally, которая принимает два аргумента:\\npromise — исходный промис.onFinally — функцию (которая может быть асинхронной), выполняемую в блоке \"finally\".\\nФункция myFinally должна вести себя аналогично методу .finally() для промисов:\\nНезависимо от того, разрешился ли исходный промис или был отклонён, сначала выполняется функция onFinally.Если onFinally завершается успешно, возвращается результат исходного промиса.Если исходный промис был отклонён, то рез...",
      "code_content": "// промис для тестирования  \n  \nconst promise = Promise.resolve(\"Result\");  \n  \n  \n// основная функция  \nfunction myFinally(promise, onFinally) {  \n    const runFinally = async () => {  \n        try {  \n            return await Promise.resolve(onFinally());  \n        } catch (err) {  \n            throw err;  \n        }  \n    };  \n  \n    return promise.then(  \n        value => runFinally().then(() => value),  \n        reason => runFinally().then(() => { throw reason; })  \n    );  \n}\n  \n  \n// then usage  \nmyFinally(promise, () => {  \n    console.log(\"Cleanup completed.\");  \n}).then(result => console.log(\"Resolved with:\", result))  \n    .catch(error => console.error(\"Rejected with:\", error));  \n  \n  \nasync function myFinallyAsync(promise) {  \n    try {  \n        const result = await myFinally(promise, async () => {  \n            console.log(\"Starting async cleanup...\");  \n            await new Promise(resolve => setTimeout(resolve, 1000)); // Асинхронная очистка  \n            console.log(\"Async cleanup completed.\");  \n        });  \n        console.log(\"Resolved with:\", result);  \n    } catch (error) {  \n        console.error(\"Rejected with:\", error);  \n    }  \n}  \n  \nmyFinallyAsync(promise);  \nmyFinallyAsync(Promise.reject(\"Error occurred!\")); // Пример с отклонённым промисом",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "async_await",
        "promises"
      ],
      "keywords": [
        "await",
        "value",
        "myfinally",
        "npromise",
        "async",
        "myfinallyasync",
        "err",
        "then",
        "error",
        "try",
        "finally",
        "runfinally",
        "resolve",
        "onfinally",
        "throw",
        "settimeout",
        "catch",
        "reject",
        "reason",
        "result",
        "promise"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 101,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 10,
      "pedagogical_type": "example",
      "text_complexity": 1.71,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxfo0044hxt82hrt8pdt",
      "title": "12. Кастомный all",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию all, которая ведёт себя аналогично встроенному Promise.all. Функция принимает массив промисов (или значений, которые можно обернуть с помощью Promise.resolve()) и возвращает новый промис, который:\\nРазрешается с массивом результатов, если все переданные промисы успешно завершаются. Результаты должны располагаться в том же порядке, что и исходный массив.Отклоняется немедленно, если хотя бы один из переданных промисов отклоняется, возвращая ошибку первого вст...",
      "code_content": "const p1 = Promise.resolve(1);\nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, 2));\nconst p3 = Promise.resolve(3);\n\nall([p1, p2, p3])\n    .then(results => console.log(\"Resolved with:\", results)) // Ожидаемый вывод: [1, 2, 3]\n    .catch(error => console.error(\"Rejected with:\", error));\n",
      "code_language": "js",
      "code_lines": 6,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "resolve",
        "all",
        "settimeout",
        "catch",
        "error",
        "then",
        "promise",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 1.36,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxgf0045hxt8el43xkcy",
      "title": "13. Кастомный allSettled",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию allSettled, которая принимает массив промисов (а также значений, которые можно обрабатывать как уже разрешённые промисы) и возвращает новый промис. Этот промис должен разрешаться, когда все переданные промисы завершатся, независимо от того, были ли они разрешены или отклонены.\\nТребования:\\nЕсли переданный массив пуст, функция должна немедленно вернуть промис, разрешённый пустым массивом.Для каждого элемента массива создайте обёртку с помощью Promise.resolv...",
      "code_content": "const p1 = Promise.resolve(1);\nconst p2 = Promise.reject(\"Error in p2\");\nconst p3 = 3; // Не-промис, будет обработан как resolved\nconst p4 = new Promise(resolve => setTimeout(() => resolve(4), 100));\n\nallSettled([p1, p2, p3, p4])\n    .then(results => console.log(\"Results:\", results))\n    .catch(error => console.error(\"Error:\", error));",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "resolve",
        "value",
        "settimeout",
        "catch",
        "reject",
        "allsettled",
        "reason",
        "then",
        "error",
        "promise",
        "status",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 58,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 12,
      "pedagogical_type": "exercise",
      "text_complexity": 1.63,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxhs0046hxt869yx2p6j",
      "title": "14. Кастомный any",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию any, которая принимает массив промисов (или значений) и возвращает новый промис, который:\\nРазрешается, как только один из переданных промисов успешно завершится, возвращая его значение.Если все промисы отклоняются, функция должна отклониться с ошибкой типа AggregateError, содержащей массив всех ошибок.\\nОсобенности реализации:\\nЕсли переданный массив пуст, немедленно отклоните промис с AggregateError и сообщением, что промисы не найдены.Для каждого элемент...",
      "code_content": "function any(promises) {  \n    let counter = promises.length;  \n    let errors = [];  \n  \n    return new Promise((resolve, reject) => {  \n        if (!promises.length) {  \n            // Если массив пуст, немедленно отклоняем с пустым массивом ошибок  \n            return reject(new AggregateError('No promise found', errors));  \n        }  \n  \n        promises.forEach((promise) => {  \n            Promise.resolve(promise)  \n                .then(resolve)   \n.catch((error) => {  \n                    errors.push(error);  \n                    counter--;  \n                    if (counter === 0) {  \n                        reject(new AggregateError('All promises are rejected', errors));  \n                    }  \n                });  \n        });  \n    });  \n}  \n  \n// Примеры использования:  \n  \nconst p1 = Promise.reject(\"Error from p1\");  \nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, \"Success from p2\"));  \nconst p3 = Promise.reject(\"Error from p3\");  \n  \n  \n  \n// Если p2 завершается первым, результат - \"Success from p2\"  \nany([p1, p2, p3])  \n    .then((result) => console.log(\"Resolved with:\", result))  \n    .catch((error) => console.error(\"Rejected with:\", error)); // Ожидаемый вывод: \"Resolved with: Success from p2\"  \n  \n  \n// Пример, когда все промисы отклоняются  \nany([p1, Promise.reject(\"Error from p2\"), p3])  \n    .then((result) => console.log(\"Resolved with:\", result))  \n    .catch((error) => {  \n        console.error(\"Rejected with AggregateError:\", error);  \n    });",
      "code_language": "js",
      "code_lines": 35,
      "complexity_score": 3.5,
      "difficulty_factors": [
        "Средний код (35 строк)",
        "Глубокая вложенность (5)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises",
        "array_forEach"
      ],
      "keywords": [
        "resolve",
        "counter",
        "settimeout",
        "catch",
        "foreach",
        "reject",
        "error",
        "any",
        "then",
        "errors",
        "result",
        "promise",
        "aggregateerror",
        "promises"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 97,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 13,
      "pedagogical_type": "example",
      "text_complexity": 1.69,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyda004thxt88zlcfy7p",
      "title": "15. Valid Parentheses",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Проверка корректности скобок (Valid Parentheses)\nРеализуйте функцию, которая проверяет, является ли строка корректной последовательностью скобок.\\n",
      "code_content": "\nfunction isValid(s) {  \n    const stack = [];  \n    const mapping = {  \n        ')': '(',  \n        '}': '{',  \n        ']': '[',  \n    };  \n  \n    for (let char of s) {  \n        if (char in mapping) {  \n            if (stack.pop() !== mapping[char]) {  \n                return false;  \n            }  \n        } else {  \n            stack.push(char);  \n        }  \n    }  \n    return stack.length === 0;  \n}\n",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 4.0,
      "difficulty_factors": [
        "Средняя вложенность (4)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "parentheses",
        "isvalid",
        "mapping",
        "valid",
        "stack",
        "char"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 40,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 14,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxij0047hxt8eu8p0tk0",
      "title": "15. withRetry",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте асинхронную функцию withRetry, которая выполняет HTTP-запрос с повторными попытками в случае неудачи. Функция должна принимать следующие параметры:\\nurl — адрес запроса.options — объект с дополнительными параметрами для запроса (по умолчанию пустой объект).maxAttempts — максимальное количество попыток выполнения запроса (по умолчанию 3).\\nТребования к реализации:\\nФункция должна пытаться выполнить запрос с помощью fetch до тех пор, пока не получит успешный ответ ил...",
      "code_content": "withRetry(\"https://api.example.com/fake-endpoint\")\n    .then(response => response.json())\n    .then(data => console.log(\"Полученные данные:\", data))\n    .catch(error => console.error(\"Ошибка после повторных попыток:\", error.message));",
      "code_language": "js",
      "code_lines": 4,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "withretry",
        "fetch",
        "message",
        "nurl",
        "response",
        "options",
        "error",
        "http",
        "maxattempts",
        "url"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 67,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 14,
      "pedagogical_type": "example",
      "text_complexity": 1.42,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxja0048hxt8v4ipmslc",
      "title": "16. parallel",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию parallel, которая принимает два параметра:\\nfuncArray — массив функций, каждая из которых ожидает коллбэк и асинхронно возвращает некоторый результат через этот коллбэк.doneAll — функция-обработчик, которая вызывается после завершения всех функций из funcArray и получает массив результатов.\\nТребования:\\nВсе функции из funcArray должны выполняться параллельно.Каждый результат должен сохраняться в массиве results на той же позиции, что и функция в исходном м...",
      "code_content": "const a = done => {\n    setTimeout(() => {\n        done('result a');\n    }, 300);\n};\n\nconst b = done => {\n    setTimeout(() => {\n        done('result b');\n    }, 200);\n};\n\nparallel([a, b], results => {\n    console.log(results); // ['result a', 'result b']\n});",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "destructuring",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "done",
        "settimeout",
        "nfuncarray",
        "parallel",
        "doneall",
        "funcarray",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 58,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 15,
      "pedagogical_type": "example",
      "text_complexity": 1.03,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxk10049hxt8swobackx",
      "title": "17. fetchDataWithRetry",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте асинхронную функцию fetchDataWithRetry, которая выполняет HTTP-запрос с повторными попытками в случае ошибки. Функция должна принимать следующие параметры:\\nurl — адрес запроса.maxRetries — максимальное количество повторных попыток (по умолчанию 5).initialDelay — начальная задержка перед первой повторной попыткой (по умолчанию 1000 мс).\\nЛогика работы функции:\\nПопытаться выполнить запрос по указанному URL с помощью fetch.Если ответ не успешен (проверка response.ok...",
      "code_content": "fetchDataWithRetry('https://api.example.com/data')\n    .then(data => {\n        console.log('Received data:', data);\n    })\n    .catch(error => {\n        console.error('Error:', error.message);\n    });\n",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "url",
        "maxretries",
        "fetch",
        "message",
        "initialdelay",
        "nurl",
        "data",
        "response",
        "json",
        "error",
        "http",
        "fetchdatawithretry",
        "received",
        "api"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 70,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 16,
      "pedagogical_type": "example",
      "text_complexity": 1.47,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxkr004ahxt8dk4jo9nh",
      "title": "18. url limit",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию get, которая выполняет HTTP-запрос по заданному URL и возвращает данные в формате JSON. При возникновении ошибки (например, если HTTP-статус не является успешным), функция должна повторять запрос до достижения заданного лимита попыток.\\nТребования:\\nФункция принимает два параметра:url — адрес запроса.limit — максимальное число попыток выполнить запрос.При каждом вызове fetch:Если ответ успешен (response.ok === true), функция должна преобразовать его в JSON ...",
      "code_content": "get('https://example.com/data', 5)\n    .then(res => console.log(res))\n    .catch(err => console.error(err));",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "async",
        "arrow_functions",
        "error_handling",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "res",
        "fetch",
        "catch",
        "response",
        "json",
        "limit",
        "error",
        "http",
        "then",
        "get",
        "url",
        "https",
        "err"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 57,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 17,
      "pedagogical_type": "example",
      "text_complexity": 1.14,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxli004bhxt85icwha27",
      "title": "19. parallelLimit",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию parallelLimit, которая осуществляет параллельное выполнение HTTP-запросов по заданным URL с ограничением на максимальное число одновременно выполняемых запросов. Функция должна:\\nПринимать следующие параметры:urls — массив URL для выполнения запросов.limit — максимальное количество одновременных запросов.callback — функция, которая вызывается после завершения всех запросов и получает массив результатов.Выполнять запросы параллельно, но не превышая указанное...",
      "code_content": "parallelLimit([\"https://example.com\", \"https://example.com\"], 2, console.log);",
      "code_language": "js",
      "code_lines": 1,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "parallellimit",
        "callback",
        "urls",
        "limit",
        "http",
        "url",
        "https",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 66,
      "target_skill_level": "beginner",
      "path_depth": 0,
      "order_in_file": 18,
      "pedagogical_type": "example",
      "text_complexity": 1.54,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxma004chxt8zpk2ktzi",
      "title": "20. parallelRequest",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию parallelRequest, которая принимает массив URL, ограничение на число одновременных запросов и коллбэк. Функция должна выполнять HTTP-запросы по указанным URL параллельно, но не более чем limit запросов одновременно, а затем возвращать результаты в виде массива в том же порядке, что и исходный список URL.\\nТребования:\\nПараметры функции:urls: массив URL, по которым нужно выполнить запросы.limit (по умолчанию 5): максимальное количество одновременно выполняемы...",
      "code_content": "parallelRequest([\"https://example.com/1\", \"https://example.com/2\"], 5, (results) => {\n    console.log(results); // Массив с результатами запросов\n});",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "destructuring",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "fetch",
        "callback",
        "urls",
        "limit",
        "http",
        "url",
        "https",
        "parallelrequest",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 71,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 19,
      "pedagogical_type": "example",
      "text_complexity": 1.55,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxxmy004dhxt8e9xo29me",
      "title": "21. requestBus",
      "category": "JS",
      "subcategory": "Promise",
      "path_titles": [],
      "text_content": "Постановка задачи:\\nРеализуйте функцию requestBus, которая выполняет асинхронные запросы к заданным конечным точкам (endpoints) с ограничением на число одновременных запросов. Функция должна:\\nПринимать следующие параметры:endpoints: массив URL (конечных точек) для выполнения HTTP-запросов.limit: максимальное количество одновременных запросов.callback: функция, которая будет вызвана после завершения всех запросов и получит массив результатов.Запускать запросы параллельно, но не более чем limit з...",
      "code_content": "requestBus([\"https://api.example.com/data1\", \"https://api.example.com/data2\"], 2, (results) => {\n    console.log(results);\n});",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "destructuring",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "requestbus",
        "fetch",
        "endpoints",
        "callback",
        "limit",
        "json",
        "http",
        "url",
        "https",
        "results"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 62,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 20,
      "pedagogical_type": "example",
      "text_complexity": 1.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy2v004fhxt8rplnk68y",
      "title": "1. string.prototype.greet",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Добавление метода greet в String.prototype\nНапишите метод greet для всех строк, который принимает строку-префикс и возвращает новую строку в формате \"префикс + исходная строка\".\\n",
      "code_content": "\n  \n// Задача: Написать метод `greet`, который должен вернуть `hello + <Строку у которой был вызван метод>`.  \n  \n  \nString.prototype.greet = function(prefix) {  \n    return `${prefix} ${this}`;  \n};  \n  \n  \n  \n// Ожидаемый вывод   \nconsole.log(\"Вася\".greet(\"hello\")); // \"hello Вася\"\n",
      "code_language": "js",
      "code_lines": 6,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "functions",
        "strings",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "string",
        "greet",
        "prototype",
        "prefix"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy3l004ghxt81t8b68uu",
      "title": "2. Reverse String",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Переворот строки (Reverse String)\nНапишите функцию, которая принимает массив символов и переворачивает его на месте.\\n",
      "code_content": "\n  \nfunction reverseString(s) {  \n    let left = 0;  \n    let right = s.length - 1;  \n  \n    while (left < right) {  \n        // Обмен местами элементов    \n[s[left], s[right]] = [s[right], s[left]];  \n        // Двигаемся к центру    \nleft++;  \n        right--;  \n    }  \n}  \n  \n// Примеры использования:    \nconst s1 = [\"h\", \"e\", \"l\", \"l\", \"o\"];  \nreverseString(s1);  \nconsole.log(s1);  \n  \n  \nconst s2 = [\"H\", \"a\", \"n\", \"n\", \"a\", \"h\"];  \n  \n  \nreverseString(s2);  \nconsole.log(s2);\n",
      "code_language": "js",
      "code_lines": 18,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "strings",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "reverse",
        "reversestring",
        "string",
        "right",
        "left"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy4b004hhxt85qfxts0l",
      "title": "3. Valid Anagram",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Проверка на анаграмму (Valid Anagram)\nРеализуйте функцию, которая проверяет, являются ли две строки анаграммами (содержат одинаковые буквы в разном порядке).\\n",
      "code_content": "\n  \n/**  \n * Проверка на анаграмму - решение с сортировкой * Сложность: O(n log n) */  \n  \nfunction isAnagramSort(s, t) {  \n    if (s.length !== t.length) return false;  \n  \n    // Сортируем обе строки и сравниваем    \nreturn s.split('').sort().join('') === t.split('').sort().join('');  \n}  \n  \n  \n/**  \n * Проверка на анаграмму - Map * Сложность: O(n) */  \n  \nfunction isAnagramMap(s, t) {  \n    if (s.length !== t.length) return false;  \n  \n    const map = new Map();  \n  \n    // Заполняем Map с подсчётом символов строки s    \nfor (let char of s) {  \n        map.set(char, (map.get(char) || 0) + 1);  \n    }  \n  \n    // Проверяем символы строки t с Map    \nfor (let char of t) {  \n        if (!map.has(char) || map.get(char) === 0) {  \n            return false;  \n        }  \n        map.set(char, map.get(char) - 1);  \n    }  \n  \n    return true;  \n}  \n  \n// Примеры использования:  const s1 = \"anagram\", t1 = \"nagaram\";  \nconst s2 = \"rat\", t2 = \"car\";  \n  \n  \nconsole.log(isAnagramSort(s1, t1)); // true  console.log(isAnagramSort(s2, t2)); // false    \n  \n  \nconst unicodeS = \"déjà vu\";  \nconst unicodeT = \"vu déjà\";  \n  \nconsole.log(isAnagramMap(unicodeS, unicodeT)); // true\n",
      "code_language": "js",
      "code_lines": 31,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (31 строк)",
        "Средняя вложенность (3)",
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "sorting",
        "regex",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "unicodes",
        "anagram",
        "map",
        "sort",
        "isanagrammap",
        "set",
        "get",
        "valid",
        "isanagramsort",
        "has",
        "unicodet",
        "char",
        "split",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 53,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy52004ihxt8ilxcs2u1",
      "title": "4. Valid Palindrome",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Проверка строки на палиндром (Valid Palindrome)\nНапишите функцию, которая проверяет, является ли строка палиндромом, игнорируя пробелы, знаки препинания и регистр.\\nдоп проверка на цифры\\n",
      "code_content": "\nconst isLetter = (char) => {  \n    return char.toLowerCase() !== char.toUpperCase();  \n};  \n  \nconst isPalindrome = (str) => {  \n  \n    let left = 0;  \n    let right = str.length - 1;  \n  \n    while (left < right) {  \n  \n        while (!isLetter(str[left])) left++;  \n        while (!isLetter(str[right])) right--;  \n  \n        if (str[left].toLowerCase() !== str[right].toLowerCase()) return false;  \n  \n        left++;  \n        right--;  \n  \n    }  \n  \n    return true;  \n};  \n  \n// Примеры использования  \nconst examples = [  \n    'Казак',  \n    `Madam, I'm Adam`,  \n    'А в Енисее - синева',  \n    'О, духи, от уборки микробу-то и худо',  \n    'Не палиндром'  \n];  \n  \nexamples.forEach(example => console.log(isPalindrome(example)));  \n  \n// Ожидаемый вывод: true, true, true, true, false\n\n",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средний код (25 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "arrow_functions",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_forEach"
      ],
      "keywords": [
        "touppercase",
        "palindrome",
        "madam",
        "tolowercase",
        "foreach",
        "ispalindrome",
        "right",
        "str",
        "char",
        "example",
        "valid",
        "left",
        "isletter",
        "examples"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 40,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.23,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy6j004khxt8qk16jmrn",
      "title": "6. Is Subsequence",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Является ли одна строка подпоследовательностью другой (Is Subsequence)\nНапишите функцию, которая определяет, является ли одна строка подпоследовательностью другой.\\n",
      "code_content": "/**  \n * Подход 1: Два указателя * Мы проходим по обеим строкам одновременно, используя два указателя. * Если символ в `s` совпадает с текущим символом в `t`, мы движемся вперёд в обеих строках. * Если символы не совпадают, движемся только в `t`. */  \n  \nfunction isSubsequenceTwoPointers(s, t) {  \n    let sIndex = 0;  \n    let tIndex = 0;  \n  \n    while (sIndex < s.length && tIndex < t.length) {  \n        if (s[sIndex] === t[tIndex]) {  \n            sIndex++;  \n        }  \n        tIndex++;  \n    }  \n  \n    return sIndex === s.length;  \n}  \n  \n/**  \n * Подход 2: Цикл for * Используем один указатель для строки `s` и проходим через строку `t`. * Если находим совпадающий символ, увеличиваем указатель строки `s`. */  \n  \nfunction isSubsequenceForLoop(s, t) {  \n    let sIndex = 0;  \n  \n    for (let i = 0; i < t.length && sIndex < s.length; i++) {  \n        if (s[sIndex] === t[i]) {  \n            sIndex++;  \n        }  \n    }  \n    return sIndex === s.length;  \n}  \n  \n  \nconsole.log(\"Using Two Pointers:\");  \n  \nconsole.log(isSubsequenceTwoPointers(\"abc\", \"ahbgdc\")); console.log(isSubsequenceTwoPointers(\"axc\", \"ahbgdc\"));  \n  \n  \nconsole.log(\"Using For Loop:\");  \n  \nconsole.log(isSubsequenceForLoop(\"abc\", \"ahbgdc\"));  \nconsole.log(isSubsequenceForLoop(\"axc\", \"ahbgdc\"));",
      "code_language": "js",
      "code_lines": 29,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (29 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "destructuring",
        "template_literals"
      ],
      "js_features_used": [],
      "keywords": [
        "sindex",
        "issubsequenceforloop",
        "tindex",
        "issubsequencetwopointers",
        "subsequence"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 42,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy7c004lhxt89e7olf1b",
      "title": "7. Length of Last Word",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Длина последнего слова в строке (Length of Last Word)\nРеализуйте функцию, которая принимает строку и возвращает длину последнего слова.\\n",
      "code_content": "\n/**  \n * Подход 1: Метод split * Разделяет строку на слова по пробелам и возвращает длину последнего слова. */  \nfunction lengthOfLastWordSplit(s) {  \n    const words = s.trim().split(' ');  \n    return words[words.length - 1].length;  \n}  \n  \n/**  \n * Подход 2: Обход строки с конца * Проходим по строке с конца, пока не найдем начало последнего слова. */  \nfunction lengthOfLastWordFromEnd(s) {  \n    let length = 0;  \n    let i = s.length - 1;  \n  \n    // Пропускаем конечные пробелы  \n    while (i >= 0 && s[i] === ' ') {  \n        i--;  \n    }  \n  \n    // Считаем длину последнего слова  \n    while (i >= 0 && s[i] !== ' ') {  \n        length++;  \n        i--;  \n    }  \n  \n    return length;  \n}  \n  \n  \nconsole.log(\"Using Split:\");  \n  \nconsole.log(lengthOfLastWordSplit(\"Hello World\"));            // Ожидаемый вывод: 5  \nconsole.log(lengthOfLastWordSplit(\"   fly me   to   the moon  \")); // Ожидаемый вывод: 4  \nconsole.log(lengthOfLastWordSplit(\"luffy is still joyboy\"));  // Ожидаемый вывод: 6  \n  \nconsole.log(\"Using From End:\");  \n  \nconsole.log(lengthOfLastWordFromEnd(\"Hello World\"));            // Ожидаемый вывод: 5  \nconsole.log(lengthOfLastWordFromEnd(\"   fly me   to   the moon  \")); // Ожидаемый вывод: 4  \nconsole.log(lengthOfLastWordFromEnd(\"luffy is still joyboy\"));  // Ожидаемый вывод: 6\n",
      "code_language": "js",
      "code_lines": 30,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средний код (30 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "strings",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "lengthoflastwordsplit",
        "lengthoflastwordfromend",
        "last",
        "words",
        "trim",
        "word",
        "split"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 39,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 0.19,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy8t004nhxt8zhgv3hm2",
      "title": "9. compress",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Сжатие строки (Compress)\nРеализуйте алгоритм сжатия строки, заменяя повторяющиеся символы на <количество повторов><символ>.\\n",
      "code_content": "\n// for  \nfunction compress(str) {  \n    let compressed = '';  \n    let count = 1;  \n  \n    for (let i = 0; i < str.length; i++) {  \n        if (str[i] === str[i + 1]) {  \n            // Если следующий символ совпадает с текущим, увеличиваем счетчик  \n            count++;  \n        } else {  \n            // Если символы не совпадают, добавляем текущий символ и его количество  \n            compressed += (count > 1 ? count : '') + str[i];  \n            count = 1; // Сбрасываем счетчик для нового символа  \n        }  \n    }  \n    return compressed;  \n}  \n  \n// reduce  \nfunction compressReduce(str) {  \n    return str.split('').reduce((compressed, char, i, arr) => {  \n        let count = 1;  \n  \n        // Считаем количество повторений текущего символа  \n        while (i + count < arr.length && char === arr[i + count]) {  \n            count++;  \n        }  \n  \n        if (count > 1) {  \n            compressed += count + char;  \n            arr.splice(i + 1, count - 1); // Удаляем повторяющиеся символы  \n        } else {  \n            compressed += char;  \n        }  \n  \n        return compressed;  \n    }, '');  \n}  \n  \n  \n// while  \n  \nfunction compressWhile(str) {  \n    let compressed = '';  \n    let i = 0;  \n  \n    while (i < str.length) {  \n        let count = 1;  \n  \n        // Подсчет повторяющихся символов  \n        while (i + 1 < str.length && str[i] === str[i + 1]) {  \n            count++;  \n            i++;  \n        }  \n  \n        compressed += (count > 1 ? count : '') + str[i];  \n        i++;  \n    }  \n  \n    return compressed;  \n}  \n  \n  \n  \n// recursive  \nfunction compressRecursive(str) {  \n    if (str.length === 0) return '';  \n  \n    let count = 1;  \n    let i = 1;  \n  \n    // Считаем количество повторений текущего символа  \n    while (i < str.length && str[i] === str[0]) {  \n        count++;  \n        i++;  \n    }  \n  \n    // Если повторяется больше одного раза, добавляем число и символ  \n    const compressedPart = (count > 1 ? count : '') + str[0];  \n  \n    // Рекурсивно обрабатываем оставшуюся часть строки  \n    return compressedPart + compressRecursive(str.slice(i));  \n}  \n  \n  \n  \nconsole.log(compress('AAA'));  \nconsole.log(compress('ABCBD'));  \nconsole.log(compress('AAABBOPP'));  \n  \nconsole.log(compressReduce('AAA'));  \nconsole.log(compressReduce('ABCBD'));  \nconsole.log(compressReduce('AAABBOPP'));  \n  \n  \n  \nconsole.log(compressWhile('AAA'));  \nconsole.log(compressWhile('ABCBD'));  \nconsole.log(compressWhile('AAABBOPP'))  \n  \nconsole.log(compressRecursive('AAA'));  \nconsole.log(compressRecursive('ABCBD'));  \nconsole.log(compressRecursive('AAABBOPP'));\n\n",
      "code_language": "js",
      "code_lines": 76,
      "complexity_score": 8.0,
      "difficulty_factors": [
        "Длинный код (76 строк)",
        "Средняя вложенность (3)",
        "Сложные концепции (1)",
        "Рекурсия"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "recursion",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "compressed",
        "slice",
        "compress",
        "reduce",
        "compressreduce",
        "count",
        "compresswhile",
        "arr",
        "splice",
        "str",
        "compressrecursive",
        "compressedpart",
        "char",
        "split"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 103,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.63,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxy9l004ohxt8vxpf2cah",
      "title": "10. compress 2",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "**Сжати\nНапишите функцию, которая принимает строку, содержащую повторяющиеся цифры, и заменяет их на <количество повторов>*<цифра>.\\n",
      "code_content": "\nна входе строка вида 111223334, на выходе 34294, пояснение : (1*3)(2*2)(3*3)(4*1)\n\n",
      "code_language": "js",
      "code_lines": 1,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [],
      "js_features_used": [],
      "keywords": [
        "compress"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 20,
      "target_skill_level": "beginner",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyab004phxt8e0cuwcew",
      "title": "11. uncompress",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Разжатие строки (Uncompress)\nРеализуйте функцию, которая принимает сжатую строку в формате \"3(ab)\" и восстанавливает исходную строку.\\n",
      "code_content": "\n// стэк  \nfunction uncompress(str) {  \n    const stack = [];  \n  \n    for (let i = 0; i < str.length; i++) {  \n        const char = str[i];  \n  \n        if (char === ')') {  \n            // Извлекаем символы до открывающей скобки '('  \n            let substr = '';  \n            while (stack[stack.length - 1] !== '(') {  \n                substr = stack.pop() + substr;  \n            }  \n            stack.pop(); // Удаляем '('  \n  \n            // Извлекаем количество повторений перед открывающей скобкой            let repeatCount = '';  \n            while (stack.length && !isNaN(stack[stack.length - 1])) {  \n                repeatCount = stack.pop() + repeatCount;  \n            }  \n  \n            // Повторяем подстроку необходимое количество раз и кладем обратно в стек  \n            stack.push(substr.repeat(Number(repeatCount)));  \n        } else {  \n            // Кладем символ в стек, включая цифры и скобки  \n            stack.push(char);  \n        }  \n    }  \n    // Объединяем все элементы в стеке в итоговую строку  \n    return stack.join('');  \n}  \n  \n  \n// рекурсия  \n  \nfunction uncompressRecursive(str) {  \n    const decompress = (s, index) => {  \n        let result = '';  \n        let repeatCount = '';  \n  \n        while (index < s.length) {  \n            const char = s[index];  \n  \n            if (!isNaN(char)) {  \n                // Строим число, представляющее количество повторений  \n                repeatCount += char;  \n            } else if (char === '(') {  \n                // Начинаем новую рекурсивную глубину для подстроки внутри скобок  \n                const [substr, newIndex] = decompress(s, index + 1);  \n                result += substr.repeat(Number(repeatCount));  \n                repeatCount = '';  \n                index = newIndex;  \n            } else if (char === ')') {  \n                // Завершаем текущую рекурсивную глубину  \n                return [result, index];  \n            } else {  \n                // Добавляем обычные символы  \n                result += char;  \n            }  \n            index++;  \n        }  \n  \n        return [result, index];  \n    };  \n  \n    // Инициализируем рекурсию с начальной строки и возвращаем результат  \n    return decompress(str, 0)[0];  \n}  \n  \n  \nconsole.log(uncompress('3(ab)'));  \nconsole.log(uncompress('3(ab2(c))'));  \n  \n  \nconsole.log(uncompressRecursive('3(ab)'));  \nconsole.log(uncompressRecursive('3(ab2(c))'));\n",
      "code_language": "js",
      "code_lines": 60,
      "complexity_score": 10.5,
      "difficulty_factors": [
        "Длинный код (60 строк)",
        "Средняя вложенность (4)",
        "Сложные концепции (1)",
        "Рекурсия",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "arrow_functions",
        "recursion",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring"
      ],
      "keywords": [
        "index",
        "uncompress",
        "isnan",
        "number",
        "newindex",
        "repeat",
        "substr",
        "result",
        "char",
        "repeatcount",
        "uncompressrecursive",
        "stack",
        "str",
        "decompress",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 103,
      "target_skill_level": "advanced",
      "path_depth": 0,
      "order_in_file": 10,
      "pedagogical_type": "exercise",
      "text_complexity": 0.16,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyb2004qhxt89kew43p2",
      "title": "12. sum",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Гибкая функция сложения\nСоздайте функцию sum, которая может складывать числа или объединять строки в зависимости от типа аргументов.\\n",
      "code_content": "\nfunction sum(...args) {  \n    if (typeof args[0] === 'string') {  \n        // If the first argument is a string, concatenate all arguments as strings.  \n        return args.join('');  \n    } else {  \n        let sum = 0;  \n        let i = 0;  \n        while (i < args.length && typeof args[i] === 'number') {  \n            sum += args[i];  \n            i++;  \n        }  \n        if (i < args.length) {  \n            // Convert the sum to a string and concatenate the remaining arguments as strings.  \n            return sum.toString() + args.slice(i).join('');  \n        }  \n        return sum;  \n    }  \n}  \n  \n// Test cases  \nconsole.log(sum(1, 2, 3));       // Output: 6  \nconsole.log(sum(1, 2, '3'));     // Output: '33'  \nconsole.log(sum('1', 2, 3));     // Output: '123'  \nconsole.log(sum(1, '2', 3));     // Output: '123'  \nconsole.log(sum(1, true, 3));    // Output: '1true3'  \nconsole.log(sum(null, 2, 3));    // Output: 'null23'\n",
      "code_language": "js",
      "code_lines": 25,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (25 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "sum",
        "slice",
        "tostring",
        "typeof",
        "args",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 40,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 11,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyeo004vhxt8agmhgbad",
      "title": "17. compress 2",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Сжатие строки 2\nРеализуйте функцию сжатия строки, где повторяющиеся символы заменяются на <символ><количество повторов>.\\n",
      "code_content": "\nfunction compressString(str) {  \n    if (!str) return '';  \n  \n    let result = '';  \n    let i = 0;  \n  \n    while (i < str.length) {  \n        let count = 1;  \n        while (i + count < str.length && str[i + count] === str[i]) {  \n            count++;  \n        }  \n        if (count === 1) {  \n            result += str[i];  \n        } else {  \n            result += str[i] + count;  \n        }  \n        i += count;  \n    }  \n  \n    return result;  \n}  \n  \n// Test cases  \nconsole.log(compressString('aaabbccdeefa')); // Output: 'a3b2c2de2fa2'  \nconsole.log(compressString('aaabbccdeef'));  // Output: 'a3b2c2de2f'  \nconsole.log(compressString('aaaaa'));        // Output: 'a5'  \nconsole.log(compressString('b'));            // Output: 'b'  \nconsole.log(compressString(''));             // Output: ''\n",
      "code_language": "js",
      "code_lines": 24,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "compress",
        "count",
        "result",
        "compressstring",
        "str"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 38,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 16,
      "pedagogical_type": "exercise",
      "text_complexity": 0.14,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyfe004whxt8qe3z3au4",
      "title": "18. compress 3",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Сжатие строки 3\nНапишите функцию, которая сжимает строку, ограничивая количество повторений одного символа девятью (9a).\\n",
      "code_content": "\nfunction compress(word) {  \n    let comp = '';  \n    let i = 0;  \n  \n    while (i < word.length) {  \n        let count = 1;  \n        let char = word[i];  \n        while (  \n            count < 9 &&  \n            i + count < word.length &&  \n            word[i + count] === char  \n            ) {  \n            count++;  \n        }  \n        comp += count.toString() + char;  \n        i += count;  \n    }  \n  \n    return comp;  \n}  \n  \n  \nconsole.log(compress('abcde'));              // Output: '1a1b1c1d1e'  \nconsole.log(compress('aaaaaaaaaaaaaabb'));   // Output: '9a5a2b'  \nconsole.log(compress('aaaaaaaaaa'));         // Output: '9a1a'\n",
      "code_language": "js",
      "code_lines": 21,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (21 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "strings",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "compress",
        "count",
        "tostring",
        "comp",
        "char",
        "word"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 36,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 17,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyg4004xhxt8kbhdl3ex",
      "title": "19. compress 4",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Сжатие строки 4\nРеализуйте алгоритм сжатия строки в массиве символов без использования дополнительной памяти.\\n",
      "code_content": "\nfunction compress(chars) {\n  let read = 0;\n  let write = 0;\n\n  while (read < chars.length) {\n    let currentChar = chars[read];\n    let count = 0;\n\n    while (read < chars.length && chars[read] === currentChar) {\n      read++;\n      count++;\n    }\n\n    chars[write++] = currentChar;\n\n    if (count > 1) {\n      for (let c of count.toString()) {\n        chars[write++] = c;\n      }\n    }\n  }\n\n  return write;\n}\n\n",
      "code_language": "js",
      "code_lines": 19,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (4)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "destructuring"
      ],
      "js_features_used": [],
      "keywords": [
        "write",
        "currentchar",
        "compress",
        "chars",
        "count",
        "tostring",
        "read"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 18,
      "pedagogical_type": "exercise",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxygu004yhxt81f1v2gsu",
      "title": "20. uncompress 2",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Разжатие строки 2\nНапишите функцию, которая принимает закодированную строку в формате \"3[a]2[bc]\" и разжимает её.\\n",
      "code_content": "\nfunction decodeString(s) {  \n    let numStack = [];  \n    let strStack = [];  \n    let currentNum = 0;  \n    let currentStr = '';  \n  \n    for (let char of s) {  \n        if (!isNaN(char)) {  \n            currentNum = currentNum * 10 + Number(char);  \n        } else if (char === '[') {  \n            numStack.push(currentNum);  \n            strStack.push(currentStr);  \n            currentNum = 0;  \n            currentStr = '';  \n        } else if (char === ']') {  \n            let repeatTimes = numStack.pop();  \n            let previousStr = strStack.pop();  \n            currentStr = previousStr + currentStr.repeat(repeatTimes);  \n        } else {  \n            currentStr += char;  \n        }  \n    }  \n    return currentStr;  \n}\n",
      "code_language": "js",
      "code_lines": 23,
      "complexity_score": 4.5,
      "difficulty_factors": [
        "Средний код (23 строк)",
        "Средняя вложенность (3)",
        "Структуры данных"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "strings"
      ],
      "js_features_used": [],
      "keywords": [
        "isnan",
        "number",
        "repeat",
        "numstack",
        "strstack",
        "currentnum",
        "currentstr",
        "repeattimes",
        "previousstr",
        "char",
        "decodestring",
        "uncompress"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 45,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 19,
      "pedagogical_type": "exercise",
      "text_complexity": 0.15,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyhk004zhxt8szdvzt2m",
      "title": "21. remove duplicates",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Удаление дублирующихся символов\nСоздайте функцию, которая удаляет подряд идущие повторяющиеся буквы из строки.\\n",
      "code_content": "\nfunction removeDuplicates(str) {  \n  \n    let result = '';  \n    let prevChar = '';  \n  \n    for (let char of str) {  \n        let charLower = char.toLowerCase();  \n        if (charLower !== prevChar) {  \n            result += char;  \n            prevChar = charLower;  \n        }  \n    }  \n    return result;  \n}  \n  \n  \nconsole.log(removeDuplicates('Ннуужжнноо ннааппиисаатьь ффунккциюю, которая ннааа вввходдд приинниимааеетт ссстррокууу иии воозввраащааетт её ббезз лллишннннеегооо ддуубблиирррооованиияя ббукввв'));  \n  \n  \n// Ожидаемый вывод: \"Нужно написать функцию, которая на вход принимает строку и возвращает её без лишнего дублирования букв\"\n",
      "code_language": "js",
      "code_lines": 14,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "duplicates",
        "charlower",
        "tolowercase",
        "removeduplicates",
        "result",
        "remove",
        "str",
        "prevchar",
        "char"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 28,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 20,
      "pedagogical_type": "exercise",
      "text_complexity": 0.13,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxyib0050hxt84li1uu95",
      "title": "22. Longest Substring Without Repeating Characters",
      "category": "JS",
      "subcategory": "Strings",
      "path_titles": [],
      "text_content": "Поиск самой длинной подстроки без повторяющихся символов\nРеализуйте функцию, которая находит длину самой длинной подстроки без повторяющихся символов.\\n",
      "code_content": "\nfunction lengthOfLongestSubstring(s) {  \n    const charIndexMap = new Map();  \n    let maxLength = 0;  \n    let windowStart = 0;  \n  \n    for (let windowEnd = 0; windowEnd < s.length; windowEnd++) {  \n        const rightChar = s[windowEnd];  \n  \n        if (charIndexMap.has(rightChar) && charIndexMap.get(rightChar) >= windowStart) {  \n            windowStart = charIndexMap.get(rightChar) + 1;  \n        }  \n  \n        charIndexMap.set(rightChar, windowEnd);  \n        maxLength = Math.max(maxLength, windowEnd - windowStart + 1);  \n    }  \n  \n    return maxLength;  \n}\n",
      "code_language": "js",
      "code_lines": 14,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "strings",
        "functional"
      ],
      "js_features_used": [],
      "keywords": [
        "max",
        "substring",
        "charindexmap",
        "windowstart",
        "without",
        "lengthoflongestsubstring",
        "maxlength",
        "map",
        "repeating",
        "longest",
        "characters",
        "math",
        "has",
        "get",
        "set",
        "rightchar",
        "windowend"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 21,
      "pedagogical_type": "exercise",
      "text_complexity": 0.18,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxz0l0052hxt84b9954qa",
      "title": "1. sum",
      "category": "JS",
      "subcategory": "Test",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Напишите функцию sum, которая принимает массив чисел, в том числе содержащий вложенные массивы, и возвращает сумму всех чисел в массиве. Для решения задачи используйте рекурсию для обработки вложенных массивов.\\n",
      "code_content": "function sum(arr) {  \n    return arr.reduce((total, item) => {  \n        if (Array.isArray(item)) {  \n            return total + sum(item); // рекурсивно суммируем вложенные массивы  \n        }  \n        return total + item; // добавляем число к общей сумме  \n    }, 0);  \n}  \n  \n// Пример использования  \nconsole.log(sum([1, 1, 1, [2, 1], [1, [1, [1], 3]]])); // Вернет 12",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "functions",
        "conditionals",
        "arrays",
        "arrow_functions",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_reduce"
      ],
      "keywords": [
        "sum",
        "item",
        "reduce",
        "total",
        "array",
        "isarray",
        "arr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxz1a0053hxt8d5i3kzex",
      "title": "2. findMinMax",
      "category": "JS",
      "subcategory": "Test",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию, которая принимает массив чисел и возвращает объект, содержащий минимальное и максимальное значение из этого массива.\\nИнициализируйте переменные min и max первым элементом массива.Пройдите по массиву начиная со второго элемента и сравните каждый элемент с текущими значениями min и max.Если текущий элемент меньше min, обновите значение min.Если текущий элемент больше max, обновите значение max.Верните объект с ключами min и max, содержащими найденные значения...",
      "code_content": "function (arr) {\n    let min = arr[0];\n    let max = arr[0];\n\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    return { min, max };\n}",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops"
      ],
      "js_features_used": [],
      "keywords": [
        "max",
        "min",
        "arr",
        "findminmax"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 47,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.64,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxz200054hxt8dg7mgp5i",
      "title": "3. removeEvenIndexedElements",
      "category": "JS",
      "subcategory": "Test",
      "path_titles": [
        "Очень простые (базовые операции и манипуляции)"
      ],
      "text_content": "Постановка задачи:Реализуйте функцию removeEvenIndexedElements, которая принимает массив и удаляет из него элементы, находящиеся на чётных индексах. Итоговый массив должен содержать только элементы, расположенные на нечётных позициях (индексация начинается с нуля).\\nОбходите массив в обратном порядке, чтобы избежать проблем с изменением индексов при удалении элементов.Для каждого элемента проверяйте, является ли его индекс чётным.Если индекс чётный, удаляйте элемент из массива с помощью метода s...",
      "code_content": "const removeEvenIndexedElements = (arr) => {  \n    for (let i = arr.length - 1; i >= 0; i--) {  \n        if (i % 2 === 0) {  \n            arr.splice(i, 1);  \n        }  \n    }    \n    return arr;  \n};  \n  \nconst data = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"];  \n  \nconsole.log(removeEvenIndexedElements(data)); // [\"B\", \"D\", \"F\", \"H\", \"J\"]",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "loops",
        "arrays",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "splice",
        "arr",
        "data",
        "removeevenindexedelements"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 49,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.68,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzft0056hxt82bi31hkb",
      "title": "1. Функция возвращает другую функцию, которая всегда возвращает строку \"HelloWorld\"",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Создайте функцию, которая при вызове возвращает другую функцию. Эта вложенная функция должна принимать любые аргументы, но неизменно возвращать строку \"HelloWorld\".\\n",
      "code_content": "\nfunction HelloWorld() {\n\treturn function (...args) {\n\treturn 'HelloWorld'\n\t} \n}\n\n\nconst fn = HelloWorld()\nconsole.log(fn())",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "spread_operator"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "args",
        "helloworld"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 0,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzgj0057hxt8kld412kw",
      "title": "2. Функция, ограничивающая количество положительных ответов",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Напишите функцию canGetCount(n), которая принимает число n и возвращает новую функцию. Эта вложенная функция при вызове n раз возвращает 'yes', а затем всегда 'no'.\\n",
      "code_content": "function canGetCount(n:number) {  \n    let count = 0  \n    return () => {  \n        if (count < n) {  \n            count++  \n            return 'no'  \n        } else {  \n            return 'yes'  \n        }  \n    }}  \n  \nconst a = canGetCount(2)  \n  \nconsole.log(a())  \nconsole.log(a())  \nconsole.log(a())  \nconsole.log(a())",
      "code_language": "js",
      "code_lines": 15,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "cangetcount",
        "count",
        "number"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 35,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 1,
      "pedagogical_type": "exercise",
      "text_complexity": 0.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzh80058hxt8fniuwvqj",
      "title": "3. Функция для вывода значения счётчика при достижении заданного предела",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Создайте функцию, принимающую число maxIncrementNumber. Она должна возвращать другую функцию, которая увеличивает внутренний счётчик и выводит его значение в консоль при достижении maxIncrementNumber.\\n",
      "code_content": "const callback = (maxIncrementNumber) => {  \n    let count = 0;  \n    return () => {  \n        count++  \n        if (count === maxIncrementNumber) console.log(count)  \n    }  \n}  \n  \nconst cb = callback(4);  \n  \ncb();  \ncb();  \ncb();  \ncb();",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "callback",
        "count",
        "maxincrementnumber"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 30,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 2,
      "pedagogical_type": "exercise",
      "text_complexity": 0.23,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzhy0059hxt81zfgzhi4",
      "title": "4. Функция-счётчик, увеличивающая значение при каждом вызове",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Реализуйте функцию createCounter(n), которая принимает число n и возвращает другую функцию. Эта вложенная функция при каждом вызове увеличивает значение счётчика и возвращает его.\\n",
      "code_content": "function createCounter(n: number): () => number {  \n    let count = n  \n    console.log(count)  \n    return () => count++  \n}  \n  \n  \nconst counter = createCounter(10)  \nconsole.log(counter())  \nconsole.log(counter())  \nconsole.log(counter())",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "createcounter",
        "counter",
        "count",
        "number"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 28,
      "target_skill_level": "beginner",
      "path_depth": 0,
      "order_in_file": 3,
      "pedagogical_type": "exercise",
      "text_complexity": 0.23,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1060064hxt8qznw71e2",
      "title": "Таймер + счетчик",
      "category": "REACT",
      "subcategory": "Refactor",
      "path_titles": [
        "Рефакторинг Мини-Задач",
        "2. IT-One"
      ],
      "text_content": "",
      "code_content": "function Clicker() {\n  const [clicks, setClicks] = useState(0);\n  const timerRef = useRef(null);\n\n  const onClick = useCallback(() => {\n    if (timerRef.current) clearTimeout(timerRef.current);\n    timerRef.current = setTimeout(() => {\n      setClicks((prevClicks) => prevClicks + 1);\n    }, 2000);\n  }, []);\n\n  useEffect(() => () => clearTimeout(timerRef.current), []);\n\n  return <button onClick={onClick}>{clicks}</button>;\n}",
      "code_language": "js",
      "code_lines": 12,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "destructuring",
        "arrow_functions",
        "events"
      ],
      "js_features_used": [
        "arrow_functions",
        "array_destructuring"
      ],
      "keywords": [
        "button",
        "clicks",
        "usestate",
        "cleartimeout",
        "settimeout",
        "usecallback",
        "useref",
        "setclicks",
        "onclick",
        "timerref",
        "current",
        "clicker",
        "prevclicks",
        "useeffect"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 24,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 14,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzje005bhxt8zhktsovs",
      "title": "6. Функция-счётчик с методами инкремента, декремента и сброса",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Создайте функцию createCounter(init), которая принимает начальное значение init и возвращает объект с методами:\\nincrement() – увеличивает текущее значение счётчика на 1 и возвращает его,decrement() – уменьшает текущее значение счётчика на 1 и возвращает его,reset() – сбрасывает значение счётчика к начальному init и возвращает его.\\n",
      "code_content": "type Counter = {  \n    increment: () => number,  \n    decrement: () => number,  \n    reset: () => number,  \n}  \n  \nfunction createCounter(init: number): Counter {  \n    let presentCount = init  \n  \n    function increment() {  \n        return ++presentCount;  \n    }  \n  \n    function decrement() {  \n        return --presentCount;  \n    }  \n  \n    function reset() {  \n        return presentCount = init  \n    }  \n  \n    return { increment, decrement, reset };  \n}  \n  \n  \n  \nconst counter = createCounter(10)  \n  \n  \n  \nconsole.log(counter.increment()); // 6  \nconsole.log(counter.reset()); // 5  \nconsole.log(counter.decrement()); // 4",
      "code_language": "js",
      "code_lines": 22,
      "complexity_score": 1.5,
      "difficulty_factors": [
        "Средний код (22 строк)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "createcounter",
        "reset",
        "nincrement",
        "number",
        "decrement",
        "counter",
        "type",
        "increment",
        "presentcount",
        "init"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 46,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 5,
      "pedagogical_type": "exercise",
      "text_complexity": 0.43,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzk5005chxt8jwkhfvzo",
      "title": "7. Функция для создания массива функций, возвращающих свой индекс",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Создайте функцию createFunctionArray(), которая создаёт массив функций. Каждая функция должна возвращать свой индекс в массиве при вызове.\\n",
      "code_content": "function createFunctionArray() {  \n    const functionsArray = [];  \n  \n    for (let i = 0; i < 10; i++) {  \n        functionsArray[i] = function() {  \n            return i;  \n        };  \n    }  \n  \n    return functionsArray;  \n}  \n  \nconst functionArray = createFunctionArray();  \n  \nconsole.log(functionArray[0]()); // Вывод: 0  \nconsole.log(functionArray[1]()); // Вывод: 1  \nconsole.log(functionArray[2]()); // Вывод: 2",
      "code_language": "js",
      "code_lines": 13,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "destructuring",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "functionarray",
        "createfunctionarray",
        "functionsarray"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 6,
      "pedagogical_type": "exercise",
      "text_complexity": 0.17,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzkv005dhxt8tktsk6gn",
      "title": "8. Функция-замыкание с автоматическим увеличением счётчика",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Создайте самовызывающееся замыкание, в котором переменная counter увеличивается при каждом вызове функции count().\\n",
      "code_content": "\nconst count = (function () {\n    let counter = 0;\n    return function () {\n        return console.log(++counter);\n    };\n})();\n\ncount(); // 1\ncount(); // 2\n\n",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "counter",
        "count"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 23,
      "target_skill_level": "beginner",
      "path_depth": 0,
      "order_in_file": 7,
      "pedagogical_type": "exercise",
      "text_complexity": 0.63,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzll005ehxt8u58l0k80",
      "title": "9. Функция-счётчик с сохранением состояния",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Напишите функцию makeCounter(initialValue), которая создаёт счётчик с начальным значением initialValue. Возвращаемая функция должна увеличивать значение на 1 при каждом вызове.\\n",
      "code_content": "\nconst makeCounter = (initialValue) => {  \n    let result = initialValue  \n    return () => {  \n        result += 1  \n        return result  \n    }  \n}  \nconst counterB = makeCounter(100);  \n  \nconsole.log(counterB()); // 101\n",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "counterb",
        "makecounter",
        "initialvalue",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 27,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 8,
      "pedagogical_type": "exercise",
      "text_complexity": 0.2,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuxzmn005fhxt8vw0ljp0t",
      "title": "10. Каррированная функция для суммирования чисел",
      "category": "JS",
      "subcategory": "Zamiki",
      "path_titles": [],
      "text_content": "Реализуйте функцию add(sum), которая возвращает новую функцию. Эта функция должна продолжать принимать аргументы, пока не встретится undefined, после чего вернуть сумму всех переданных чисел.\\n",
      "code_content": "\nconst add = (sum) => (nextNum) => nextNum !== undefined ? add(sum + nextNum) : sum;\n  \nconst ad = add(4);  \n  \nconsole.log(ad(5)()); // 9\n",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "nextnum",
        "sum",
        "add"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "intermediate",
      "path_depth": 0,
      "order_in_file": 9,
      "pedagogical_type": "exercise",
      "text_complexity": 0.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1n2006bhxt89i7z4fpq",
      "title": "Разбор:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "1. Иннотех"
      ],
      "text_content": "В коде есть useEffect и useLayoutEffect, которые выполняются в разное время.Последовательность выполнения на первом рендере:\\nПри каждом клике (setCount) произойдет ререндер и перед effect-хук вызовутся cleanup:\\n\\n",
      "code_content": "render App\nrender A\nrender B\nlayout effect A\nlayout effect B\nlayout effect App\neffect A\neffect B\neffect App",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [],
      "js_features_used": [],
      "keywords": [
        "setcount",
        "effect",
        "cleanup",
        "uselayouteffect",
        "app",
        "layout",
        "useeffect",
        "render"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 27,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "practice",
      "text_complexity": 0.25,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1oj006dhxt8hs4zuobs",
      "title": "Что в консоли:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "2. Tele2"
      ],
      "text_content": "",
      "code_content": "A\nB\nC\nD\nA",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [],
      "js_features_used": [],
      "keywords": [],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 17,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 3,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1pz006fhxt827vdomq8",
      "title": "Что в консоли при изменении state (0 → 1 → 2)?",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "3. IBS"
      ],
      "text_content": "",
      "code_content": "useEffect(() => {\n  console.log(state)\n  return () => {\n    console.log(state)\n  }\n}, [state]);",
      "code_language": "js",
      "code_lines": 6,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "state",
        "useeffect"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 18,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 5,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1qp006ghxt8kwicddvy",
      "title": "Ответ:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "3. IBS"
      ],
      "text_content": "Разбор:\\nuseEffect выполняется после рендера.Перед новым значением вызывается cleanup, который использует предыдущее значение state.\\n\\n",
      "code_content": "0   // Первый рендер (state = 0)\n0   // Очистка перед обновлением (state = 1)\n1   // Новый эффект после обновления на state = 1\n1   // Очистка перед обновлением (state = 2)\n2   // Новый эффект после обновления на state = 2",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "nuseeffect",
        "state",
        "cleanup"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 21,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 6,
      "pedagogical_type": "practice",
      "text_complexity": 0.13,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1rf006hhxt8rnl5bawz",
      "title": "Композитные компоненты",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "3. IBS"
      ],
      "text_content": "",
      "code_content": "console.log(1);\nconsole.log(3);\n\nuseEffect(() => {\n  console.log(2);\n}, []);\n\nuseEffect(() => {\n  console.log(4);\n}, []);",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrays",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "useeffect"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 19,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 7,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1s5006ihxt80rls5703",
      "title": "Вывод в консоли:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "3. IBS",
        "Композитные компоненты"
      ],
      "text_content": "1, 3 – при первом рендере2, 4 – при выполнении useEffect после рендера\\n\\n",
      "code_content": "1\n3\n2\n4",
      "code_language": "js",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [],
      "js_features_used": [],
      "keywords": [
        "useeffect"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 21,
      "target_skill_level": "beginner",
      "path_depth": 2,
      "order_in_file": 8,
      "pedagogical_type": "practice",
      "text_complexity": 0.13,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1su006jhxt8xroiozoa",
      "title": "Сколько ререндеров?",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "4. РСХБ"
      ],
      "text_content": "",
      "code_content": "const handleClick = () => {\n  setCount(count + 1);\n  setCount(count + 1);\n  setCount(count + 1);\n};",
      "code_language": "js",
      "code_lines": 5,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "setcount",
        "count",
        "handleclick"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 18,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 9,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1u9006lhxt846p6ztwv",
      "title": "Усложнение (с setTimeout)",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "4. РСХБ"
      ],
      "text_content": "",
      "code_content": "const handleClick = () => {\n  setCount(count + 1);\n  setTimeout(() => {\n    setCount(count + 1);\n  }, 1000);\n  setCount(count + 1);\n};",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "settimeout",
        "setcount",
        "count",
        "handleclick"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 19,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 11,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1ux006mhxt8ar2iyqhv",
      "title": "Что в консоли?",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "4. РСХБ",
        "Усложнение (с setTimeout)"
      ],
      "text_content": "",
      "code_content": "Rendered  // Первый рендер\nRendered  // После первого и третьего setCount\nRendered  // После setTimeout",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "rendered"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 16,
      "target_skill_level": "beginner",
      "path_depth": 2,
      "order_in_file": 12,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1vt006nhxt84uadv93e",
      "title": "Оптимизированный вариант (через useRef)",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "4. РСХБ",
        "Усложнение (с setTimeout)"
      ],
      "text_content": "\\n",
      "code_content": "const timeoutRef = useRef(null);\nconst handleClick = () => {\n  if (timeoutRef.current) clearTimeout(timeoutRef.current);\n\n  setCount((prev) => prev + 1);\n  setCount((prev) => prev + 1);\n\n  timeoutRef.current = setTimeout(() => {\n    setCount((prev) => prev + 1);\n  }, 1000);\n};",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "setcount",
        "timeoutref",
        "handleclick",
        "cleartimeout",
        "settimeout",
        "prev",
        "useref",
        "current"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 20,
      "target_skill_level": "intermediate",
      "path_depth": 2,
      "order_in_file": 13,
      "pedagogical_type": "practice",
      "text_complexity": 0.01,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1wj006ohxt8lcm8jv4e",
      "title": "1. Что будет в Clicker?",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name"
      ],
      "text_content": "",
      "code_content": "setTimeout(() => {\n  setClicks(clicks + 1);\n}, 200);",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "setclicks",
        "clicker",
        "settimeout",
        "clicks"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 17,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 14,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1x6006phxt8or6px97n",
      "title": "Ответ:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name",
        "1. Что будет в Clicker?"
      ],
      "text_content": "clicks всегда будет увеличиваться на 1, даже если нажимать быстро.Причина: setClicks(clicks + 1) берет clicks из замыкания (старое значение).\\n✅ Исправленный вариант (чтобы обновлялось корректно):\\n\\n",
      "code_content": "setTimeout(() => {\n  setClicks((prev) => prev + 1);\n}, 200);",
      "code_language": "js",
      "code_lines": 3,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "setclicks",
        "settimeout",
        "prev",
        "clicks"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "beginner",
      "path_depth": 2,
      "order_in_file": 15,
      "pedagogical_type": "practice",
      "text_complexity": 0.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1xu006qhxt86kgv30xl",
      "title": "2. Последовательность логов",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name"
      ],
      "text_content": "",
      "code_content": "console.log(1);\n\nuseLayoutEffect(() => {\n  console.log(5);\n  setState((state) => state + 1);\n}, []);\n\nuseEffect(() => {\n  console.log(2);\n}, [state]);\n\nPromise.resolve().then(() => console.log(3));\n\nsetTimeout(() => console.log(4), 0);",
      "code_language": "js",
      "code_lines": 10,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrays",
        "async",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions",
        "promises"
      ],
      "keywords": [
        "resolve",
        "useeffect",
        "settimeout",
        "then",
        "uselayouteffect",
        "promise",
        "state",
        "setstate"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 21,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 16,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1yj006rhxt8mx0awegy",
      "title": "Ответ в консоли:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name",
        "2. Последовательность логов"
      ],
      "text_content": "\\n",
      "code_content": "1  // Первый рендер\n5  // useLayoutEffect\n2  // useEffect после первого рендера\n1  // Второй рендер (из-за setState)\n2  // useEffect после второго рендера\n3  // Promise (микрозадача)\n4  // setTimeout (макрозадача)\n4  // setTimeout (повторная макрозадача)",
      "code_language": "js",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "async",
        "regex"
      ],
      "js_features_used": [
        "promises"
      ],
      "keywords": [],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 19,
      "target_skill_level": "advanced",
      "path_depth": 2,
      "order_in_file": 17,
      "pedagogical_type": "practice",
      "text_complexity": 0.01,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1z9006shxt84an8bb1h",
      "title": "3. Последовательность логов",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name"
      ],
      "text_content": "",
      "code_content": "console.log(1);\n\nuseEffect(() => {\n  console.log(2);\n  return () => {\n    console.log(3);\n  };\n}, [count]);\n\nuseEffect(() => {\n  console.log(4);\n  setCount((count) => count + 1);\n}, []);",
      "code_language": "js",
      "code_lines": 11,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrays",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "useeffect",
        "setcount",
        "count"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 21,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 18,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy1zw006thxt87fseef70",
      "title": "Ответ в консоли:",
      "category": "REACT",
      "subcategory": "Rerender",
      "path_titles": [
        "5. Тренировочные No Name",
        "3. Последовательность логов"
      ],
      "text_content": "",
      "code_content": "1  // Первый рендер\n5  // `Child` useEffect\n2  // `useEffect` компонента\n4  // `setCount`, инициирующий ререндер\n1  // Второй рендер (из-за `setCount`)\n6  // Очистка `Child` useEffect (count обновился)\n3  // Очистка `useEffect` (count обновился)\n5  // `Child` useEffect снова\n2  // `useEffect` снова",
      "code_language": "js",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "template_literals",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 19,
      "target_skill_level": "beginner",
      "path_depth": 2,
      "order_in_file": 19,
      "pedagogical_type": "practice",
      "text_complexity": 0.0,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2iu006vhxt89nmcbbrz",
      "title": "1. Тип функции",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить обобщенный тип Func<T, K>, описывающий функцию, которая принимает объект T и ключ K, принадлежащий keyof T. Функция должна возвращать значение свойства K объекта T, а его тип должен соответствовать T[K]. Также требуется убедиться, что ReturnType<Func<T, K>> корректно выводит ожидаемый тип.\\n",
      "code_content": "// ReturnType<Func>\ntype Func<T, K extends keyof T> = (a: T, b: K) => T[K];  \ntype T1 = ReturnType<Func<{ a: number; b: string }, 'a'>>;  \n// Возвращаемый тип 'number'\n\nconst getValue: Func<{ a: number; b: string }, 'a'> = (obj, key) => obj[key];  \nconst obj1 = { a: 42, b: \"hello\" };  \nconst value: T1 = getValue(obj1, 'a'); // value = 42 ",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "inheritance"
      ],
      "keywords": [
        "getvalue",
        "key",
        "returntype",
        "obj",
        "number",
        "keyof",
        "value",
        "func",
        "type",
        "string"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 0,
      "pedagogical_type": "practice",
      "text_complexity": 0.43,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2jm006whxt8qj3a708h",
      "title": "2. Тип параметров",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить обобщенный тип T2, который представляет параметры функции Func<T, K> в виде кортежа. Функция принимает объект T и ключ K, принадлежащий keyof T, а кортеж параметров должен иметь структуру [T, K]. Требуется проверить, что использование Parameters<Func<T, K>> правильно формирует ожидаемый кортеж параметров.\\n",
      "code_content": "// Parameters<Func>  \n  \ntype T2 = Parameters<Func<{ a: number; b: string }, 'a'>>;  \n// Параметры функции кортеж: [{ a: number; b: string }, 'a']  \n  \nconst params: T2 = [{ a: 42, b: \"world\" }, 'a'];  \nconst result: T1 = getValue(...params); // result = 42  ",
      "code_language": "ts",
      "code_lines": 5,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "strings",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "getvalue",
        "parameters",
        "number",
        "keyof",
        "func",
        "type",
        "string",
        "result",
        "params"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 32,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "practice",
      "text_complexity": 0.44,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2kb006xhxt8u1i17kpa",
      "title": "3. Исключение свойства",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить новый тип T3, который представляет собой объект, полученный из исходного типа путем исключения одного из его свойств. Для этого используется утилита Omit<T, K>, которая удаляет указанное свойство K из объекта T. Требуется проверить, что после исключения свойства объект сохраняет оставшиеся ключи с их исходными типами.\\n",
      "code_content": "// Omit  \n  \ntype T3 = Omit<{ a: number; b: string; c: boolean }, 'b'>;  \n// Убираем 'b', остается: { a: number; c: boolean }  \n  \nconst obj3: T3 = { a: 10, c: true }; // b исключён  ",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "omit",
        "number",
        "type",
        "string",
        "boolean"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 33,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 2,
      "pedagogical_type": "practice",
      "text_complexity": 0.48,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2l1006yhxt8catnrduz",
      "title": "4. Выбор свойств",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить новый тип T4, который включает только выбранные свойства из исходного объекта. Для этого используется утилита Pick<T, K>, которая формирует новый объект, содержащий только указанные в K ключи из T. Требуется проверить, что после выбора свойств объект сохраняет их исходные типы.\\n",
      "code_content": "// Pick  \n  \ntype T4 = Pick<{ a: number; b: string; c: boolean }, 'a' | 'c'>;  \n// Выбираем только 'a' и 'c': { a: number; c: boolean }  \n  \nconst obj4: T4 = { a: 100, c: false }; // Только a и c  ",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "number",
        "pick",
        "type",
        "string",
        "boolean"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 31,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 3,
      "pedagogical_type": "practice",
      "text_complexity": 0.43,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2lo006zhxt8yh97zy0d",
      "title": "5. Необязательные свойства",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить новый тип T5, в котором все свойства исходного объекта становятся необязательными. Для этого используется утилита Partial<T>, которая преобразует каждое свойство объекта T в необязательное, добавляя к нему модификатор ?. Требуется проверить, что объект может содержать любое подмножество исходных свойств, включая пустой объект.\\n",
      "code_content": "// Partial  \n  \ntype T5 = Partial<{ a: number; b: string }>;  \n// Все свойства необязательны: { a?: number; b?: string }  \n  \nconst obj5_1: T5 = {}; // Все свойства необязательны  \nconst obj5_2: T5 = { a: 1 }; // Только a  \nconst obj5_3: T5 = { b: \"test\" }; // Только b  ",
      "code_language": "ts",
      "code_lines": 6,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "objects",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "partial",
        "number",
        "type",
        "string"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 4,
      "pedagogical_type": "practice",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2me0070hxt8b1jxq7em",
      "title": "6. Обязательные свойства",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить новый тип T6, в котором все свойства исходного объекта становятся обязательными. Для этого используется утилита Required<T>, которая удаляет модификатор ? у всех свойств объекта T. Требуется проверить, что объект теперь должен содержать все изначально необязательные свойства.\\n",
      "code_content": "// Required  \n\ntype T6 = Required<{ a?: number; b?: string }>;  \n// Все свойства обязательны: { a: number; b: string }  \n  \nconst obj6: T6 = { a: 5, b: \"required\" }; // Все свойства обязательны\n\ntype Func<T, K extends keyof T> = (a: T, b: K) => T[K];\n\ntype T1 = ReturnType<Func<{ a: number; b: string }, 'a'>>; \n// Возвращаемый тип `Func` для ключа 'a' — это тип свойства 'a', т.е. number\n\ntype T2 = Parameters<Func<{ a: number; b: string }, 'a'>>; \n// Параметры функции `Func` — это кортеж типа [{ a: number; b: string }, 'a']\n\ntype T3 = Omit<{ a: number; b: string; c: boolean }, 'b'>; \n// `Omit` убирает ключ 'b', результат: { a: number; c: boolean }\n\ntype T4 = Pick<{ a: number; b: string; c: boolean }, 'a' | 'c'>; \n// `Pick` выбирает только 'a' и 'c', результат: { a: number; c: boolean }\n\ntype T5 = Partial<{ a: number; b: string }>; \n// `Partial` делает все свойства необязательными: { a?: number; b?: string }\n\ntype T6 = Required<{ a?: number; b?: string }>; \n// `Required` делает все свойства обязательными: { a: number; b: string }",
      "code_language": "ts",
      "code_lines": 17,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "strings",
        "classes",
        "modules",
        "arrow_functions",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "inheritance"
      ],
      "keywords": [
        "parameters",
        "omit",
        "returntype",
        "required",
        "number",
        "partial",
        "pick",
        "keyof",
        "type",
        "string",
        "func",
        "boolean"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 38,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 5,
      "pedagogical_type": "practice",
      "text_complexity": 0.39,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2n50071hxt8veiwl712",
      "title": "7. Числовой enum",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо создать числовое перечисление Enum, в котором каждому элементу автоматически присваиваются числовые значения, начиная с 0. Также требуется продемонстрировать, что перечисление поддерживает обратное отображение, позволяя получать имя элемента по его числовому значению.\\n",
      "code_content": "enum Enum {\n    A, // Значение по умолчанию — 0\n    B, // Значение по умолчанию — 1\n}\n\nconsole.log(Enum.A); // 0, так как значения начинаются с 0 по умолчанию\n\nconsole.log(Enum[0]); // \"A\"",
      "code_language": "ts",
      "code_lines": 6,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "enum"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 29,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 6,
      "pedagogical_type": "practice",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2nv0072hxt8detdynqf",
      "title": "8. Исключение z",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо определить новый тип Point2D, который создается на основе существующего типа Point3D, но без свойства z. Для этого используется утилита Omit<T, K>, которая позволяет исключить указанное свойство K из объекта T. Требуется убедиться, что в полученном типе Point2D остаются только свойства x и y.\\n",
      "code_content": "// Создайте новый тип `Point2D` на основе существующего типа `Point3D`, исключив из него свойство `z`.\n\ntype Point3D = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Point2D = Omit<Point3D, \"z\">;\n\n// Ожидаемый результат:\n// Point2D = {\n//   x: number;\n//   y: number;\n// }",
      "code_language": "ts",
      "code_lines": 12,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "template_literals",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "type",
        "omit",
        "number"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 36,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 7,
      "pedagogical_type": "practice",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2om0073hxt8pixlf1r6",
      "title": "9. Обобщённая функция",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо создать функцию fn, которая принимает аргумент типа T и возвращает его без изменений. Тип T ограничен объектом (extends object), что гарантирует, что переданный аргумент является объектом. Требуется убедиться, что при вызове функции переданный объект сохраняет свой тип, а возвращаемое значение соответствует входному объекту.\\n",
      "code_content": "// типизация и допись  \nfunction fn<T extends object>(arg: T): T {  \n    return arg;  \n}  \n  \n// Использование  \nconst result = fn({ id: \"123\", name: \"Alice\" });  \n  \n// Ожидаемый результат:  \n// result имеет тип { id: string; name: string }`",
      "code_language": "ts",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "strings",
        "classes",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "arg",
        "name",
        "object",
        "result"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 8,
      "pedagogical_type": "practice",
      "text_complexity": 0.45,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2pe0074hxt8fdzwqs4b",
      "title": "10. Опциональные свойства",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо изменить интерфейс Todo, чтобы все его свойства стали необязательными. Использование ? в определении свойств делает их опциональными, что позволяет создавать объекты без обязательного указания всех полей.\\n",
      "code_content": "interface Todo {\n    title?: string;\n    description?: string;\n}",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings"
      ],
      "js_features_used": [],
      "keywords": [
        "todo",
        "title",
        "description",
        "string",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 26,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 9,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2q40075hxt8cr97blxk",
      "title": "11. Только для чтения",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо изменить интерфейс Todo, чтобы его свойства стали доступными только для чтения. Использование readonly гарантирует, что после инициализации значения свойств изменить нельзя.\\n",
      "code_content": "interface Todo {\n    readonly title: string;\n    readonly description: string;\n}",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings"
      ],
      "js_features_used": [],
      "keywords": [
        "todo",
        "title",
        "readonly",
        "description",
        "string",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 24,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 10,
      "pedagogical_type": "practice",
      "text_complexity": 0.23,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2qq0076hxt8m3fpwumd",
      "title": "12. Выбор title",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо создать новый тип TodoTitle, который включает только свойство title из интерфейса Todo. Для этого используется утилита Pick<T, K>, позволяющая выбрать одно или несколько свойств из исходного типа.\\n",
      "code_content": "type TodoTitle = Pick<Todo, 'title'>;",
      "code_language": "ts",
      "code_lines": 1,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [],
      "js_features_used": [],
      "keywords": [
        "todo",
        "title",
        "pick",
        "type",
        "todotitle"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 11,
      "pedagogical_type": "practice",
      "text_complexity": 0.29,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2rf0077hxt8m94ldvxm",
      "title": "13. Ошибка в функции",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо исправить функцию error, которая должна всегда завершаться с исключением. Функция должна возвращать never, так как она не имеет корректного завершения. Бросок исключения (throw) предотвращает нормальный выход из функции, что соответствует типу never.\\n",
      "code_content": "function error(): never {\n    throw new Error('ERROR!');\n}",
      "code_language": "ts",
      "code_lines": 3,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "error_handling"
      ],
      "js_features_used": [],
      "keywords": [
        "error",
        "throw",
        "never"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 27,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 12,
      "pedagogical_type": "practice",
      "text_complexity": 0.34,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2s50078hxt8jvhpsvfe",
      "title": "14. Required свойства",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо изменить тип MaybeProps, чтобы все его свойства стали обязательными. Для этого используется утилита Required<T>, которая убирает модификатор ? у всех полей объекта.\\n",
      "code_content": "type RequiredProps = Required<MaybeProps>;",
      "code_language": "ts",
      "code_lines": 1,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "modules"
      ],
      "js_features_used": [],
      "keywords": [
        "type",
        "requiredprops",
        "maybeprops",
        "required"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 23,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 13,
      "pedagogical_type": "practice",
      "text_complexity": 0.24,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2su0079hxt8yxbqxsw9",
      "title": "15. Ограниченный контейнер",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо создать обобщенный тип Container, который содержит одно свойство value. Допустимые типы для value должны быть ограничены string или number, что обеспечивается extends string | number.\\n",
      "code_content": "type Container<T extends string | number> = {\n    value: T;\n};",
      "code_language": "ts",
      "code_lines": 3,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "number",
        "value",
        "type",
        "string",
        "container"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 25,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 14,
      "pedagogical_type": "practice",
      "text_complexity": 0.27,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2to007ahxt8ilyp40ji",
      "title": "16.Ошибка greet",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо исправить функцию greet, которая принимает объект с полем name и возвращает строку приветствия. Ошибка заключается в некорректном синтаксисе строкового шаблона в return, что требует исправления.\\n",
      "code_content": "function greet<T extends { name: string }>(entity: T): string {\n    `return `Hello, ${entity.name}!``;\n}",
      "code_language": "ts",
      "code_lines": 3,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "strings",
        "classes",
        "template_literals"
      ],
      "js_features_used": [
        "template_literals",
        "inheritance"
      ],
      "keywords": [
        "name",
        "entity",
        "hello",
        "string",
        "greet"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 25,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 15,
      "pedagogical_type": "practice",
      "text_complexity": 0.27,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2ui007bhxt8hgk2w0pl",
      "title": "17. Проверка Alien",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо исправить функцию checkAlien, которая проверяет, является ли объект person пришельцем. Ошибка связана с проверкой типа species и недостающим условием, которое гарантирует, что person является Alien перед доступом к его уникальным свойствам.\\n",
      "code_content": "type Alien = {\n  species: string;\n  name: string;\n  planet: string;\n  isAlien: true;\n}\n\ntype Human = {\n  planet: 'Earth';\n  name: string;\n  species: 'human';\n}\n\ntype Person = Alien | Human;\n\nfunction checkAlien(person: Person) {\n    if (person.species === \"human\") {\n        console.log(\"Not an alien\");\n    } else if (\"isAlien\" in person) {\n        console.log(person.isAlien); // Теперь TypeScript уверен, что это Alien\n    }\n}",
      "code_language": "ts",
      "code_lines": 19,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "conditionals",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "name",
        "planet",
        "isalien",
        "human",
        "checkalien",
        "type",
        "string",
        "person",
        "species",
        "alien"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 35,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 16,
      "pedagogical_type": "practice",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2v8007chxt8e7bupdkv",
      "title": "18. Ошибки типов",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо исправить ошибку в определении обобщенного типа A<T>, где {...} является недопустимым синтаксисом. Также необходимо проанализировать объединение интерфейсов с разными свойствами и убедиться, что оно происходит без ошибок.\\n",
      "code_content": "type A<T> = { foo: T };\n\ninterface B {\n    foo: string;\n}\ninterface B {\n    bar: string;\n}",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "destructuring",
        "spread_operator"
      ],
      "js_features_used": [],
      "keywords": [
        "bar",
        "type",
        "string",
        "foo",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 28,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 17,
      "pedagogical_type": "practice",
      "text_complexity": 0.29,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2vz007dhxt8ccxe4r3h",
      "title": "19. Конфликт интерфейсов",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо разобраться с проблемой объединения интерфейсов, в которых одинаковые свойства имеют разные типы. Такой конфликт приводит к ошибке. Для решения можно либо убедиться, что типы совпадают, либо использовать объединение типов (string | number).\\n",
      "code_content": "interface C {\n    bar: string;\n}\ninterface C {\n    bar: number; // Ошибка: конфликт типов для свойства bar\n}\n\ninterface D {\n    bar: string | number; // Пример с объединением типов, чтобы избежать конфликта",
      "code_language": "ts",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "string",
        "bar",
        "interface",
        "number"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 30,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 18,
      "pedagogical_type": "practice",
      "text_complexity": 0.34,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2wq007ehxt81fty1pdt",
      "title": "20. Пересечение типов",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Пачка мини задач"
      ],
      "text_content": "Постановка задачи:Необходимо проанализировать проблему пересечения типов, в которых одно и то же свойство имеет несовместимые типы (string и number). В таких случаях результирующий тип получает значение never. Чтобы этого избежать, можно использовать объединение типов (string | number).\\n",
      "code_content": "type E = {\n    bar: string;\n}\ntype F = E & {\n    bar: number;\n}\n\ntype G = {\n    bar: string | number;\n}\ntype H = G & {\n    bar: number;\n}\nРезультат: type H = { bar: number; }",
      "code_language": "ts",
      "code_lines": 13,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings"
      ],
      "js_features_used": [],
      "keywords": [
        "bar",
        "number",
        "never",
        "string",
        "type"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 33,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 19,
      "pedagogical_type": "practice",
      "text_complexity": 0.37,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2xh007fhxt8edo8sk4e",
      "title": "21. FormFields",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо исправить ошибку в типе FormFields, который строится на основе типа Form. Ошибка заключается в использовании typeof Form, хотя Form уже является объявленным типом и может быть использован напрямую.\\n",
      "code_content": "type Form = {\n  name: string;\n  age: number;  \n};\n\ntype FormField<T> = {}; // Тип представляющий html поле\n\n\ntype FormFields = {\n    [K in keyof typeof Form]: FormField<Form[K]>; // решение\n}",
      "code_language": "ts",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "loops",
        "objects",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "name",
        "form",
        "number",
        "keyof",
        "type",
        "string",
        "typeof",
        "formfields",
        "formfield",
        "age"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 20,
      "pedagogical_type": "practice",
      "text_complexity": 0.3,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2y9007ghxt8lfyjm59h",
      "title": "22. getProperty 1",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию getProp, которая принимает объект o и строку p, представляющую ключ. Функция должна возвращать true, если ключ p существует в объекте o, и false в противном случае. Использование оператора in позволит проверить наличие свойства в объекте.\\n",
      "code_content": "function getProp<T extends object, K extends keyof T>(o: T, p: K): boolean {  \n    return p in o;  \n}  \n  \n  \nconst x = { a: 1, b: 2, c: 3 };  \n  \n  \nconsole.log(getProp(x, 'a')); \n  \nconsole.log(getProp(x, 'o'));\n",
      "code_language": "ts",
      "code_lines": 6,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "classes"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "keyof",
        "getprop",
        "boolean",
        "getproperty",
        "object"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 31,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 21,
      "pedagogical_type": "practice",
      "text_complexity": 0.39,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2z0007hhxt87xuvf2xs",
      "title": "23. getProperty 2",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать обобщенную функцию getProperty, которая принимает объект obj и ключ key. Ключ должен быть строго ограничен существующими свойствами объекта, что обеспечивается использованием K extends keyof T. Функция должна возвращать значение свойства объекта по переданному ключу.\\n",
      "code_content": "function getProperty<T extends object, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n\nconst X = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(X, 'a');\ngetProperty(X, 'm'); \"c\" | \"d\"'\ngetProperty({ asd: 123 }, 'a');",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "classes"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "key",
        "obj",
        "keyof",
        "getproperty",
        "object"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 30,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 22,
      "pedagogical_type": "practice",
      "text_complexity": 0.37,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy2zt007ihxt8bdmtcpjw",
      "title": "24. getProperty 3",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо создать функцию getProperty, которая принимает объект и ключ, возвращая значение этого ключа. Для обеспечения безопасности типов следует использовать обобщения (generics), ограничивающие ключ возможными значениями из keyof T.\\n",
      "code_content": "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}",
      "code_language": "ts",
      "code_lines": 3,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "classes"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "key",
        "obj",
        "generics",
        "keyof",
        "getproperty"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 26,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 23,
      "pedagogical_type": "practice",
      "text_complexity": 0.29,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3v1008ahxt8atag4bgu",
      "title": "Readonly",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Делает все поля объекта только для чтения (нельзя изменить после инициализации).\\n",
      "code_content": "type Person = {\n  name: string;\n  age: number;\n};\n\ntype PersonReadonly = Readonly<Person>;\n// Эквивалентно: { readonly name: string; readonly age: number; }\n\n\ntype MyReadonly<T> = {\n  readonly [K in keyof T]: T[K];\n};",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "name",
        "number",
        "readonly",
        "myreadonly",
        "keyof",
        "type",
        "string",
        "person",
        "age",
        "personreadonly"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 23,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 3,
      "pedagogical_type": "practice",
      "text_complexity": 0.12,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy30p007jhxt8bg5ixnq1",
      "title": "25. getDetails",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию getDetails, которая принимает объект obj и отображение mapping. Функция должна возвращать массив объектов, содержащих ключи из obj и их преобразованные значения. Если для ключа указана функция преобразования в mapping, следует применять её, иначе оставлять исходное значение.\\n",
      "code_content": "type Mapping<T> = {  \n    [K in keyof T]?: (value: T[K]) => string | number;  \n};  \n  \nfunction getDetails<T extends object>(obj: T, mapping: Mapping<T> ){  \n  \n    const result: Array<{ key: keyof T; value: string | number | T[keyof T] }> = [];  \n  \n    for (const key in obj) {  \n  \n        const value = obj[key as keyof T];  \n  \n        const fn = mapping[key as keyof T];  \n  \n        result.push({ key, value: fn ? fn(value) : value });  \n    }  \n  \n    return result;  \n}",
      "code_language": "ts",
      "code_lines": 12,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "arrays",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "functional"
      ],
      "js_features_used": [
        "arrow_functions",
        "inheritance"
      ],
      "keywords": [
        "key",
        "obj",
        "number",
        "value",
        "keyof",
        "array",
        "type",
        "string",
        "result",
        "mapping",
        "getdetails",
        "object"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 41,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 24,
      "pedagogical_type": "practice",
      "text_complexity": 0.4,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy31f007khxt80sddujss",
      "title": "26. getInfo",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо создать функцию getInfo, которая принимает ключ из заранее объявленного объекта person и возвращает соответствующее значение. Ключ должен быть ограничен keyof typeof person, что обеспечит безопасность типов.\\n",
      "code_content": "let person = {  \n    name: 'Anton',  \n    age: 37,  \n    location: 'Yekaterinburg'  \n}  \n  \nconst getInfo = (key) => {  \n  \n}  \n\n// console.log(getInfo('name')); // \"Anton\"  \n  \n// console.log(getInfo('age')); // 37  \n  \n// console.log(getInfo('location')); // \"Yekaterinburg\"",
      "code_language": "ts",
      "code_lines": 10,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrow_functions",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions"
      ],
      "keywords": [
        "name",
        "key",
        "keyof",
        "person",
        "typeof",
        "age",
        "location",
        "getinfo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 30,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 25,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy325007lhxt86vgypxw2",
      "title": "27. getInfo 2",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию getInfo, которая принимает объект product, первый уровень ключей path и второй уровень ключей nextPath. Функция должна возвращать значение, соответствующее product[path][nextPath], с учетом корректной типизации через обобщенные параметры (generics).\\n",
      "code_content": "// Типизировать функцию\nconst product = {  \n    name: {  \n        title: \"Bag\",  \n        description: \"A stylish leather bag\"  \n    },  \n    details: {  \n        price: 700,  \n        currency: \"USD\"  \n    },  \n    info: {  \n        weight: 100,  \n        dimensions: {  \n            length: 30,  \n            width: 20,  \n            height: 10  \n        }  \n    }};  \n  \nfunction getInfo(product, path, nextPath) {  \n    return product[path][nextPath];  \n}  \n  \n// const title = getInfo(product, \"name\", \"title\"); // \"Bag\"  \n  \n// const price = getInfo(product, \"details\", \"price\"); // 700  \n  \n// const weight = getInfo(product, \"info\", \"weight\"); // 100",
      "code_language": "ts",
      "code_lines": 24,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Средний код (24 строк)",
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "width",
        "title",
        "weight",
        "product",
        "path",
        "name",
        "dimensions",
        "info",
        "generics",
        "nextpath",
        "description",
        "currency",
        "details",
        "price",
        "height",
        "getinfo"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 45,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 26,
      "pedagogical_type": "practice",
      "text_complexity": 0.32,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy32v007mhxt8k4ik2zgo",
      "title": "28. callback",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию callback, которая принимает объект obj и ключ key, принадлежащий keyof T. Функция должна возвращать значение свойства obj[key], при этом обеспечивая строгую типизацию.\\n",
      "code_content": "const obj321 = {\n    key: '',\n    value: '',\n};\n\nfunction callback<T extends object, K extends keyof T>(obj: T, key: K): T[K] {\n    return obj[key];\n}\n\ncallback(obj321, 'key'); // Returns: string",
      "code_language": "ts",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "key",
        "obj",
        "callback",
        "keyof",
        "value",
        "object"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 27,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 27,
      "pedagogical_type": "practice",
      "text_complexity": 0.26,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy33l007nhxt8sa859h13",
      "title": "29. fn (infer)",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию fn, которая принимает объект типа A | B. В зависимости от переданного типа функция должна возвращать boolean, если передан объект типа A, и number, если объект типа B. Использование оператора extends в сочетании с infer позволит корректно вывести возвращаемый тип.\\n",
      "code_content": "type A = { foo: boolean };\ntype B = { bar: number };\n\ntype C = A | B;\n\nfunction fn<T extends C>(data: T): T extends A ? boolean : number {\n    // Implementation here\n}\n\nconst a: A = { foo: true };\nconst b: B = { bar: 42 };\n\nconst c = fn(a); // c: boolean\nconst d = fn(b); // d: number",
      "code_language": "ts",
      "code_lines": 10,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "bar",
        "number",
        "data",
        "type",
        "foo",
        "boolean",
        "infer"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 28,
      "pedagogical_type": "practice",
      "text_complexity": 0.44,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy34c007ohxt8v6ttstm0",
      "title": "30. myAsyncFunction",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать асинхронную функцию myAsyncFunction, которая принимает строку url и возвращает Promise<string>. Функция должна быть корректно вызвана с последующей обработкой результата с помощью .then().\\n",
      "code_content": "const myAsyncFunction = async (url: string): Promise<string> => {\n    return url;\n};\n\nmyAsyncFunction(\"123\").then(result => console.log(result));",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "strings",
        "async",
        "arrow_functions"
      ],
      "js_features_used": [
        "arrow_functions",
        "async_await",
        "promises"
      ],
      "keywords": [
        "myasyncfunction",
        "url",
        "string",
        "result",
        "then",
        "async",
        "promise"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 30,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 29,
      "pedagogical_type": "practice",
      "text_complexity": 0.25,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy352007phxt8cjjtlth4",
      "title": "31. merge",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию merge, которая объединяет два объекта obj1 и obj2 в один. Возвращаемый объект должен содержать все свойства обоих объектов, сохраняя типизацию. Для этого используется пересечение типов (T & U).\\n",
      "code_content": "function merge(obj1, obj2) {  \n    return {  \n        ...obj1,  \n        ...obj2,  \n    };  \n}  \n  \nconst res = merge({a: 5}, {b: {a: 10, mes: 'test'}})",
      "code_language": "js",
      "code_lines": 7,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Алгоритмы сортировки"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "destructuring",
        "spread_operator",
        "sorting",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "merge",
        "mes",
        "res"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 34,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 30,
      "pedagogical_type": "practice",
      "text_complexity": 0.32,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy35t007qhxt8x4cgbbz6",
      "title": "32. join",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо создать функцию join, которая принимает строку-разделитель и массив строковых аргументов. Функция должна объединять переданные строки с использованием разделителя, обеспечивая правильную типизацию входных данных.\\n",
      "code_content": "// Implement the join function with proper typing for variable arguments.\n\nfunction join(separator, ...parts) {\n  // Implementation here\n}\n\nconst result = join('-', 'a', 'b', 'c'); // Should return 'a-b-c'",
      "code_language": "ts",
      "code_lines": 5,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "loops",
        "strings",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "separator",
        "result",
        "parts",
        "join"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 25,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 31,
      "pedagogical_type": "practice",
      "text_complexity": 0.25,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy36i007rhxt8fn97eyx2",
      "title": "33. pluck",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Функции (дженерики)"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать функцию pluck, которая принимает массив объектов items и ключ key. Функция должна возвращать массив значений, соответствующих key во всех объектах массива, с корректной типизацией с использованием K extends keyof T.\\n",
      "code_content": "// Type the pluck function using generics and indexed access types.\n\nfunction pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {\n  // Implementation here\n}\n\nconst users = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n];\n\nconst names = pluck(users, 'name'); // Should be ['Alice', 'Bob']",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "arrays",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "name",
        "pluck",
        "key",
        "items",
        "keyof",
        "names",
        "users"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 30,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 32,
      "pedagogical_type": "practice",
      "text_complexity": 0.33,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy37b007shxt89u9en64j",
      "title": "35. Exclude + Omit",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Кастомные Utility"
      ],
      "text_content": "Постановка задачи:Необходимо создать обобщенный тип MyExclude, который удаляет из объединения T все типы, совпадающие с U. Затем на его основе реализовать MyOmit, который позволяет исключить из объекта T свойства, указанные в K, аналогично стандартному Omit<T, K>.\\n",
      "code_content": "// 1. Exclude  \n  \n// type MyExclude ...  \n  \n// Test Case  \ntype ExcludableValues = MyExclude<'a' | 'b' | 'c', 'a'>; // -> 'b' | 'c'  \n  \n  \n  \ninterface User {  \n    name: string;  \n    age: number;  \n}  \n  \n  \n// type MyOmit ...  \n  \n  \n  \ninterface User2 extends MyOmit<User, 'age'> {}  \n  \n// Test Case  \n  \nconst user: User2 = {  \n    name: \"Alice\" // допустимо  \n    // age не существует в User2};",
      "code_language": "ts",
      "code_lines": 14,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "conditionals",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "myexclude",
        "omit",
        "name",
        "myomit",
        "number",
        "type",
        "string",
        "exclude",
        "age",
        "user",
        "excludablevalues",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 33,
      "pedagogical_type": "practice",
      "text_complexity": 0.36,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy380007thxt8ghmr7d9w",
      "title": "37. Omit",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Кастомные Utility"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип MyOmit, который исключает из объекта T свойства, указанные в K. Для реализации используется Exclude<keyof T, K>, который удаляет ключи K из ключей T, а затем создается новый объект с оставшимися свойствами.\\n",
      "code_content": "interface User {\n    name: string;\n    age: number;\n}\n\n// Test Case\n\nconst user: User2 = {\n    name: \"Alice\" // допустимо\n    // age не существует в User2\n};",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "conditionals",
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "omit",
        "name",
        "myomit",
        "number",
        "keyof",
        "string",
        "exclude",
        "age",
        "user",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 31,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 34,
      "pedagogical_type": "practice",
      "text_complexity": 0.35,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy38q007uhxt8ytt6q6au",
      "title": "38. Readonly",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Кастомные Utility"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип MyReadonly, который делает все свойства объекта T доступными только для чтения. Это аналог встроенного типа Readonly<T>, при котором каждое свойство объекта T становится readonly.\\n",
      "code_content": "// 2. Readonly  \n  \ninterface Todo {  \n    title: string  \n    description: string  \n    completed: boolean  \n    author: string  \n}  \n  \n// type MyReadonly ...  \n  \ntype ReadonlyTodo = MyReadonly<Todo>  \n\n/* ->  \n  {    readonly title: string;    readonly description: string;    readonly completed: boolean;    readonly author: string;  }*/\n",
      "code_language": "ts",
      "code_lines": 11,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "strings",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator"
      ],
      "keywords": [
        "todo",
        "title",
        "readonly",
        "myreadonly",
        "completed",
        "description",
        "string",
        "type",
        "boolean",
        "readonlytodo",
        "interface",
        "author"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 29,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 35,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy39g007vhxt8n81pfqi4",
      "title": "39. Partial",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Кастомные Utility"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип MyPartial, который делает все свойства объекта T необязательными. Это аналог встроенного Partial<T>, который преобразует каждый ключ T в необязательный с помощью ?.\\n",
      "code_content": "\n// Определение MyPartial\ntype MyPartial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Пример использования:\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype PartialUser = MyPartial<User>;\n\n// Теперь PartialUser будет эквивалентен следующему:\ntype PartialUserEquivalent = {\n  name?: string;\n  age?: number;\n};\n\n",
      "code_language": "ts",
      "code_lines": 15,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "mypartial",
        "name",
        "number",
        "partial",
        "keyof",
        "type",
        "string",
        "partialuser",
        "partialuserequivalent",
        "age",
        "user",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 31,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 36,
      "pedagogical_type": "practice",
      "text_complexity": 0.26,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3a5007whxt8uubhszum",
      "title": "40. Parameters",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Кастомные Utility"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип MyParameters, который извлекает типы аргументов функции T и возвращает их в виде кортежа. Это аналог встроенного Parameters<T>, который позволяет получить типы параметров переданной функции.\\n",
      "code_content": "\n// 3. Parameters\ntype MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => any ? P : never;\n\n// Test Case\nconst foo = (arg1: string, arg2: number): void => {};\n\ntype FooParameters = MyParameters<typeof foo>; // -> [string, number]\n\n",
      "code_language": "ts",
      "code_lines": 5,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "functions",
        "conditionals",
        "arrays",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "parameters",
        "void",
        "myparameters",
        "number",
        "fooparameters",
        "never",
        "type",
        "string",
        "any",
        "foo",
        "typeof",
        "args",
        "infer"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 28,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 37,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3au007xhxt89b9es3au",
      "title": "41. MyAwaited",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип MyAwaited, который извлекает тип значения, возвращаемого из Promise<T>. Если переданный тип T является Promise<U>, то MyAwaited<T> должен возвращать U, в противном случае — T.\\n",
      "code_content": "// Define MyAwaited to extract the resolved type from a Promise.\n\ntype MyAwaited<T> = /* Implement here */;\n\ntype Example = Promise<number>;\n\ntype Result = MyAwaited<Example>; // Expected to be number",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "async",
        "regex"
      ],
      "js_features_used": [
        "promises"
      ],
      "keywords": [
        "number",
        "type",
        "result",
        "example",
        "promise",
        "myawaited"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 26,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 38,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3bk007yhxt8a122lgc4",
      "title": "42. last (infer)",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип Last<T>, который получает последний элемент переданного массива T. Для этого используется оператор infer, который позволяет извлечь последний элемент через кортежное представление массива.\\n",
      "code_content": "\ntype Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;\n\ntype arr1 = [\"a\", \"b\", \"c\"];\ntype arr2 = [3, 2, 1];\n\ntype tail1 = Last<arr1>; // 'c'\ntype tail2 = Last<arr2>; // 1\n\n",
      "code_language": "ts",
      "code_lines": 5,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "arrays",
        "classes",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "last",
        "never",
        "type",
        "any",
        "infer"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 26,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 39,
      "pedagogical_type": "practice",
      "text_complexity": 0.26,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3cb007zhxt8puxkl9g5",
      "title": "43. concat",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип Concat<T, U>, который объединяет два массива T и U в один. В результате должен получиться новый массив, содержащий элементы T, а затем элементы U\\n",
      "code_content": "\ntype Concat<T extends any[], U extends any[]> = [...T, ...U];\n\ntype Result = Concat<[1], [2]>; // [1, 2]\n\n",
      "code_language": "ts",
      "code_lines": 2,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "arrays",
        "classes",
        "destructuring",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "type",
        "result",
        "any",
        "concat"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 25,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 40,
      "pedagogical_type": "practice",
      "text_complexity": 0.28,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3d00080hxt8mdxc84cu",
      "title": "44. Template Literal Types",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо использовать шаблонные строковые типы (Template Literal Types) в TypeScript. Требуется создать строковые типы, которые динамически комбинируют значения на основе переданных типов, например, для формирования уникальных строковых идентификаторов.\\n",
      "code_content": "// Создаем строковые типы с динамической подстановкой\ntype Prefix = \"user\" | \"admin\" | \"guest\";\ntype ID<T extends string> = `${T}_id`;\n\ntype UserID = ID<\"user\">; // \"user_id\"\ntype AdminID = ID<\"admin\">; // \"admin_id\"\n\n// Использование нескольких шаблонных типов\ntype UserRole<T extends Prefix> = `${T}_role`;\n\ntype Role1 = UserRole<\"user\">; // \"user_role\"\ntype Role2 = UserRole<\"admin\">; // \"admin_role\"",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "template_literals",
        "regex"
      ],
      "js_features_used": [
        "template_literals",
        "inheritance"
      ],
      "keywords": [
        "typescript",
        "template",
        "literal",
        "userid",
        "type",
        "string",
        "userrole",
        "prefix",
        "adminid",
        "types"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 30,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 41,
      "pedagogical_type": "example",
      "text_complexity": 0.29,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3dq0081hxt841clr2fy",
      "title": "45. Типы-контейнеры с условными ограничениями",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать контейнерные типы с условными ограничениями. Такие типы позволяют накладывать условия на параметры (generics) и изменять их структуру в зависимости от переданного типа.\\n",
      "code_content": "// Создаем контейнер с ограничением типов\ntype Container<T extends string | number> = {\n    value: T;\n};\n\n// Пример использования\nconst stringContainer: Container<string> = { value: \"Hello\" };\nconst numberContainer: Container<number> = { value: 42 };\n\n// Ошибка: тип boolean не соответствует ограничению\n// const invalidContainer: Container<boolean> = { value: true }; ",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "variables",
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "numbercontainer",
        "stringcontainer",
        "number",
        "generics",
        "value",
        "type",
        "string",
        "container"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 27,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 42,
      "pedagogical_type": "practice",
      "text_complexity": 0.25,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3ee0082hxt8dp83qyyf",
      "title": "46. Рекурсивные условные типы",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать рекурсивные условные типы, которые позволяют создавать вложенные структуры, например, для глубокого преобразования типов или рекурсивного обхода сложных типов.\\n",
      "code_content": "// Рекурсивный тип для преобразования всех свойств объекта в строки\ntype DeepStringify<T> = {\n    [K in keyof T]: T[K] extends object ? DeepStringify<T[K]> : string;\n};\n\ninterface Data {\n    id: number;\n    details: {\n        name: string;\n        age: number;\n    };\n}\n\ntype StringifiedData = DeepStringify<Data>;\n\n// Ожидаемый результат:\n// type StringifiedData = {\n//     id: string;\n//     details: {\n//         name: string;\n//         age: string;\n//     };\n// }",
      "code_language": "ts",
      "code_lines": 20,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "conditionals",
        "objects",
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "deepstringify",
        "name",
        "stringifieddata",
        "number",
        "keyof",
        "data",
        "type",
        "string",
        "details",
        "age",
        "object",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 32,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 43,
      "pedagogical_type": "example",
      "text_complexity": 0.21,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3f60083hxt8dfggnqaq",
      "title": "47. Key Remapping в отображаемых типах",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать тип RemapKeys<T>, который изменяет имена всех ключей в объекте T, добавляя к ним префикс new_. Для этого используется Key Remapping в отображаемых типах, позволяющий переименовывать ключи при их копировании.\\n",
      "code_content": "\ntype RemapKeys<T> = {  \n    [K in keyof T as `new_${K & string}`]: T[K];  \n};  \n  \ninterface Original {  \n    id: number;  \n    name: string;  \n}  \n  \ntype Remapped = RemapKeys<Original>;  \n  \n// Ожидаемый результат:  \n// {  \n//   new_id: number;  \n//   new_name: string;  \n// }\n\n",
      "code_language": "ts",
      "code_lines": 13,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "loops",
        "objects",
        "strings",
        "template_literals",
        "regex",
        "functional"
      ],
      "js_features_used": [
        "template_literals"
      ],
      "keywords": [
        "remapkeys",
        "name",
        "key",
        "remapped",
        "number",
        "keyof",
        "original",
        "type",
        "string",
        "remapping",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 33,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 44,
      "pedagogical_type": "practice",
      "text_complexity": 0.32,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3fv0084hxt8n2w0kc2z",
      "title": "48. Создание глубоких неизменяемых типов",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать DeepReadonly<T>, который рекурсивно делает все свойства объекта T неизменяемыми. Если свойство является объектом, оно также должно становиться readonly, сохраняя структуру.\\n",
      "code_content": "\ntype DeepReadonly<T> = {\n  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n};\n\ninterface NestedObject {\n  a: {\n    b: {\n      c: string;\n    };\n  };\n}\n\nconst obj: DeepReadonly<NestedObject> = {\n  a: {\n    b: {\n      c: 'value',\n    },\n  },\n};\n\nobj.a.b.c = 'new value'; // Ошибка: нельзя изменить свойство только для чтения\n\n\n",
      "code_language": "ts",
      "code_lines": 18,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "objects",
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "obj",
        "deepreadonly",
        "nestedobject",
        "readonly",
        "keyof",
        "type",
        "string",
        "object",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 34,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 45,
      "pedagogical_type": "practice",
      "text_complexity": 0.23,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3gm0085hxt8r7wtl17m",
      "title": "49. Пользовательские типы с условными свойствами",
      "category": "TS",
      "subcategory": "Задачи",
      "path_titles": [
        "Types"
      ],
      "text_content": "Постановка задачи:Необходимо реализовать ConditionalProperties<T, Condition>, который извлекает имена свойств объекта T, чьи значения соответствуют типу Condition. Например, можно выделить только строковые свойства из интерфейса Example.\\n",
      "code_content": "\ntype ConditionalProperties<T, Condition> = {\n  [K in keyof T]: T[K] extends Condition ? K : never;\n}[keyof T];\n\ninterface Example {\n  id: number;\n  title: string;\n  isActive: boolean;\n}\n\ntype StringProperties = ConditionalProperties<Example, string>; // 'title'\n\n",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "title",
        "number",
        "condition",
        "keyof",
        "conditionalproperties",
        "never",
        "type",
        "string",
        "isactive",
        "boolean",
        "example",
        "stringproperties",
        "interface"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 27,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 46,
      "pedagogical_type": "example",
      "text_complexity": 0.25,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3tm0088hxt834j8dyun",
      "title": "Omit",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Создаёт тип, исключающий из T указанные ключи (K).\\n",
      "code_content": "type Person = {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n};\n\ntype WithoutAdmin = Omit<Person, 'isAdmin'>;\n// Эквивалентно: { name: string; age: number; }\n\n\n\ntype MyOmit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;",
      "code_language": "ts",
      "code_lines": 8,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "omit",
        "name",
        "myomit",
        "number",
        "pick",
        "keyof",
        "type",
        "string",
        "any",
        "person",
        "isadmin",
        "age",
        "boolean",
        "withoutadmin",
        "exclude"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 22,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 1,
      "pedagogical_type": "practice",
      "text_complexity": 0.09,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3uc0089hxt8krntlulu",
      "title": "Pick",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Создаёт тип, выбирающий из T только указанные ключи (K).\\n",
      "code_content": "type Person = {\n  name: string;\n  age: number;\n  isAdmin: boolean;\n};\n\ntype NameAndAge = Pick<Person, 'name' | 'age'>;\n// Эквивалентно: { name: string; age: number; }\n\n\ntype MyPick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};",
      "code_language": "ts",
      "code_lines": 10,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "nameandage",
        "name",
        "number",
        "pick",
        "keyof",
        "type",
        "string",
        "person",
        "isadmin",
        "age",
        "boolean",
        "mypick"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 23,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 2,
      "pedagogical_type": "practice",
      "text_complexity": 0.1,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3vr008bhxt8n8pagldu",
      "title": "Record",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Создаёт тип объекта, где каждый ключ из K (обычно строка/число/символ) маппится на значение типа T.\\n",
      "code_content": "type Roles = 'admin' | 'user' | 'guest';\n\ntype RolePermissions = Record<Roles, boolean>;\n// Эквивалентно: {\n//   admin: boolean;\n//   user: boolean;\n//   guest: boolean;\n// }\n\n\ntype MyRecord<K extends keyof any, T> = {\n  [P in K]: T;\n};",
      "code_language": "ts",
      "code_lines": 10,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "keyof",
        "type",
        "rolepermissions",
        "any",
        "roles",
        "record",
        "boolean",
        "myrecord"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 25,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 4,
      "pedagogical_type": "practice",
      "text_complexity": 0.16,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3wh008chxt84npe05nn",
      "title": "Exclude",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Исключает из объединения (union) T все типы, которые приспособимы к U.\\n",
      "code_content": "type AllTypes = string | number | boolean;\n\ntype JustStringsAndNumbers = Exclude<AllTypes, boolean>;\n// Эквивалентно: string | number\n\n\ntype MyExclude<T, U> = T extends U ? never : T;",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "myexclude",
        "juststringsandnumbers",
        "number",
        "never",
        "alltypes",
        "type",
        "string",
        "exclude",
        "boolean",
        "union"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 21,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 5,
      "pedagogical_type": "practice",
      "text_complexity": 0.12,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3x8008dhxt8op0ca7dv",
      "title": "Extract",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Извлекает из объединения T только те типы, которые приспособимы к U.\\n",
      "code_content": "type AllTypes = string | number | boolean;\n\ntype OnlyStrings = Extract<AllTypes, string>;\n// Эквивалентно: string\n\ntype MyExtract<T, U> = T extends U ? T : never;",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "onlystrings",
        "extract",
        "number",
        "myextract",
        "never",
        "alltypes",
        "type",
        "string",
        "boolean"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 21,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 6,
      "pedagogical_type": "practice",
      "text_complexity": 0.12,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3xy008ehxt8p1upb3mt",
      "title": "Required",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Назначение: Делает все поля объекта обязательными (required).\\n",
      "code_content": "type PersonOptional = {\n  name?: string;\n  age?: number;\n};\n\ntype PersonRequired = Required<PersonOptional>;\n// Эквивалентно: { name: string; age: number; }\n\n\ntype MyRequired<T> = {\n  [K in keyof T]-?: T[K];\n};",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "modules",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "personoptional",
        "name",
        "required",
        "number",
        "keyof",
        "type",
        "string",
        "age",
        "myrequired",
        "personrequired"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 21,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 7,
      "pedagogical_type": "practice",
      "text_complexity": 0.07,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3yo008fhxt8xelf9055",
      "title": "NonNullable",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Исключает null и undefined из типа T.\\n",
      "code_content": "type NullableString = string | null | undefined;\n\ntype NonNullStr = NonNullable<NullableString>;\n// Эквивалентно: string\n\ntype MyNonNullable<T> = T extends null | undefined ? never : T;",
      "code_language": "ts",
      "code_lines": 4,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "classes",
        "regex"
      ],
      "js_features_used": [
        "inheritance"
      ],
      "keywords": [
        "nonnullable",
        "nullablestring",
        "mynonnullable",
        "never",
        "type",
        "string",
        "nonnullstr"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions"
      ],
      "estimated_time_minutes": 19,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 8,
      "pedagogical_type": "practice",
      "text_complexity": 0.08,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3ze008ghxt8vkuo0bfz",
      "title": "ReturnType",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Получает тип возвращаемого значения из типа функции T.\\n",
      "code_content": "function getName(): string {\n  return 'Alice';\n}\n\ntype NameReturnType = ReturnType<typeof getName>;\n// Эквивалентно: string\n\n\ntype MyReturnType<T extends (...args: any[]) => any> =\n  T extends (...args: any[]) => infer R ? R : never;",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "arrays",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "returntype",
        "namereturntype",
        "never",
        "string",
        "type",
        "any",
        "getname",
        "typeof",
        "myreturntype",
        "args",
        "infer"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 22,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 9,
      "pedagogical_type": "practice",
      "text_complexity": 0.09,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy404008hhxt8va6h5gkk",
      "title": "Parameters",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Получает кортеж типов параметров функции T.\\n",
      "code_content": "function greet(name: string, age: number): void {}\n\ntype GreetParams = Parameters<typeof greet>;\n// Эквивалентно: [name: string, age: number]\n\n\ntype MyParameters<T extends (...args: any) => any> =\n  T extends (...args: infer P) => any ? P : never;",
      "code_language": "ts",
      "code_lines": 5,
      "complexity_score": 0.5,
      "difficulty_factors": [],
      "programming_concepts": [
        "functions",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "inheritance"
      ],
      "keywords": [
        "parameters",
        "name",
        "void",
        "myparameters",
        "number",
        "never",
        "string",
        "type",
        "greetparams",
        "any",
        "age",
        "typeof",
        "greet",
        "args",
        "infer"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 20,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 10,
      "pedagogical_type": "practice",
      "text_complexity": 0.07,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy40u008ihxt84rm3e87z",
      "title": "InstanceType",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Получает тип экземпляра (instance) из конструктора T.\\n",
      "code_content": "class User {\n  constructor(public name: string, public age: number) {}\n}\n\ntype UserInstance = InstanceType<typeof User>;\n// Эквивалентно: User\n\n\ntype MyInstanceType<T extends new (...args: any) => any> =\n  T extends new (...args: any) => infer R ? R : any;",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "es6_classes",
        "constructor",
        "inheritance"
      ],
      "keywords": [
        "public",
        "name",
        "instance",
        "number",
        "userinstance",
        "string",
        "type",
        "myinstancetype",
        "instancetype",
        "any",
        "age",
        "user",
        "typeof",
        "args",
        "infer",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 25,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 11,
      "pedagogical_type": "practice",
      "text_complexity": 0.08,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy41k008jhxt8567luw6d",
      "title": "ConstructorParameters",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Извлекает типы параметров конструктора.\\n",
      "code_content": "class User {\n  constructor(public name: string, public age: number) {}\n}\n\ntype UserConstructorParams = ConstructorParameters<typeof User>;\n// Эквивалентно: [name: string, age: number]\n\n\ntype MyConstructorParameters<T extends abstract new (...args: any) => any> =\n  T extends abstract new (...args: infer P) => any ? P : never;",
      "code_language": "ts",
      "code_lines": 7,
      "complexity_score": 2.0,
      "difficulty_factors": [
        "Сложные концепции (1)"
      ],
      "programming_concepts": [
        "variables",
        "functions",
        "objects",
        "strings",
        "classes",
        "destructuring",
        "arrow_functions",
        "spread_operator",
        "regex"
      ],
      "js_features_used": [
        "arrow_functions",
        "spread_operator",
        "es6_classes",
        "constructor",
        "inheritance"
      ],
      "keywords": [
        "public",
        "name",
        "number",
        "never",
        "myconstructorparameters",
        "string",
        "type",
        "userconstructorparams",
        "abstract",
        "any",
        "age",
        "user",
        "typeof",
        "constructorparameters",
        "args",
        "infer",
        "constructor"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [
        "objects",
        "functions",
        "variables"
      ],
      "estimated_time_minutes": 24,
      "target_skill_level": "advanced",
      "path_depth": 1,
      "order_in_file": 12,
      "pedagogical_type": "practice",
      "text_complexity": 0.05,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy42a008khxt82nf2thrd",
      "title": "ThisType",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Остальные"
      ],
      "text_content": "Назначение: Позволяет задать контекст this для объектов (обычно полезно в комбинации с --noImplicitThis или при написании деклараций для JS-библиотек).\\nПример (используется редко на практике и не работает напрямую в обычных интерфейсах без контекста, но в config-объектах может быть полезно):\\n",
      "code_content": "type Obj = ThisType<{ message: string }>;\n\nconst obj: Obj = {\n  printMessage() {\n    // Здесь `this` считается { message: string }\n    console.log(this.message);\n  },\n};\n\n\n// В \"чистом\" виде нельзя реализовать без магии TS, но условно:\ntype MyThisType<T> = { /* сборная заглушка */ };",
      "code_language": "ts",
      "code_lines": 9,
      "complexity_score": 1.0,
      "difficulty_factors": [
        "Средняя вложенность (3)"
      ],
      "programming_concepts": [
        "variables",
        "strings",
        "template_literals",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "obj",
        "config",
        "mythistype",
        "message",
        "noimplicitthis",
        "type",
        "string",
        "thistype",
        "printmessage"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 35,
      "target_skill_level": "intermediate",
      "path_depth": 1,
      "order_in_file": 13,
      "pedagogical_type": "example",
      "text_complexity": 0.38,
      "user_success_rate": 0.0,
      "avg_solve_time": 0.0
    },
    {
      "id": "cmbhuy3sl0087hxt862ok8q55",
      "title": "Partial",
      "category": "TS",
      "subcategory": "Утилитные типы",
      "path_titles": [
        "Основные"
      ],
      "text_content": "Делает все поля объекта необязательными (optional).\\n",
      "code_content": "type Person = {\n  name: string;\n  age: number;\n};\n\ntype PersonPartial = Partial<Person>;\n// Эквивалентно: { name?: string; age?: number; }\nasdasdas\ntype MyPartial<T> = {\n  [K in keyof T]?: T[K];\n};",
      "code_language": "ts",
      "code_lines": 10,
      "complexity_score": 0.0,
      "difficulty_factors": [],
      "programming_concepts": [
        "strings",
        "regex"
      ],
      "js_features_used": [],
      "keywords": [
        "mypartial",
        "name",
        "number",
        "partial",
        "optional",
        "keyof",
        "personpartial",
        "type",
        "string",
        "person",
        "age",
        "asdasdas"
      ],
      "similar_tasks": [],
      "prerequisite_concepts": [],
      "estimated_time_minutes": 22,
      "target_skill_level": "beginner",
      "path_depth": 1,
      "order_in_file": 0,
      "pedagogical_type": "practice",
      "text_complexity": 0.06,
      "user_success_rate": 1.0,
      "avg_solve_time": 3.0
    }
  ],
  "concept_clusters": {
    "arrays": [
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxyda004thxt88zlcfy7p",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxygu004yhxt81f1v2gsu",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3ze008ghxt8vkuo0bfz"
    ],
    "functions": [
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxs2l0002hxt8dctlk266",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuy10w0065hxt811552rzr",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxydy004uhxt8pp8z6lbv",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuy11s0066hxt8hwryorh4",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxuiu0027hxt8b2ukzqum",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxujl0028hxt8lotcvh0v",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxukd0029hxt8s70bhq5t",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxtze001zhxt8gi7a8rbq",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxu0y0021hxt8m2amkhfg",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxu3a0024hxt8kgth0xff",
      "cmbhuxul3002ahxt8xbqlc9h0",
      "cmbhuxulw002bhxt8d5lmmlb8",
      "cmbhuxumn002chxt8l6eazjvy",
      "cmbhuxune002dhxt8aic7842d",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxvr3003ahxt8w8d6zyjw",
      "cmbhuxuov002fhxt8df139lwi",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxwe2003chxt8rwypcfj0",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxutz002mhxt8s89q83nw",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxuvg002ohxt8ydqy5mni",
      "cmbhuxuw8002phxt8zdhyaonc",
      "cmbhuxuwz002qhxt8d1p114i6",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxuxs002rhxt8ny7coxj8",
      "cmbhuxuyj002shxt8u66jvno7",
      "cmbhuxuza002thxt89mb63y9k",
      "cmbhuxv02002uhxt8d791nlzh",
      "cmbhuy0xa0060hxt8gj17myut",
      "cmbhuy0y00061hxt8t6b6zbyr",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxv4u0030hxt8z9gmuesj",
      "cmbhuxv5k0031hxt8h713wjbt",
      "cmbhuxvqc0039hxt8u37on9me",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxvmj0034hxt8pgunvy4a",
      "cmbhuxvnb0035hxt8vys5zdse",
      "cmbhuxvo00036hxt8hdoh0aib",
      "cmbhuxvou0037hxt8lxnj0pjo",
      "cmbhuxvpm0038hxt8di4dikfj",
      "cmbhuy0yq0062hxt8eh9stuz5",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxy5t004jhxt81ai0mp7u",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxx7e003thxt8a3fnleyl",
      "cmbhuxx85003uhxt8ysyfns6p",
      "cmbhuxybu004rhxt821vvdjmk",
      "cmbhuxx8w003vhxt8nblvhg45",
      "cmbhuxx9q003whxt82t576qha",
      "cmbhuxxag003xhxt80033zpaf",
      "cmbhuxxb6003yhxt8agyoqdvi",
      "cmbhuxyck004shxt8xbifcpjd",
      "cmbhuxxbx003zhxt8dtyuwmzw",
      "cmbhuxxco0040hxt8asigmboe",
      "cmbhuxxdf0041hxt8qtiizdxr",
      "cmbhuxxe60042hxt8395kf8t0",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuxxex0043hxt8dsobibwk",
      "cmbhuxxfo0044hxt82hrt8pdt",
      "cmbhuxxgf0045hxt8el43xkcy",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxyda004thxt88zlcfy7p",
      "cmbhuxxij0047hxt8eu8p0tk0",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxxk10049hxt8swobackx",
      "cmbhuxxkr004ahxt8dk4jo9nh",
      "cmbhuxxma004chxt8zpk2ktzi",
      "cmbhuxxmy004dhxt8e9xo29me",
      "cmbhuxy2v004fhxt8rplnk68y",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxy4b004hhxt85qfxts0l",
      "cmbhuxy52004ihxt8ilxcs2u1",
      "cmbhuxy6j004khxt8qk16jmrn",
      "cmbhuxy7c004lhxt89e7olf1b",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxyeo004vhxt8agmhgbad",
      "cmbhuxyfe004whxt8qe3z3au4",
      "cmbhuxyg4004xhxt8kbhdl3ex",
      "cmbhuxygu004yhxt81f1v2gsu",
      "cmbhuxyhk004zhxt8szdvzt2m",
      "cmbhuxyib0050hxt84li1uu95",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxz1a0053hxt8d5i3kzex",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxzft0056hxt82bi31hkb",
      "cmbhuxzgj0057hxt8kld412kw",
      "cmbhuxzh80058hxt8fniuwvqj",
      "cmbhuxzhy0059hxt81zfgzhi4",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuxzje005bhxt8zhktsovs",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuxzkv005dhxt8tktsk6gn",
      "cmbhuxzll005ehxt8u58l0k80",
      "cmbhuxzmn005fhxt8vw0ljp0t",
      "cmbhuy1pz006fhxt827vdomq8",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuy1su006jhxt8xroiozoa",
      "cmbhuy1u9006lhxt846p6ztwv",
      "cmbhuy1vt006nhxt84uadv93e",
      "cmbhuy1wj006ohxt8lcm8jv4e",
      "cmbhuy1x6006phxt8or6px97n",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2rf0077hxt8m94ldvxm",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy352007phxt8cjjtlth4",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d"
    ],
    "objects": [
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d"
    ],
    "strings": [
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxu410025hxt8ylv0xh71",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxuvg002ohxt8ydqy5mni",
      "cmbhuxuxs002rhxt8ny7coxj8",
      "cmbhuxuyj002shxt8u66jvno7",
      "cmbhuxuza002thxt89mb63y9k",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxvqc0039hxt8u37on9me",
      "cmbhuxvnb0035hxt8vys5zdse",
      "cmbhuxvo00036hxt8hdoh0aib",
      "cmbhuxy5t004jhxt81ai0mp7u",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxybu004rhxt821vvdjmk",
      "cmbhuxyck004shxt8xbifcpjd",
      "cmbhuxy2v004fhxt8rplnk68y",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxy4b004hhxt85qfxts0l",
      "cmbhuxy7c004lhxt89e7olf1b",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxyeo004vhxt8agmhgbad",
      "cmbhuxyfe004whxt8qe3z3au4",
      "cmbhuxyg4004xhxt8kbhdl3ex",
      "cmbhuxygu004yhxt81f1v2gsu",
      "cmbhuxyib0050hxt84li1uu95",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2kb006xhxt8u1i17kpa",
      "cmbhuy2l1006yhxt8catnrduz",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2pe0074hxt8fdzwqs4b",
      "cmbhuy2q40075hxt8cr97blxk",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2v8007chxt8e7bupdkv",
      "cmbhuy2vz007dhxt8ccxe4r3h",
      "cmbhuy2wq007ehxt81fty1pdt",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy3v1008ahxt8atag4bgu",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy380007thxt8ghmr7d9w",
      "cmbhuy38q007uhxt8ytt6q6au",
      "cmbhuy39g007vhxt8n81pfqi4",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy3gm0085hxt8r7wtl17m",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3xy008ehxt8p1upb3mt",
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d",
      "cmbhuy42a008khxt82nf2thrd",
      "cmbhuy3sl0087hxt862ok8q55"
    ],
    "async": [
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxuwz002qhxt8d1p114i6",
      "cmbhuxv5k0031hxt8h713wjbt",
      "cmbhuxx7e003thxt8a3fnleyl",
      "cmbhuxx85003uhxt8ysyfns6p",
      "cmbhuxx8w003vhxt8nblvhg45",
      "cmbhuxx9q003whxt82t576qha",
      "cmbhuxxag003xhxt80033zpaf",
      "cmbhuxxb6003yhxt8agyoqdvi",
      "cmbhuxxbx003zhxt8dtyuwmzw",
      "cmbhuxxco0040hxt8asigmboe",
      "cmbhuxxdf0041hxt8qtiizdxr",
      "cmbhuxxe60042hxt8395kf8t0",
      "cmbhuxxex0043hxt8dsobibwk",
      "cmbhuxxfo0044hxt82hrt8pdt",
      "cmbhuxxgf0045hxt8el43xkcy",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxxij0047hxt8eu8p0tk0",
      "cmbhuxxk10049hxt8swobackx",
      "cmbhuxxkr004ahxt8dk4jo9nh",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy3au007xhxt89b9es3au"
    ],
    "classes": [
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxtze001zhxt8gi7a8rbq",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxu0y0021hxt8m2amkhfg",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxu3a0024hxt8kgth0xff",
      "cmbhuxu410025hxt8ylv0xh71",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy3gm0085hxt8r7wtl17m",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3vr008bhxt8n8pagldu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d"
    ],
    "regex": [
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxydy004uhxt8pp8z6lbv",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxujl0028hxt8lotcvh0v",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxukd0029hxt8s70bhq5t",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxtze001zhxt8gi7a8rbq",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxu0y0021hxt8m2amkhfg",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxu3a0024hxt8kgth0xff",
      "cmbhuxu410025hxt8ylv0xh71",
      "cmbhuxul3002ahxt8xbqlc9h0",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxvr3003ahxt8w8d6zyjw",
      "cmbhuxuov002fhxt8df139lwi",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxutz002mhxt8s89q83nw",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxuvg002ohxt8ydqy5mni",
      "cmbhuxuwz002qhxt8d1p114i6",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxuxs002rhxt8ny7coxj8",
      "cmbhuxuza002thxt89mb63y9k",
      "cmbhuxv02002uhxt8d791nlzh",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxv4u0030hxt8z9gmuesj",
      "cmbhuxv5k0031hxt8h713wjbt",
      "cmbhuxvqc0039hxt8u37on9me",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxvmj0034hxt8pgunvy4a",
      "cmbhuxvnb0035hxt8vys5zdse",
      "cmbhuxvo00036hxt8hdoh0aib",
      "cmbhuxvpm0038hxt8di4dikfj",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxy5t004jhxt81ai0mp7u",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxx7e003thxt8a3fnleyl",
      "cmbhuxx85003uhxt8ysyfns6p",
      "cmbhuxybu004rhxt821vvdjmk",
      "cmbhuxx8w003vhxt8nblvhg45",
      "cmbhuxxag003xhxt80033zpaf",
      "cmbhuxxb6003yhxt8agyoqdvi",
      "cmbhuxyck004shxt8xbifcpjd",
      "cmbhuxxbx003zhxt8dtyuwmzw",
      "cmbhuxxdf0041hxt8qtiizdxr",
      "cmbhuxxe60042hxt8395kf8t0",
      "cmbhuxxex0043hxt8dsobibwk",
      "cmbhuxxfo0044hxt82hrt8pdt",
      "cmbhuxxgf0045hxt8el43xkcy",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxxij0047hxt8eu8p0tk0",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxxk10049hxt8swobackx",
      "cmbhuxxkr004ahxt8dk4jo9nh",
      "cmbhuxxli004bhxt85icwha27",
      "cmbhuxxma004chxt8zpk2ktzi",
      "cmbhuxxmy004dhxt8e9xo29me",
      "cmbhuxy2v004fhxt8rplnk68y",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxy4b004hhxt85qfxts0l",
      "cmbhuxy52004ihxt8ilxcs2u1",
      "cmbhuxy7c004lhxt89e7olf1b",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxyeo004vhxt8agmhgbad",
      "cmbhuxyfe004whxt8qe3z3au4",
      "cmbhuxyhk004zhxt8szdvzt2m",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxzje005bhxt8zhktsovs",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuxzkv005dhxt8tktsk6gn",
      "cmbhuxzll005ehxt8u58l0k80",
      "cmbhuxzmn005fhxt8vw0ljp0t",
      "cmbhuy1qp006ghxt8kwicddvy",
      "cmbhuy1ux006mhxt8ar2iyqhv",
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy1zw006thxt87fseef70",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2kb006xhxt8u1i17kpa",
      "cmbhuy2l1006yhxt8catnrduz",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2n50071hxt8veiwl712",
      "cmbhuy2nv0072hxt8detdynqf",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2vz007dhxt8ccxe4r3h",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy3v1008ahxt8atag4bgu",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy352007phxt8cjjtlth4",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy380007thxt8ghmr7d9w",
      "cmbhuy38q007uhxt8ytt6q6au",
      "cmbhuy39g007vhxt8n81pfqi4",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3au007xhxt89b9es3au",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy3gm0085hxt8r7wtl17m",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3vr008bhxt8n8pagldu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3xy008ehxt8p1upb3mt",
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d",
      "cmbhuy42a008khxt82nf2thrd",
      "cmbhuy3sl0087hxt862ok8q55"
    ],
    "path_Очень простые (базовые операции и манипуляции)": [
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxs2l0002hxt8dctlk266",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxz1a0053hxt8d5i3kzex",
      "cmbhuxz200054hxt8dg7mgp5i"
    ],
    "path_Рефакторинг Мини-Задач": [
      "cmbhuy10w0065hxt811552rzr",
      "cmbhuy11s0066hxt8hwryorh4",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuy0xa0060hxt8gj17myut",
      "cmbhuy0y00061hxt8t6b6zbyr",
      "cmbhuy0yq0062hxt8eh9stuz5",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuy1060064hxt8qznw71e2"
    ],
    "path_Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)": [
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsn3000qhxt8if58l0g2",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7"
    ],
    "path_Средние – сложные (задачи с более высоким алгоритмическим накалом)": [
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxtd2001ohxt8fy12nxiy",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtg2001shxt84ztkofyt"
    ],
    "path_1. эммитер": [
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12"
    ],
    "path_Банкоматы": [
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif"
    ],
    "path_3. IBS": [
      "cmbhuy1pz006fhxt827vdomq8",
      "cmbhuy1qp006ghxt8kwicddvy",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuy1s5006ihxt80rls5703"
    ],
    "path_4. РСХБ": [
      "cmbhuy1su006jhxt8xroiozoa",
      "cmbhuy1u9006lhxt846p6ztwv",
      "cmbhuy1ux006mhxt8ar2iyqhv",
      "cmbhuy1vt006nhxt84uadv93e"
    ],
    "path_5. Тренировочные No Name": [
      "cmbhuy1wj006ohxt8lcm8jv4e",
      "cmbhuy1x6006phxt8or6px97n",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuy1zw006thxt87fseef70"
    ],
    "path_Пачка мини задач": [
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2kb006xhxt8u1i17kpa",
      "cmbhuy2l1006yhxt8catnrduz",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2n50071hxt8veiwl712",
      "cmbhuy2nv0072hxt8detdynqf",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2pe0074hxt8fdzwqs4b",
      "cmbhuy2q40075hxt8cr97blxk",
      "cmbhuy2qq0076hxt8m3fpwumd",
      "cmbhuy2rf0077hxt8m94ldvxm",
      "cmbhuy2s50078hxt8jvhpsvfe",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2v8007chxt8e7bupdkv",
      "cmbhuy2vz007dhxt8ccxe4r3h",
      "cmbhuy2wq007ehxt81fty1pdt"
    ],
    "path_Функции (дженерики)": [
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy352007phxt8cjjtlth4",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2"
    ],
    "path_Основные": [
      "cmbhuy3v1008ahxt8atag4bgu",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3vr008bhxt8n8pagldu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3xy008ehxt8p1upb3mt",
      "cmbhuy3sl0087hxt862ok8q55"
    ],
    "path_Кастомные Utility": [
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy380007thxt8ghmr7d9w",
      "cmbhuy38q007uhxt8ytt6q6au",
      "cmbhuy39g007vhxt8n81pfqi4",
      "cmbhuy3a5007whxt8uubhszum"
    ],
    "path_Types": [
      "cmbhuy3au007xhxt89b9es3au",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy3gm0085hxt8r7wtl17m"
    ],
    "path_Остальные": [
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d",
      "cmbhuy42a008khxt82nf2thrd"
    ],
    "difficulty_beginner": [
      "cmbhuxs2l0002hxt8dctlk266",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuy10w0065hxt811552rzr",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxsn3000qhxt8if58l0g2",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuy11s0066hxt8hwryorh4",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxtd2001ohxt8fy12nxiy",
      "cmbhuxujl0028hxt8lotcvh0v",
      "cmbhuxukd0029hxt8s70bhq5t",
      "cmbhuxul3002ahxt8xbqlc9h0",
      "cmbhuxumn002chxt8l6eazjvy",
      "cmbhuxune002dhxt8aic7842d",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxutz002mhxt8s89q83nw",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxuw8002phxt8zdhyaonc",
      "cmbhuy0xa0060hxt8gj17myut",
      "cmbhuy0y00061hxt8t6b6zbyr",
      "cmbhuxvqc0039hxt8u37on9me",
      "cmbhuxvo00036hxt8hdoh0aib",
      "cmbhuxvpm0038hxt8di4dikfj",
      "cmbhuy0yq0062hxt8eh9stuz5",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuxybu004rhxt821vvdjmk",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuxxfo0044hxt82hrt8pdt",
      "cmbhuxxgf0045hxt8el43xkcy",
      "cmbhuxxij0047hxt8eu8p0tk0",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxxk10049hxt8swobackx",
      "cmbhuxxkr004ahxt8dk4jo9nh",
      "cmbhuxxli004bhxt85icwha27",
      "cmbhuxxma004chxt8zpk2ktzi",
      "cmbhuxxmy004dhxt8e9xo29me",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxy7c004lhxt89e7olf1b",
      "cmbhuxy9l004ohxt8vxpf2cah",
      "cmbhuxyg4004xhxt8kbhdl3ex",
      "cmbhuxyhk004zhxt8szdvzt2m",
      "cmbhuxz1a0053hxt8d5i3kzex",
      "cmbhuxzft0056hxt82bi31hkb",
      "cmbhuxzh80058hxt8fniuwvqj",
      "cmbhuxzhy0059hxt81zfgzhi4",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuxzkv005dhxt8tktsk6gn",
      "cmbhuxzll005ehxt8u58l0k80",
      "cmbhuxzmn005fhxt8vw0ljp0t",
      "cmbhuy1n2006bhxt89i7z4fpq",
      "cmbhuy1oj006dhxt8hs4zuobs",
      "cmbhuy1pz006fhxt827vdomq8",
      "cmbhuy1qp006ghxt8kwicddvy",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuy1s5006ihxt80rls5703",
      "cmbhuy1su006jhxt8xroiozoa",
      "cmbhuy1u9006lhxt846p6ztwv",
      "cmbhuy1ux006mhxt8ar2iyqhv",
      "cmbhuy1vt006nhxt84uadv93e",
      "cmbhuy1wj006ohxt8lcm8jv4e",
      "cmbhuy1x6006phxt8or6px97n",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuy1zw006thxt87fseef70",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2kb006xhxt8u1i17kpa",
      "cmbhuy2l1006yhxt8catnrduz",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuy2n50071hxt8veiwl712",
      "cmbhuy2nv0072hxt8detdynqf",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2pe0074hxt8fdzwqs4b",
      "cmbhuy2q40075hxt8cr97blxk",
      "cmbhuy2qq0076hxt8m3fpwumd",
      "cmbhuy2rf0077hxt8m94ldvxm",
      "cmbhuy2s50078hxt8jvhpsvfe",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2v8007chxt8e7bupdkv",
      "cmbhuy2vz007dhxt8ccxe4r3h",
      "cmbhuy2wq007ehxt81fty1pdt",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy3v1008ahxt8atag4bgu",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy380007thxt8ghmr7d9w",
      "cmbhuy38q007uhxt8ytt6q6au",
      "cmbhuy39g007vhxt8n81pfqi4",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy3au007xhxt89b9es3au",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuy3gm0085hxt8r7wtl17m",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3vr008bhxt8n8pagldu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3xy008ehxt8p1upb3mt",
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy42a008khxt82nf2thrd",
      "cmbhuy3sl0087hxt862ok8q55"
    ],
    "difficulty_intermediate": [
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxuiu0027hxt8b2ukzqum",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7",
      "cmbhuxtze001zhxt8gi7a8rbq",
      "cmbhuxu410025hxt8ylv0xh71",
      "cmbhuxulw002bhxt8d5lmmlb8",
      "cmbhuxvr3003ahxt8w8d6zyjw",
      "cmbhuxuov002fhxt8df139lwi",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxuvg002ohxt8ydqy5mni",
      "cmbhuxv02002uhxt8d791nlzh",
      "cmbhuxv4u0030hxt8z9gmuesj",
      "cmbhuxvnb0035hxt8vys5zdse",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxy5t004jhxt81ai0mp7u",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxx9q003whxt82t576qha",
      "cmbhuxyck004shxt8xbifcpjd",
      "cmbhuxxbx003zhxt8dtyuwmzw",
      "cmbhuxxdf0041hxt8qtiizdxr",
      "cmbhuxxe60042hxt8395kf8t0",
      "cmbhuxy2v004fhxt8rplnk68y",
      "cmbhuxy52004ihxt8ilxcs2u1",
      "cmbhuxy6j004khxt8qk16jmrn",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxyeo004vhxt8agmhgbad",
      "cmbhuxyfe004whxt8qe3z3au4",
      "cmbhuxyib0050hxt84li1uu95",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxzgj0057hxt8kld412kw",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuxzje005bhxt8zhktsovs",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy352007phxt8cjjtlth4",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d"
    ],
    "difficulty_advanced": [
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxydy004uhxt8pp8z6lbv",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxu0y0021hxt8m2amkhfg",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxu3a0024hxt8kgth0xff",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxwe2003chxt8rwypcfj0",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxuwz002qhxt8d1p114i6",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxuxs002rhxt8ny7coxj8",
      "cmbhuxuyj002shxt8u66jvno7",
      "cmbhuxuza002thxt89mb63y9k",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxv5k0031hxt8h713wjbt",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxvmj0034hxt8pgunvy4a",
      "cmbhuxvou0037hxt8lxnj0pjo",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxx7e003thxt8a3fnleyl",
      "cmbhuxx85003uhxt8ysyfns6p",
      "cmbhuxx8w003vhxt8nblvhg45",
      "cmbhuxxag003xhxt80033zpaf",
      "cmbhuxxb6003yhxt8agyoqdvi",
      "cmbhuxxco0040hxt8asigmboe",
      "cmbhuxxex0043hxt8dsobibwk",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxyda004thxt88zlcfy7p",
      "cmbhuxy4b004hhxt85qfxts0l",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxygu004yhxt81f1v2gsu"
    ]
  },
  "learning_sequences": {
    "sequence_arrays": [
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxyda004thxt88zlcfy7p",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxygu004yhxt81f1v2gsu",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxtxs001xhxt8l4xr9x12"
    ],
    "sequence_functions": [
      "cmbhuxzft0056hxt82bi31hkb",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxzkv005dhxt8tktsk6gn",
      "cmbhuxutz002mhxt8s89q83nw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2rf0077hxt8m94ldvxm",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuxujl0028hxt8lotcvh0v",
      "cmbhuxukd0029hxt8s70bhq5t",
      "cmbhuxzh80058hxt8fniuwvqj",
      "cmbhuxvo00036hxt8hdoh0aib",
      "cmbhuxzhy0059hxt81zfgzhi4",
      "cmbhuxune002dhxt8aic7842d",
      "cmbhuxvqc0039hxt8u37on9me",
      "cmbhuxzll005ehxt8u58l0k80",
      "cmbhuxzmn005fhxt8vw0ljp0t",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuxxfo0044hxt82hrt8pdt",
      "cmbhuxxgf0045hxt8el43xkcy",
      "cmbhuxxij0047hxt8eu8p0tk0",
      "cmbhuxxja0048hxt8v4ipmslc",
      "cmbhuxxk10049hxt8swobackx",
      "cmbhuxxkr004ahxt8dk4jo9nh",
      "cmbhuxuw8002phxt8zdhyaonc",
      "cmbhuxxma004chxt8zpk2ktzi",
      "cmbhuxxmy004dhxt8e9xo29me",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy1pz006fhxt827vdomq8",
      "cmbhuy2me0070hxt8b1jxq7em",
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuy1rf006hhxt8rnl5bawz",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuy1su006jhxt8xroiozoa",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuy1u9006lhxt846p6ztwv",
      "cmbhuy1wj006ohxt8lcm8jv4e",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuy0xa0060hxt8gj17myut",
      "cmbhuy0y00061hxt8t6b6zbyr",
      "cmbhuy0yq0062hxt8eh9stuz5",
      "cmbhuy1vt006nhxt84uadv93e",
      "cmbhuy10w0065hxt811552rzr",
      "cmbhuy1x6006phxt8or6px97n",
      "cmbhuy11s0066hxt8hwryorh4",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuxul3002ahxt8xbqlc9h0",
      "cmbhuxumn002chxt8l6eazjvy",
      "cmbhuxvpm0038hxt8di4dikfj",
      "cmbhuxy7c004lhxt89e7olf1b",
      "cmbhuxzk5005chxt8jwkhfvzo",
      "cmbhuxuo7002ehxt8wv0wa0s9",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxybu004rhxt821vvdjmk",
      "cmbhuxyg4004xhxt8kbhdl3ex",
      "cmbhuxyhk004zhxt8szdvzt2m",
      "cmbhuxs2l0002hxt8dctlk266",
      "cmbhuxz1a0053hxt8d5i3kzex",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxuiu0027hxt8b2ukzqum",
      "cmbhuxy2v004fhxt8rplnk68y",
      "cmbhuxzgj0057hxt8kld412kw",
      "cmbhuxy52004ihxt8ilxcs2u1",
      "cmbhuxulw002bhxt8d5lmmlb8",
      "cmbhuxzje005bhxt8zhktsovs",
      "cmbhuxxe60042hxt8395kf8t0",
      "cmbhuxusg002khxt8u0cts5iq",
      "cmbhuxyck004shxt8xbifcpjd",
      "cmbhuxyib0050hxt84li1uu95",
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuxy5t004jhxt81ai0mp7u",
      "cmbhuxy6j004khxt8qk16jmrn",
      "cmbhuxxbx003zhxt8dtyuwmzw",
      "cmbhuxvr3003ahxt8w8d6zyjw",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxyb2004qhxt89kew43p2",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxyeo004vhxt8agmhgbad",
      "cmbhuxyfe004whxt8qe3z3au4",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuy352007phxt8cjjtlth4",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxvnb0035hxt8vys5zdse",
      "cmbhuxx9q003whxt82t576qha",
      "cmbhuxtze001zhxt8gi7a8rbq",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxuov002fhxt8df139lwi",
      "cmbhuxxdf0041hxt8qtiizdxr",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxuvg002ohxt8ydqy5mni",
      "cmbhuxv02002uhxt8d791nlzh",
      "cmbhuxv4u0030hxt8z9gmuesj",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxx7e003thxt8a3fnleyl",
      "cmbhuxxag003xhxt80033zpaf",
      "cmbhuxu0y0021hxt8m2amkhfg",
      "cmbhuxxco0040hxt8asigmboe",
      "cmbhuxuq9002hhxt8khog3l32",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxuwz002qhxt8d1p114i6",
      "cmbhuxuyj002shxt8u66jvno7",
      "cmbhuxuza002thxt89mb63y9k",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuxxb6003yhxt8agyoqdvi",
      "cmbhuxu3a0024hxt8kgth0xff",
      "cmbhuxur0002ihxt8zeku9txm",
      "cmbhuxxhs0046hxt869yx2p6j",
      "cmbhuxut7002lhxt8qmwr0xmj",
      "cmbhuxydy004uhxt8pp8z6lbv",
      "cmbhuxuxs002rhxt8ny7coxj8",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxx85003uhxt8ysyfns6p",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxxex0043hxt8dsobibwk",
      "cmbhuxyda004thxt88zlcfy7p",
      "cmbhuxv5k0031hxt8h713wjbt",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxwe2003chxt8rwypcfj0",
      "cmbhuxvmj0034hxt8pgunvy4a",
      "cmbhuxy4b004hhxt85qfxts0l",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxurr002jhxt8q7700ftr",
      "cmbhuxygu004yhxt81f1v2gsu",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxv43002zhxt8rlqm3i8g",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxvou0037hxt8lxnj0pjo",
      "cmbhuxv0u002vhxt8eoifk8pr",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxvlt0033hxt8orquj5qz",
      "cmbhuxtyl001yhxt8pgy5uxwd",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxsmb000phxt8itoanhpn",
      "cmbhuxtcb001nhxt8r4jhte4d",
      "cmbhuxy8t004nhxt8zhgv3hm2",
      "cmbhuxx8w003vhxt8nblvhg45",
      "cmbhuxyab004phxt8e0cuwcew",
      "cmbhuxtxs001xhxt8l4xr9x12"
    ],
    "sequence_objects": [
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuxwll003mhxt8uaub838w",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuy3a5007whxt8uubhszum",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuxwk5003khxt8zzpe4n0p",
      "cmbhuxwkv003lhxt8og7qs4xq",
      "cmbhuxwn2003ohxt8r75wdyfw",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuy3fv0084hxt8n2w0kc2z",
      "cmbhuxwmb003nhxt8pxpfkxxk",
      "cmbhuxwoq003qhxt89loz0fmq",
      "cmbhuxwpg003rhxt8qckt1kte",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxwet003dhxt8pj55oqwk",
      "cmbhuxwht003hhxt8g1rmis4k",
      "cmbhuxupk002ghxt8wr5jtnth",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxwns003phxt8etnfnnm2",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuy12c0067hxt8uobjhtnj",
      "cmbhuxu050020hxt8rivfqodp",
      "cmbhuxwik003ihxt85wanudxu",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxwga003fhxt88xcx9kb6",
      "cmbhuxwh3003ghxt8bp1vouz7",
      "cmbhuxwjb003jhxt8vlwlon6v",
      "cmbhuxu1p0022hxt83jo9hqhv",
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxsal000bhxt8dfksgob4",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxwfk003ehxt8iwndvw9w",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxu2i0023hxt8epssc7k4",
      "cmbhuxsmb000phxt8itoanhpn"
    ],
    "sequence_path_Очень простые (базовые операции и манипуляции)": [
      "cmbhuxs790007hxt8g1jizp82",
      "cmbhuxs8z0009hxt8fsu4q7ua",
      "cmbhuxsbg000chxt8q5heziq4",
      "cmbhuxs2l0002hxt8dctlk266",
      "cmbhuxz1a0053hxt8d5i3kzex",
      "cmbhuxs9s000ahxt88qwbi2pw",
      "cmbhuxseu000ghxt8opsb2bi3",
      "cmbhuxsfo000hhxt8oipcq3ea",
      "cmbhuxshd000jhxt86edflvmv",
      "cmbhuxs160001hxt8uz4eqqjd",
      "cmbhuxz0l0052hxt84b9954qa",
      "cmbhuxs3r0003hxt832dkijfk",
      "cmbhuxz200054hxt8dg7mgp5i",
      "cmbhuxs4l0004hxt8hdong1mr",
      "cmbhuxs5g0005hxt8x2y5feb2",
      "cmbhuxs840008hxt8a0rxzu9x",
      "cmbhuxs6c0006hxt8x2p6v3wk",
      "cmbhuxsd4000ehxt8nq3amqoc",
      "cmbhuxse0000fhxt8nb582gbd",
      "cmbhuxsca000dhxt8m5yyv4gm",
      "cmbhuxsgj000ihxt81mj8tdm1",
      "cmbhuxsal000bhxt8dfksgob4"
    ],
    "sequence_path_Рефакторинг Мини-Задач": [
      "cmbhuy0xa0060hxt8gj17myut",
      "cmbhuy0y00061hxt8t6b6zbyr",
      "cmbhuy0yq0062hxt8eh9stuz5",
      "cmbhuy10w0065hxt811552rzr",
      "cmbhuy11s0066hxt8hwryorh4",
      "cmbhuy1340068hxt8rr8dkllm",
      "cmbhuy1060064hxt8qznw71e2",
      "cmbhuy12c0067hxt8uobjhtnj"
    ],
    "sequence_path_Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)": [
      "cmbhuxsi8000khxt8miwsvf7a",
      "cmbhuxsn3000qhxt8if58l0g2",
      "cmbhuxt1t0019hxt8yjb87kml",
      "cmbhuxspr000thxt8s9q02p1e",
      "cmbhuxsj2000lhxt8spvqq9qi",
      "cmbhuxslk000ohxt85z73ewby",
      "cmbhuxsx70013hxt8zwbvqw1r",
      "cmbhuxsp2000shxt8nyk551gp",
      "cmbhuxsqi000uhxt8o4zdjzfq",
      "cmbhuxsr6000vhxt8o7lusubh",
      "cmbhuxswg0012hxt8n4yrpbib",
      "cmbhuxt72001ghxt8pr2hu15q",
      "cmbhuxt7p001hhxt8zl086kkd",
      "cmbhuxt8f001ihxt868gwtoaf",
      "cmbhuxt93001jhxt8ad06wrjj",
      "cmbhuxt9u001khxt80ap2d64f",
      "cmbhuxtal001lhxt8g54m0uw7",
      "cmbhuxt2j001ahxt8q3u4owni",
      "cmbhuxt43001chxt8c5ef7t0l",
      "cmbhuxt4z001dhxt8l9ljgo5u",
      "cmbhuxsju000mhxt8e9xlo12g",
      "cmbhuxsta000yhxt8ilfyq0h2",
      "cmbhuxsvn0011hxt8r0b9i3vj",
      "cmbhuxt6f001fhxt8golwlbem",
      "cmbhuxsns000rhxt83t1y6ycl",
      "cmbhuxsrt000whxt8mzlqm6m7",
      "cmbhuxsyq0015hxt8o5vrnxnv",
      "cmbhuxt120018hxt8ty4t80oh",
      "cmbhuxsko000nhxt8peqhyvt5",
      "cmbhuxssj000xhxt8wvbzx32d",
      "cmbhuxsu1000zhxt811rhkmjp",
      "cmbhuxszi0016hxt815baeecs",
      "cmbhuxt0a0017hxt89ph9ttca",
      "cmbhuxt5p001ehxt8koihztlr",
      "cmbhuxsut0010hxt8nls1xgze",
      "cmbhuxsxz0014hxt85lc589ao",
      "cmbhuxt3c001bhxt80d4ppktd",
      "cmbhuxsmb000phxt8itoanhpn"
    ],
    "sequence_path_Средние – сложные (задачи с более высоким алгоритмическим накалом)": [
      "cmbhuxtd2001ohxt8fy12nxiy",
      "cmbhuxtdt001phxt8sus1xbly",
      "cmbhuxtfb001rhxt8mtm6j2j3",
      "cmbhuxtbd001mhxt8k0it92zs",
      "cmbhuxtg2001shxt84ztkofyt",
      "cmbhuxtek001qhxt8dp3pcpki",
      "cmbhuxtcb001nhxt8r4jhte4d"
    ],
    "sequence_path_1. эммитер": [
      "cmbhuxtvk001uhxt8fcidaqns",
      "cmbhuxtw9001vhxt81jngl6xv",
      "cmbhuxtx0001whxt8x62v3c2t",
      "cmbhuxtxs001xhxt8l4xr9x12"
    ],
    "sequence_path_Банкоматы": [
      "cmbhuxv1n002whxt8sxl78206",
      "cmbhuxv2d002xhxt8vf2kulif",
      "cmbhuxv0u002vhxt8eoifk8pr"
    ],
    "sequence_path_3. IBS": [
      "cmbhuy1qp006ghxt8kwicddvy",
      "cmbhuy1s5006ihxt80rls5703",
      "cmbhuy1pz006fhxt827vdomq8",
      "cmbhuy1rf006hhxt8rnl5bawz"
    ],
    "sequence_path_4. РСХБ": [
      "cmbhuy1ux006mhxt8ar2iyqhv",
      "cmbhuy1su006jhxt8xroiozoa",
      "cmbhuy1u9006lhxt846p6ztwv",
      "cmbhuy1vt006nhxt84uadv93e"
    ],
    "sequence_path_5. Тренировочные No Name": [
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy1zw006thxt87fseef70",
      "cmbhuy1wj006ohxt8lcm8jv4e",
      "cmbhuy1xu006qhxt86kgv30xl",
      "cmbhuy1z9006shxt84an8bb1h",
      "cmbhuy1x6006phxt8or6px97n"
    ],
    "sequence_path_Пачка мини задач": [
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2kb006xhxt8u1i17kpa",
      "cmbhuy2l1006yhxt8catnrduz",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2n50071hxt8veiwl712",
      "cmbhuy2nv0072hxt8detdynqf",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2pe0074hxt8fdzwqs4b",
      "cmbhuy2q40075hxt8cr97blxk",
      "cmbhuy2qq0076hxt8m3fpwumd",
      "cmbhuy2rf0077hxt8m94ldvxm",
      "cmbhuy2s50078hxt8jvhpsvfe",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy2ui007bhxt8hgk2w0pl",
      "cmbhuy2v8007chxt8e7bupdkv",
      "cmbhuy2vz007dhxt8ccxe4r3h",
      "cmbhuy2wq007ehxt81fty1pdt",
      "cmbhuy2iu006vhxt89nmcbbrz",
      "cmbhuy2me0070hxt8b1jxq7em"
    ],
    "sequence_path_Функции (дженерики)": [
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuy2y9007ghxt8lfyjm59h",
      "cmbhuy2z0007hhxt87xuvf2xs",
      "cmbhuy2zt007ihxt8bdmtcpjw",
      "cmbhuy32v007mhxt8k4ik2zgo",
      "cmbhuy33l007nhxt8sa859h13",
      "cmbhuy35t007qhxt8x4cgbbz6",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy31f007khxt80sddujss",
      "cmbhuy30p007jhxt8bg5ixnq1",
      "cmbhuy325007lhxt86vgypxw2",
      "cmbhuy34c007ohxt8v6ttstm0",
      "cmbhuy352007phxt8cjjtlth4"
    ],
    "sequence_path_Основные": [
      "cmbhuy3sl0087hxt862ok8q55",
      "cmbhuy3tm0088hxt834j8dyun",
      "cmbhuy3uc0089hxt8krntlulu",
      "cmbhuy3v1008ahxt8atag4bgu",
      "cmbhuy3vr008bhxt8n8pagldu",
      "cmbhuy3wh008chxt84npe05nn",
      "cmbhuy3x8008dhxt8op0ca7dv",
      "cmbhuy3xy008ehxt8p1upb3mt"
    ],
    "sequence_path_Кастомные Utility": [
      "cmbhuy37b007shxt89u9en64j",
      "cmbhuy380007thxt8ghmr7d9w",
      "cmbhuy38q007uhxt8ytt6q6au",
      "cmbhuy39g007vhxt8n81pfqi4",
      "cmbhuy3a5007whxt8uubhszum"
    ],
    "sequence_path_Types": [
      "cmbhuy3au007xhxt89b9es3au",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy3cb007zhxt8puxkl9g5",
      "cmbhuy3dq0081hxt841clr2fy",
      "cmbhuy3ee0082hxt8dp83qyyf",
      "cmbhuy3gm0085hxt8r7wtl17m",
      "cmbhuy3d00080hxt8mdxc84cu",
      "cmbhuy3f60083hxt8dfggnqaq",
      "cmbhuy3fv0084hxt8n2w0kc2z"
    ],
    "sequence_path_Остальные": [
      "cmbhuy3yo008fhxt8xelf9055",
      "cmbhuy3ze008ghxt8vkuo0bfz",
      "cmbhuy404008hhxt8va6h5gkk",
      "cmbhuy42a008khxt82nf2thrd",
      "cmbhuy40u008ihxt84rm3e87z",
      "cmbhuy41k008jhxt8567luw6d"
    ],
    "recommended_learning_path": [
      "cmbhuxutz002mhxt8s89q83nw",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuy36i007rhxt8fn97eyx2",
      "cmbhuy3bk007yhxt8a122lgc4",
      "cmbhuy2lo006zhxt8yh97zy0d",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2xh007fhxt8edo8sk4e",
      "cmbhuxuuq002nhxt8rooy764b",
      "cmbhuxy3l004ghxt81t8b68uu",
      "cmbhuy2jm006whxt8qj3a708h",
      "cmbhuy2om0073hxt8pixlf1r6",
      "cmbhuy2su0079hxt8yxbqxsw9",
      "cmbhuy2to007ahxt8ilyp40ji",
      "cmbhuy1yj006rhxt8mx0awegy",
      "cmbhuy3au007xhxt89b9es3au",
      "cmbhuxxfo0044hxt82hrt8pdt"
    ]
  },
  "path_structure": {
    "depth_distribution": {
      "1": 144,
      "2": 16,
      "0": 109
    },
    "common_paths": {
      "Очень простые (базовые операции и манипуляции)": 22,
      "Рефакторинг Мини-Задач": 8,
      "Рефакторинг Мини-Задач > 2. IT-One": 3,
      "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)": 38,
      "Средние – сложные (задачи с более высоким алгоритмическим накалом)": 7,
      "1. эммитер": 4,
      "Рефакторинг Мини-Задач > 3. ОТП БАНК": 1,
      "Банкоматы": 3,
      "Рефакторинг Мини-Задач > 1. СберБанк": 3,
      "Банкоматы > Банкомат в трех частях": 2,
      "ВК  canonizePath в трех частях": 1,
      "Рефакторинг Мини-Задач > 4. IBS": 1,
      "1. Иннотех": 1,
      "2. Tele2": 1,
      "3. IBS": 4,
      "3. IBS > Композитные компоненты": 1,
      "4. РСХБ": 4,
      "4. РСХБ > Усложнение (с setTimeout)": 2,
      "5. Тренировочные No Name": 6,
      "5. Тренировочные No Name > 1. Что будет в Clicker?": 1,
      "5. Тренировочные No Name > 2. Последовательность логов": 1,
      "5. Тренировочные No Name > 3. Последовательность логов": 1,
      "Пачка мини задач": 20,
      "Функции (дженерики)": 13,
      "Основные": 8,
      "Кастомные Utility": 5,
      "Types": 9,
      "Остальные": 6
    },
    "path_hierarchies": {
      "Очень простые (базовые операции и манипуляции)": [
        "cmbhuxs160001hxt8uz4eqqjd",
        "cmbhuxs2l0002hxt8dctlk266",
        "cmbhuxs3r0003hxt832dkijfk",
        "cmbhuxs4l0004hxt8hdong1mr",
        "cmbhuxs5g0005hxt8x2y5feb2",
        "cmbhuxs6c0006hxt8x2p6v3wk",
        "cmbhuxs790007hxt8g1jizp82",
        "cmbhuxs840008hxt8a0rxzu9x",
        "cmbhuxs8z0009hxt8fsu4q7ua",
        "cmbhuxs9s000ahxt88qwbi2pw",
        "cmbhuxsal000bhxt8dfksgob4",
        "cmbhuxsbg000chxt8q5heziq4",
        "cmbhuxsca000dhxt8m5yyv4gm",
        "cmbhuxsd4000ehxt8nq3amqoc",
        "cmbhuxse0000fhxt8nb582gbd",
        "cmbhuxseu000ghxt8opsb2bi3",
        "cmbhuxsfo000hhxt8oipcq3ea",
        "cmbhuxsgj000ihxt81mj8tdm1",
        "cmbhuxshd000jhxt86edflvmv",
        "cmbhuxz0l0052hxt84b9954qa",
        "cmbhuxz1a0053hxt8d5i3kzex",
        "cmbhuxz200054hxt8dg7mgp5i"
      ],
      "Рефакторинг Мини-Задач": [
        "cmbhuy10w0065hxt811552rzr",
        "cmbhuy11s0066hxt8hwryorh4",
        "cmbhuy12c0067hxt8uobjhtnj",
        "cmbhuy0xa0060hxt8gj17myut",
        "cmbhuy0y00061hxt8t6b6zbyr",
        "cmbhuy0yq0062hxt8eh9stuz5",
        "cmbhuy1340068hxt8rr8dkllm",
        "cmbhuy1060064hxt8qznw71e2"
      ],
      "Лёгкие – средние (классические алгоритмические задачи, базовая работа с массивами)": [
        "cmbhuxsi8000khxt8miwsvf7a",
        "cmbhuxsj2000lhxt8spvqq9qi",
        "cmbhuxsju000mhxt8e9xlo12g",
        "cmbhuxsko000nhxt8peqhyvt5",
        "cmbhuxslk000ohxt85z73ewby",
        "cmbhuxsmb000phxt8itoanhpn",
        "cmbhuxsn3000qhxt8if58l0g2",
        "cmbhuxsns000rhxt83t1y6ycl",
        "cmbhuxsp2000shxt8nyk551gp",
        "cmbhuxspr000thxt8s9q02p1e",
        "cmbhuxsqi000uhxt8o4zdjzfq",
        "cmbhuxsr6000vhxt8o7lusubh",
        "cmbhuxsrt000whxt8mzlqm6m7",
        "cmbhuxssj000xhxt8wvbzx32d",
        "cmbhuxsta000yhxt8ilfyq0h2",
        "cmbhuxsu1000zhxt811rhkmjp",
        "cmbhuxsut0010hxt8nls1xgze",
        "cmbhuxsvn0011hxt8r0b9i3vj",
        "cmbhuxswg0012hxt8n4yrpbib",
        "cmbhuxsx70013hxt8zwbvqw1r",
        "cmbhuxsxz0014hxt85lc589ao",
        "cmbhuxsyq0015hxt8o5vrnxnv",
        "cmbhuxszi0016hxt815baeecs",
        "cmbhuxt0a0017hxt89ph9ttca",
        "cmbhuxt120018hxt8ty4t80oh",
        "cmbhuxt1t0019hxt8yjb87kml",
        "cmbhuxt2j001ahxt8q3u4owni",
        "cmbhuxt3c001bhxt80d4ppktd",
        "cmbhuxt72001ghxt8pr2hu15q",
        "cmbhuxt43001chxt8c5ef7t0l",
        "cmbhuxt4z001dhxt8l9ljgo5u",
        "cmbhuxt5p001ehxt8koihztlr",
        "cmbhuxt6f001fhxt8golwlbem",
        "cmbhuxt7p001hhxt8zl086kkd",
        "cmbhuxt8f001ihxt868gwtoaf",
        "cmbhuxt93001jhxt8ad06wrjj",
        "cmbhuxt9u001khxt80ap2d64f",
        "cmbhuxtal001lhxt8g54m0uw7"
      ],
      "Средние – сложные (задачи с более высоким алгоритмическим накалом)": [
        "cmbhuxtbd001mhxt8k0it92zs",
        "cmbhuxtcb001nhxt8r4jhte4d",
        "cmbhuxtd2001ohxt8fy12nxiy",
        "cmbhuxtdt001phxt8sus1xbly",
        "cmbhuxtek001qhxt8dp3pcpki",
        "cmbhuxtfb001rhxt8mtm6j2j3",
        "cmbhuxtg2001shxt84ztkofyt"
      ],
      "1. эммитер": [
        "cmbhuxtvk001uhxt8fcidaqns",
        "cmbhuxtw9001vhxt81jngl6xv",
        "cmbhuxtx0001whxt8x62v3c2t",
        "cmbhuxtxs001xhxt8l4xr9x12"
      ],
      "Банкоматы": [
        "cmbhuxv0u002vhxt8eoifk8pr",
        "cmbhuxv1n002whxt8sxl78206",
        "cmbhuxv2d002xhxt8vf2kulif"
      ],
      "ВК  canonizePath в трех частях": [
        "cmbhuxv43002zhxt8rlqm3i8g"
      ],
      "1. Иннотех": [
        "cmbhuy1n2006bhxt89i7z4fpq"
      ],
      "2. Tele2": [
        "cmbhuy1oj006dhxt8hs4zuobs"
      ],
      "3. IBS": [
        "cmbhuy1pz006fhxt827vdomq8",
        "cmbhuy1qp006ghxt8kwicddvy",
        "cmbhuy1rf006hhxt8rnl5bawz",
        "cmbhuy1s5006ihxt80rls5703"
      ],
      "4. РСХБ": [
        "cmbhuy1su006jhxt8xroiozoa",
        "cmbhuy1u9006lhxt846p6ztwv",
        "cmbhuy1ux006mhxt8ar2iyqhv",
        "cmbhuy1vt006nhxt84uadv93e"
      ],
      "5. Тренировочные No Name": [
        "cmbhuy1wj006ohxt8lcm8jv4e",
        "cmbhuy1x6006phxt8or6px97n",
        "cmbhuy1xu006qhxt86kgv30xl",
        "cmbhuy1yj006rhxt8mx0awegy",
        "cmbhuy1z9006shxt84an8bb1h",
        "cmbhuy1zw006thxt87fseef70"
      ],
      "Пачка мини задач": [
        "cmbhuy2iu006vhxt89nmcbbrz",
        "cmbhuy2jm006whxt8qj3a708h",
        "cmbhuy2kb006xhxt8u1i17kpa",
        "cmbhuy2l1006yhxt8catnrduz",
        "cmbhuy2lo006zhxt8yh97zy0d",
        "cmbhuy2me0070hxt8b1jxq7em",
        "cmbhuy2n50071hxt8veiwl712",
        "cmbhuy2nv0072hxt8detdynqf",
        "cmbhuy2om0073hxt8pixlf1r6",
        "cmbhuy2pe0074hxt8fdzwqs4b",
        "cmbhuy2q40075hxt8cr97blxk",
        "cmbhuy2qq0076hxt8m3fpwumd",
        "cmbhuy2rf0077hxt8m94ldvxm",
        "cmbhuy2s50078hxt8jvhpsvfe",
        "cmbhuy2su0079hxt8yxbqxsw9",
        "cmbhuy2to007ahxt8ilyp40ji",
        "cmbhuy2ui007bhxt8hgk2w0pl",
        "cmbhuy2v8007chxt8e7bupdkv",
        "cmbhuy2vz007dhxt8ccxe4r3h",
        "cmbhuy2wq007ehxt81fty1pdt"
      ],
      "Функции (дженерики)": [
        "cmbhuy2xh007fhxt8edo8sk4e",
        "cmbhuy2y9007ghxt8lfyjm59h",
        "cmbhuy2z0007hhxt87xuvf2xs",
        "cmbhuy2zt007ihxt8bdmtcpjw",
        "cmbhuy30p007jhxt8bg5ixnq1",
        "cmbhuy31f007khxt80sddujss",
        "cmbhuy325007lhxt86vgypxw2",
        "cmbhuy32v007mhxt8k4ik2zgo",
        "cmbhuy33l007nhxt8sa859h13",
        "cmbhuy34c007ohxt8v6ttstm0",
        "cmbhuy352007phxt8cjjtlth4",
        "cmbhuy35t007qhxt8x4cgbbz6",
        "cmbhuy36i007rhxt8fn97eyx2"
      ],
      "Основные": [
        "cmbhuy3v1008ahxt8atag4bgu",
        "cmbhuy3tm0088hxt834j8dyun",
        "cmbhuy3uc0089hxt8krntlulu",
        "cmbhuy3vr008bhxt8n8pagldu",
        "cmbhuy3wh008chxt84npe05nn",
        "cmbhuy3x8008dhxt8op0ca7dv",
        "cmbhuy3xy008ehxt8p1upb3mt",
        "cmbhuy3sl0087hxt862ok8q55"
      ],
      "Кастомные Utility": [
        "cmbhuy37b007shxt89u9en64j",
        "cmbhuy380007thxt8ghmr7d9w",
        "cmbhuy38q007uhxt8ytt6q6au",
        "cmbhuy39g007vhxt8n81pfqi4",
        "cmbhuy3a5007whxt8uubhszum"
      ],
      "Types": [
        "cmbhuy3au007xhxt89b9es3au",
        "cmbhuy3bk007yhxt8a122lgc4",
        "cmbhuy3cb007zhxt8puxkl9g5",
        "cmbhuy3d00080hxt8mdxc84cu",
        "cmbhuy3dq0081hxt841clr2fy",
        "cmbhuy3ee0082hxt8dp83qyyf",
        "cmbhuy3f60083hxt8dfggnqaq",
        "cmbhuy3fv0084hxt8n2w0kc2z",
        "cmbhuy3gm0085hxt8r7wtl17m"
      ],
      "Остальные": [
        "cmbhuy3yo008fhxt8xelf9055",
        "cmbhuy3ze008ghxt8vkuo0bfz",
        "cmbhuy404008hhxt8va6h5gkk",
        "cmbhuy40u008ihxt84rm3e87z",
        "cmbhuy41k008jhxt8567luw6d",
        "cmbhuy42a008khxt82nf2thrd"
      ]
    }
  },
  "pedagogical_analysis": {
    "explanation_count": 0,
    "example_count": 41,
    "exercise_count": 107,
    "challenge_count": 0,
    "practice_count": 121
  },
  "user_statistics": {
    "cmbhuy3sl0087hxt862ok8q55": {
      "total_users": 1,
      "solved_users": 1,
      "success_rate": 1.0,
      "avg_attempts": 3.0
    },
    "cmbhuxtvk001uhxt8fcidaqns": {
      "total_users": 1,
      "solved_users": 1,
      "success_rate": 1.0,
      "avg_attempts": 1.0
    }
  },
  "summary_stats": {
    "total_tasks": 269,
    "by_category": {
      "JS": 184,
      "REACT": 24,
      "TS": 61
    },
    "by_skill_level": {
      "intermediate": 153,
      "advanced": 82,
      "beginner": 34
    },
    "complexity_distribution": {
      "min": 0.0,
      "max": 10.5,
      "avg": 1.912639405204461
    },
    "most_common_concepts": [
      [
        "functions",
        219
      ],
      [
        "regex",
        208
      ],
      [
        "variables",
        201
      ],
      [
        "arrow_functions",
        144
      ],
      [
        "conditionals",
        126
      ],
      [
        "loops",
        124
      ],
      [
        "destructuring",
        117
      ],
      [
        "arrays",
        97
      ],
      [
        "strings",
        87
      ],
      [
        "functional",
        66
      ],
      [
        "spread_operator",
        57
      ],
      [
        "objects",
        56
      ],
      [
        "classes",
        43
      ],
      [
        "template_literals",
        30
      ],
      [
        "sorting",
        26
      ],
      [
        "error_handling",
        26
      ],
      [
        "async",
        24
      ],
      [
        "searching",
        12
      ],
      [
        "recursion",
        7
      ],
      [
        "events",
        5
      ]
    ],
    "most_common_features": [
      [
        "arrow_functions",
        144
      ],
      [
        "spread_operator",
        52
      ],
      [
        "inheritance",
        31
      ],
      [
        "array_reduce",
        28
      ],
      [
        "template_literals",
        21
      ],
      [
        "array_forEach",
        20
      ],
      [
        "promises",
        20
      ],
      [
        "es6_classes",
        14
      ],
      [
        "array_filter",
        13
      ],
      [
        "constructor",
        13
      ],
      [
        "array_map",
        10
      ],
      [
        "async_await",
        10
      ],
      [
        "array_destructuring",
        7
      ],
      [
        "object_destructuring",
        2
      ],
      [
        "array_some",
        1
      ]
    ],
    "estimated_total_time_hours": 209.18333333333334
  }
}